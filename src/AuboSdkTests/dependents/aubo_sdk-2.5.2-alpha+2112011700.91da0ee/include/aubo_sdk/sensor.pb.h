// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor.proto

#ifndef PROTOBUF_INCLUDED_sensor_2eproto
#define PROTOBUF_INCLUDED_sensor_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "robotcommon.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensor_2eproto 

namespace protobuf_sensor_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensor_2eproto
namespace peripheral {
class ProtoFtSensorCalibParam;
class ProtoFtSensorCalibParamDefaultTypeInternal;
extern ProtoFtSensorCalibParamDefaultTypeInternal _ProtoFtSensorCalibParam_default_instance_;
class ProtoFtSensorCalibResult;
class ProtoFtSensorCalibResultDefaultTypeInternal;
extern ProtoFtSensorCalibResultDefaultTypeInternal _ProtoFtSensorCalibResult_default_instance_;
class ProtoResponseFtSensorCalibResult;
class ProtoResponseFtSensorCalibResultDefaultTypeInternal;
extern ProtoResponseFtSensorCalibResultDefaultTypeInternal _ProtoResponseFtSensorCalibResult_default_instance_;
class ProtoResponseWrench;
class ProtoResponseWrenchDefaultTypeInternal;
extern ProtoResponseWrenchDefaultTypeInternal _ProtoResponseWrench_default_instance_;
class ProtoWrench;
class ProtoWrenchDefaultTypeInternal;
extern ProtoWrenchDefaultTypeInternal _ProtoWrench_default_instance_;
}  // namespace peripheral
namespace google {
namespace protobuf {
template<> ::peripheral::ProtoFtSensorCalibParam* Arena::CreateMaybeMessage<::peripheral::ProtoFtSensorCalibParam>(Arena*);
template<> ::peripheral::ProtoFtSensorCalibResult* Arena::CreateMaybeMessage<::peripheral::ProtoFtSensorCalibResult>(Arena*);
template<> ::peripheral::ProtoResponseFtSensorCalibResult* Arena::CreateMaybeMessage<::peripheral::ProtoResponseFtSensorCalibResult>(Arena*);
template<> ::peripheral::ProtoResponseWrench* Arena::CreateMaybeMessage<::peripheral::ProtoResponseWrench>(Arena*);
template<> ::peripheral::ProtoWrench* Arena::CreateMaybeMessage<::peripheral::ProtoWrench>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace peripheral {

// ===================================================================

class ProtoWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:peripheral.ProtoWrench) */ {
 public:
  ProtoWrench();
  virtual ~ProtoWrench();

  ProtoWrench(const ProtoWrench& from);

  inline ProtoWrench& operator=(const ProtoWrench& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoWrench(ProtoWrench&& from) noexcept
    : ProtoWrench() {
    *this = ::std::move(from);
  }

  inline ProtoWrench& operator=(ProtoWrench&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoWrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoWrench* internal_default_instance() {
    return reinterpret_cast<const ProtoWrench*>(
               &_ProtoWrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProtoWrench* other);
  friend void swap(ProtoWrench& a, ProtoWrench& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoWrench* New() const final {
    return CreateMaybeMessage<ProtoWrench>(NULL);
  }

  ProtoWrench* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoWrench>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoWrench& from);
  void MergeFrom(const ProtoWrench& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double force = 1;
  int force_size() const;
  void clear_force();
  static const int kForceFieldNumber = 1;
  double force(int index) const;
  void set_force(int index, double value);
  void add_force(double value);
  const ::google::protobuf::RepeatedField< double >&
      force() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_force();

  // repeated double torque = 2;
  int torque_size() const;
  void clear_torque();
  static const int kTorqueFieldNumber = 2;
  double torque(int index) const;
  void set_torque(int index, double value);
  void add_torque(double value);
  const ::google::protobuf::RepeatedField< double >&
      torque() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_torque();

  // @@protoc_insertion_point(class_scope:peripheral.ProtoWrench)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > force_;
  ::google::protobuf::RepeatedField< double > torque_;
  friend struct ::protobuf_sensor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoResponseWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:peripheral.ProtoResponseWrench) */ {
 public:
  ProtoResponseWrench();
  virtual ~ProtoResponseWrench();

  ProtoResponseWrench(const ProtoResponseWrench& from);

  inline ProtoResponseWrench& operator=(const ProtoResponseWrench& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoResponseWrench(ProtoResponseWrench&& from) noexcept
    : ProtoResponseWrench() {
    *this = ::std::move(from);
  }

  inline ProtoResponseWrench& operator=(ProtoResponseWrench&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoResponseWrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoResponseWrench* internal_default_instance() {
    return reinterpret_cast<const ProtoResponseWrench*>(
               &_ProtoResponseWrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProtoResponseWrench* other);
  friend void swap(ProtoResponseWrench& a, ProtoResponseWrench& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoResponseWrench* New() const final {
    return CreateMaybeMessage<ProtoResponseWrench>(NULL);
  }

  ProtoResponseWrench* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoResponseWrench>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoResponseWrench& from);
  void MergeFrom(const ProtoResponseWrench& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoResponseWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .peripheral.ProtoWrench wrench = 1;
  int wrench_size() const;
  void clear_wrench();
  static const int kWrenchFieldNumber = 1;
  ::peripheral::ProtoWrench* mutable_wrench(int index);
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >*
      mutable_wrench();
  const ::peripheral::ProtoWrench& wrench(int index) const;
  ::peripheral::ProtoWrench* add_wrench();
  const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >&
      wrench() const;

  // required .aubo.robot.common.RobotCommonResponse errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  private:
  const ::aubo::robot::common::RobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::common::RobotCommonResponse& errorinfo() const;
  ::aubo::robot::common::RobotCommonResponse* release_errorinfo();
  ::aubo::robot::common::RobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::common::RobotCommonResponse* errorinfo);

  // @@protoc_insertion_point(class_scope:peripheral.ProtoResponseWrench)
 private:
  void set_has_errorinfo();
  void clear_has_errorinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench > wrench_;
  ::aubo::robot::common::RobotCommonResponse* errorinfo_;
  friend struct ::protobuf_sensor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoFtSensorCalibParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:peripheral.ProtoFtSensorCalibParam) */ {
 public:
  ProtoFtSensorCalibParam();
  virtual ~ProtoFtSensorCalibParam();

  ProtoFtSensorCalibParam(const ProtoFtSensorCalibParam& from);

  inline ProtoFtSensorCalibParam& operator=(const ProtoFtSensorCalibParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoFtSensorCalibParam(ProtoFtSensorCalibParam&& from) noexcept
    : ProtoFtSensorCalibParam() {
    *this = ::std::move(from);
  }

  inline ProtoFtSensorCalibParam& operator=(ProtoFtSensorCalibParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoFtSensorCalibParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoFtSensorCalibParam* internal_default_instance() {
    return reinterpret_cast<const ProtoFtSensorCalibParam*>(
               &_ProtoFtSensorCalibParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProtoFtSensorCalibParam* other);
  friend void swap(ProtoFtSensorCalibParam& a, ProtoFtSensorCalibParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoFtSensorCalibParam* New() const final {
    return CreateMaybeMessage<ProtoFtSensorCalibParam>(NULL);
  }

  ProtoFtSensorCalibParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoFtSensorCalibParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoFtSensorCalibParam& from);
  void MergeFrom(const ProtoFtSensorCalibParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoFtSensorCalibParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.common.ProtoJointAngle jointAngle = 1;
  int jointangle_size() const;
  void clear_jointangle();
  static const int kJointAngleFieldNumber = 1;
  ::aubo::robot::common::ProtoJointAngle* mutable_jointangle(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::common::ProtoJointAngle >*
      mutable_jointangle();
  const ::aubo::robot::common::ProtoJointAngle& jointangle(int index) const;
  ::aubo::robot::common::ProtoJointAngle* add_jointangle();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::common::ProtoJointAngle >&
      jointangle() const;

  // repeated .peripheral.ProtoWrench wrenchList = 2;
  int wrenchlist_size() const;
  void clear_wrenchlist();
  static const int kWrenchListFieldNumber = 2;
  ::peripheral::ProtoWrench* mutable_wrenchlist(int index);
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >*
      mutable_wrenchlist();
  const ::peripheral::ProtoWrench& wrenchlist(int index) const;
  ::peripheral::ProtoWrench* add_wrenchlist();
  const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >&
      wrenchlist() const;

  // @@protoc_insertion_point(class_scope:peripheral.ProtoFtSensorCalibParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::common::ProtoJointAngle > jointangle_;
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench > wrenchlist_;
  friend struct ::protobuf_sensor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoFtSensorCalibResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:peripheral.ProtoFtSensorCalibResult) */ {
 public:
  ProtoFtSensorCalibResult();
  virtual ~ProtoFtSensorCalibResult();

  ProtoFtSensorCalibResult(const ProtoFtSensorCalibResult& from);

  inline ProtoFtSensorCalibResult& operator=(const ProtoFtSensorCalibResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoFtSensorCalibResult(ProtoFtSensorCalibResult&& from) noexcept
    : ProtoFtSensorCalibResult() {
    *this = ::std::move(from);
  }

  inline ProtoFtSensorCalibResult& operator=(ProtoFtSensorCalibResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoFtSensorCalibResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoFtSensorCalibResult* internal_default_instance() {
    return reinterpret_cast<const ProtoFtSensorCalibResult*>(
               &_ProtoFtSensorCalibResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProtoFtSensorCalibResult* other);
  friend void swap(ProtoFtSensorCalibResult& a, ProtoFtSensorCalibResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoFtSensorCalibResult* New() const final {
    return CreateMaybeMessage<ProtoFtSensorCalibResult>(NULL);
  }

  ProtoFtSensorCalibResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoFtSensorCalibResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoFtSensorCalibResult& from);
  void MergeFrom(const ProtoFtSensorCalibResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoFtSensorCalibResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double centroid = 3;
  int centroid_size() const;
  void clear_centroid();
  static const int kCentroidFieldNumber = 3;
  double centroid(int index) const;
  void set_centroid(int index, double value);
  void add_centroid(double value);
  const ::google::protobuf::RepeatedField< double >&
      centroid() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_centroid();

  // repeated double angle = 4;
  int angle_size() const;
  void clear_angle();
  static const int kAngleFieldNumber = 4;
  double angle(int index) const;
  void set_angle(int index, double value);
  void add_angle(double value);
  const ::google::protobuf::RepeatedField< double >&
      angle() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_angle();

  // required .peripheral.ProtoWrench wrench = 1;
  bool has_wrench() const;
  void clear_wrench();
  static const int kWrenchFieldNumber = 1;
  private:
  const ::peripheral::ProtoWrench& _internal_wrench() const;
  public:
  const ::peripheral::ProtoWrench& wrench() const;
  ::peripheral::ProtoWrench* release_wrench();
  ::peripheral::ProtoWrench* mutable_wrench();
  void set_allocated_wrench(::peripheral::ProtoWrench* wrench);

  // required double mass = 2;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 2;
  double mass() const;
  void set_mass(double value);

  // @@protoc_insertion_point(class_scope:peripheral.ProtoFtSensorCalibResult)
 private:
  void set_has_wrench();
  void clear_has_wrench();
  void set_has_mass();
  void clear_has_mass();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > centroid_;
  ::google::protobuf::RepeatedField< double > angle_;
  ::peripheral::ProtoWrench* wrench_;
  double mass_;
  friend struct ::protobuf_sensor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoResponseFtSensorCalibResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:peripheral.ProtoResponseFtSensorCalibResult) */ {
 public:
  ProtoResponseFtSensorCalibResult();
  virtual ~ProtoResponseFtSensorCalibResult();

  ProtoResponseFtSensorCalibResult(const ProtoResponseFtSensorCalibResult& from);

  inline ProtoResponseFtSensorCalibResult& operator=(const ProtoResponseFtSensorCalibResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoResponseFtSensorCalibResult(ProtoResponseFtSensorCalibResult&& from) noexcept
    : ProtoResponseFtSensorCalibResult() {
    *this = ::std::move(from);
  }

  inline ProtoResponseFtSensorCalibResult& operator=(ProtoResponseFtSensorCalibResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoResponseFtSensorCalibResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoResponseFtSensorCalibResult* internal_default_instance() {
    return reinterpret_cast<const ProtoResponseFtSensorCalibResult*>(
               &_ProtoResponseFtSensorCalibResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProtoResponseFtSensorCalibResult* other);
  friend void swap(ProtoResponseFtSensorCalibResult& a, ProtoResponseFtSensorCalibResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoResponseFtSensorCalibResult* New() const final {
    return CreateMaybeMessage<ProtoResponseFtSensorCalibResult>(NULL);
  }

  ProtoResponseFtSensorCalibResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoResponseFtSensorCalibResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoResponseFtSensorCalibResult& from);
  void MergeFrom(const ProtoResponseFtSensorCalibResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoResponseFtSensorCalibResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .peripheral.ProtoFtSensorCalibResult ftSensorCalibResult = 1;
  int ftsensorcalibresult_size() const;
  void clear_ftsensorcalibresult();
  static const int kFtSensorCalibResultFieldNumber = 1;
  ::peripheral::ProtoFtSensorCalibResult* mutable_ftsensorcalibresult(int index);
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoFtSensorCalibResult >*
      mutable_ftsensorcalibresult();
  const ::peripheral::ProtoFtSensorCalibResult& ftsensorcalibresult(int index) const;
  ::peripheral::ProtoFtSensorCalibResult* add_ftsensorcalibresult();
  const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoFtSensorCalibResult >&
      ftsensorcalibresult() const;

  // required .aubo.robot.common.RobotCommonResponse errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  private:
  const ::aubo::robot::common::RobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::common::RobotCommonResponse& errorinfo() const;
  ::aubo::robot::common::RobotCommonResponse* release_errorinfo();
  ::aubo::robot::common::RobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::common::RobotCommonResponse* errorinfo);

  // @@protoc_insertion_point(class_scope:peripheral.ProtoResponseFtSensorCalibResult)
 private:
  void set_has_errorinfo();
  void clear_has_errorinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoFtSensorCalibResult > ftsensorcalibresult_;
  ::aubo::robot::common::RobotCommonResponse* errorinfo_;
  friend struct ::protobuf_sensor_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoWrench

// repeated double force = 1;
inline int ProtoWrench::force_size() const {
  return force_.size();
}
inline void ProtoWrench::clear_force() {
  force_.Clear();
}
inline double ProtoWrench::force(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoWrench.force)
  return force_.Get(index);
}
inline void ProtoWrench::set_force(int index, double value) {
  force_.Set(index, value);
  // @@protoc_insertion_point(field_set:peripheral.ProtoWrench.force)
}
inline void ProtoWrench::add_force(double value) {
  force_.Add(value);
  // @@protoc_insertion_point(field_add:peripheral.ProtoWrench.force)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoWrench::force() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoWrench.force)
  return force_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoWrench::mutable_force() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoWrench.force)
  return &force_;
}

// repeated double torque = 2;
inline int ProtoWrench::torque_size() const {
  return torque_.size();
}
inline void ProtoWrench::clear_torque() {
  torque_.Clear();
}
inline double ProtoWrench::torque(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoWrench.torque)
  return torque_.Get(index);
}
inline void ProtoWrench::set_torque(int index, double value) {
  torque_.Set(index, value);
  // @@protoc_insertion_point(field_set:peripheral.ProtoWrench.torque)
}
inline void ProtoWrench::add_torque(double value) {
  torque_.Add(value);
  // @@protoc_insertion_point(field_add:peripheral.ProtoWrench.torque)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoWrench::torque() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoWrench.torque)
  return torque_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoWrench::mutable_torque() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoWrench.torque)
  return &torque_;
}

// -------------------------------------------------------------------

// ProtoResponseWrench

// repeated .peripheral.ProtoWrench wrench = 1;
inline int ProtoResponseWrench::wrench_size() const {
  return wrench_.size();
}
inline void ProtoResponseWrench::clear_wrench() {
  wrench_.Clear();
}
inline ::peripheral::ProtoWrench* ProtoResponseWrench::mutable_wrench(int index) {
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoResponseWrench.wrench)
  return wrench_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >*
ProtoResponseWrench::mutable_wrench() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoResponseWrench.wrench)
  return &wrench_;
}
inline const ::peripheral::ProtoWrench& ProtoResponseWrench::wrench(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoResponseWrench.wrench)
  return wrench_.Get(index);
}
inline ::peripheral::ProtoWrench* ProtoResponseWrench::add_wrench() {
  // @@protoc_insertion_point(field_add:peripheral.ProtoResponseWrench.wrench)
  return wrench_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >&
ProtoResponseWrench::wrench() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoResponseWrench.wrench)
  return wrench_;
}

// required .aubo.robot.common.RobotCommonResponse errorInfo = 2;
inline bool ProtoResponseWrench::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoResponseWrench::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoResponseWrench::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::aubo::robot::common::RobotCommonResponse& ProtoResponseWrench::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::common::RobotCommonResponse& ProtoResponseWrench::errorinfo() const {
  const ::aubo::robot::common::RobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:peripheral.ProtoResponseWrench.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::common::RobotCommonResponse*>(
      &::aubo::robot::common::_RobotCommonResponse_default_instance_);
}
inline ::aubo::robot::common::RobotCommonResponse* ProtoResponseWrench::release_errorinfo() {
  // @@protoc_insertion_point(field_release:peripheral.ProtoResponseWrench.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::common::RobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::common::RobotCommonResponse* ProtoResponseWrench::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::common::RobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoResponseWrench.errorInfo)
  return errorinfo_;
}
inline void ProtoResponseWrench::set_allocated_errorinfo(::aubo::robot::common::RobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(errorinfo_);
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:peripheral.ProtoResponseWrench.errorInfo)
}

// -------------------------------------------------------------------

// ProtoFtSensorCalibParam

// repeated .aubo.robot.common.ProtoJointAngle jointAngle = 1;
inline int ProtoFtSensorCalibParam::jointangle_size() const {
  return jointangle_.size();
}
inline ::aubo::robot::common::ProtoJointAngle* ProtoFtSensorCalibParam::mutable_jointangle(int index) {
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoFtSensorCalibParam.jointAngle)
  return jointangle_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::common::ProtoJointAngle >*
ProtoFtSensorCalibParam::mutable_jointangle() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoFtSensorCalibParam.jointAngle)
  return &jointangle_;
}
inline const ::aubo::robot::common::ProtoJointAngle& ProtoFtSensorCalibParam::jointangle(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibParam.jointAngle)
  return jointangle_.Get(index);
}
inline ::aubo::robot::common::ProtoJointAngle* ProtoFtSensorCalibParam::add_jointangle() {
  // @@protoc_insertion_point(field_add:peripheral.ProtoFtSensorCalibParam.jointAngle)
  return jointangle_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::common::ProtoJointAngle >&
ProtoFtSensorCalibParam::jointangle() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoFtSensorCalibParam.jointAngle)
  return jointangle_;
}

// repeated .peripheral.ProtoWrench wrenchList = 2;
inline int ProtoFtSensorCalibParam::wrenchlist_size() const {
  return wrenchlist_.size();
}
inline void ProtoFtSensorCalibParam::clear_wrenchlist() {
  wrenchlist_.Clear();
}
inline ::peripheral::ProtoWrench* ProtoFtSensorCalibParam::mutable_wrenchlist(int index) {
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoFtSensorCalibParam.wrenchList)
  return wrenchlist_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >*
ProtoFtSensorCalibParam::mutable_wrenchlist() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoFtSensorCalibParam.wrenchList)
  return &wrenchlist_;
}
inline const ::peripheral::ProtoWrench& ProtoFtSensorCalibParam::wrenchlist(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibParam.wrenchList)
  return wrenchlist_.Get(index);
}
inline ::peripheral::ProtoWrench* ProtoFtSensorCalibParam::add_wrenchlist() {
  // @@protoc_insertion_point(field_add:peripheral.ProtoFtSensorCalibParam.wrenchList)
  return wrenchlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoWrench >&
ProtoFtSensorCalibParam::wrenchlist() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoFtSensorCalibParam.wrenchList)
  return wrenchlist_;
}

// -------------------------------------------------------------------

// ProtoFtSensorCalibResult

// required .peripheral.ProtoWrench wrench = 1;
inline bool ProtoFtSensorCalibResult::has_wrench() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoFtSensorCalibResult::set_has_wrench() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoFtSensorCalibResult::clear_has_wrench() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoFtSensorCalibResult::clear_wrench() {
  if (wrench_ != NULL) wrench_->Clear();
  clear_has_wrench();
}
inline const ::peripheral::ProtoWrench& ProtoFtSensorCalibResult::_internal_wrench() const {
  return *wrench_;
}
inline const ::peripheral::ProtoWrench& ProtoFtSensorCalibResult::wrench() const {
  const ::peripheral::ProtoWrench* p = wrench_;
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibResult.wrench)
  return p != NULL ? *p : *reinterpret_cast<const ::peripheral::ProtoWrench*>(
      &::peripheral::_ProtoWrench_default_instance_);
}
inline ::peripheral::ProtoWrench* ProtoFtSensorCalibResult::release_wrench() {
  // @@protoc_insertion_point(field_release:peripheral.ProtoFtSensorCalibResult.wrench)
  clear_has_wrench();
  ::peripheral::ProtoWrench* temp = wrench_;
  wrench_ = NULL;
  return temp;
}
inline ::peripheral::ProtoWrench* ProtoFtSensorCalibResult::mutable_wrench() {
  set_has_wrench();
  if (wrench_ == NULL) {
    auto* p = CreateMaybeMessage<::peripheral::ProtoWrench>(GetArenaNoVirtual());
    wrench_ = p;
  }
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoFtSensorCalibResult.wrench)
  return wrench_;
}
inline void ProtoFtSensorCalibResult::set_allocated_wrench(::peripheral::ProtoWrench* wrench) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wrench_;
  }
  if (wrench) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wrench = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wrench, submessage_arena);
    }
    set_has_wrench();
  } else {
    clear_has_wrench();
  }
  wrench_ = wrench;
  // @@protoc_insertion_point(field_set_allocated:peripheral.ProtoFtSensorCalibResult.wrench)
}

// required double mass = 2;
inline bool ProtoFtSensorCalibResult::has_mass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoFtSensorCalibResult::set_has_mass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoFtSensorCalibResult::clear_has_mass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoFtSensorCalibResult::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double ProtoFtSensorCalibResult::mass() const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibResult.mass)
  return mass_;
}
inline void ProtoFtSensorCalibResult::set_mass(double value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:peripheral.ProtoFtSensorCalibResult.mass)
}

// repeated double centroid = 3;
inline int ProtoFtSensorCalibResult::centroid_size() const {
  return centroid_.size();
}
inline void ProtoFtSensorCalibResult::clear_centroid() {
  centroid_.Clear();
}
inline double ProtoFtSensorCalibResult::centroid(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibResult.centroid)
  return centroid_.Get(index);
}
inline void ProtoFtSensorCalibResult::set_centroid(int index, double value) {
  centroid_.Set(index, value);
  // @@protoc_insertion_point(field_set:peripheral.ProtoFtSensorCalibResult.centroid)
}
inline void ProtoFtSensorCalibResult::add_centroid(double value) {
  centroid_.Add(value);
  // @@protoc_insertion_point(field_add:peripheral.ProtoFtSensorCalibResult.centroid)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoFtSensorCalibResult::centroid() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoFtSensorCalibResult.centroid)
  return centroid_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoFtSensorCalibResult::mutable_centroid() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoFtSensorCalibResult.centroid)
  return &centroid_;
}

// repeated double angle = 4;
inline int ProtoFtSensorCalibResult::angle_size() const {
  return angle_.size();
}
inline void ProtoFtSensorCalibResult::clear_angle() {
  angle_.Clear();
}
inline double ProtoFtSensorCalibResult::angle(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoFtSensorCalibResult.angle)
  return angle_.Get(index);
}
inline void ProtoFtSensorCalibResult::set_angle(int index, double value) {
  angle_.Set(index, value);
  // @@protoc_insertion_point(field_set:peripheral.ProtoFtSensorCalibResult.angle)
}
inline void ProtoFtSensorCalibResult::add_angle(double value) {
  angle_.Add(value);
  // @@protoc_insertion_point(field_add:peripheral.ProtoFtSensorCalibResult.angle)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoFtSensorCalibResult::angle() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoFtSensorCalibResult.angle)
  return angle_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoFtSensorCalibResult::mutable_angle() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoFtSensorCalibResult.angle)
  return &angle_;
}

// -------------------------------------------------------------------

// ProtoResponseFtSensorCalibResult

// repeated .peripheral.ProtoFtSensorCalibResult ftSensorCalibResult = 1;
inline int ProtoResponseFtSensorCalibResult::ftsensorcalibresult_size() const {
  return ftsensorcalibresult_.size();
}
inline void ProtoResponseFtSensorCalibResult::clear_ftsensorcalibresult() {
  ftsensorcalibresult_.Clear();
}
inline ::peripheral::ProtoFtSensorCalibResult* ProtoResponseFtSensorCalibResult::mutable_ftsensorcalibresult(int index) {
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoResponseFtSensorCalibResult.ftSensorCalibResult)
  return ftsensorcalibresult_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoFtSensorCalibResult >*
ProtoResponseFtSensorCalibResult::mutable_ftsensorcalibresult() {
  // @@protoc_insertion_point(field_mutable_list:peripheral.ProtoResponseFtSensorCalibResult.ftSensorCalibResult)
  return &ftsensorcalibresult_;
}
inline const ::peripheral::ProtoFtSensorCalibResult& ProtoResponseFtSensorCalibResult::ftsensorcalibresult(int index) const {
  // @@protoc_insertion_point(field_get:peripheral.ProtoResponseFtSensorCalibResult.ftSensorCalibResult)
  return ftsensorcalibresult_.Get(index);
}
inline ::peripheral::ProtoFtSensorCalibResult* ProtoResponseFtSensorCalibResult::add_ftsensorcalibresult() {
  // @@protoc_insertion_point(field_add:peripheral.ProtoResponseFtSensorCalibResult.ftSensorCalibResult)
  return ftsensorcalibresult_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::peripheral::ProtoFtSensorCalibResult >&
ProtoResponseFtSensorCalibResult::ftsensorcalibresult() const {
  // @@protoc_insertion_point(field_list:peripheral.ProtoResponseFtSensorCalibResult.ftSensorCalibResult)
  return ftsensorcalibresult_;
}

// required .aubo.robot.common.RobotCommonResponse errorInfo = 2;
inline bool ProtoResponseFtSensorCalibResult::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoResponseFtSensorCalibResult::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoResponseFtSensorCalibResult::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::aubo::robot::common::RobotCommonResponse& ProtoResponseFtSensorCalibResult::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::common::RobotCommonResponse& ProtoResponseFtSensorCalibResult::errorinfo() const {
  const ::aubo::robot::common::RobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:peripheral.ProtoResponseFtSensorCalibResult.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::common::RobotCommonResponse*>(
      &::aubo::robot::common::_RobotCommonResponse_default_instance_);
}
inline ::aubo::robot::common::RobotCommonResponse* ProtoResponseFtSensorCalibResult::release_errorinfo() {
  // @@protoc_insertion_point(field_release:peripheral.ProtoResponseFtSensorCalibResult.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::common::RobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::common::RobotCommonResponse* ProtoResponseFtSensorCalibResult::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::common::RobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:peripheral.ProtoResponseFtSensorCalibResult.errorInfo)
  return errorinfo_;
}
inline void ProtoResponseFtSensorCalibResult::set_allocated_errorinfo(::aubo::robot::common::RobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(errorinfo_);
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:peripheral.ProtoResponseFtSensorCalibResult.errorInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace peripheral

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensor_2eproto
