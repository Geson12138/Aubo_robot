// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robotmovecondition.proto

#ifndef PROTOBUF_INCLUDED_robotmovecondition_2eproto
#define PROTOBUF_INCLUDED_robotmovecondition_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_robotmovecondition_2eproto 

namespace protobuf_robotmovecondition_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_robotmovecondition_2eproto
namespace aubo {
namespace robot {
namespace movecondition {
}  // namespace movecondition
}  // namespace robot
}  // namespace aubo
namespace aubo {
namespace robot {
namespace movecondition {

enum robot_state {
  RobotStopped = 0,
  RobotRunning = 1,
  RobotPaused = 2,
  RobotResumed = 3
};
bool robot_state_IsValid(int value);
const robot_state robot_state_MIN = RobotStopped;
const robot_state robot_state_MAX = RobotResumed;
const int robot_state_ARRAYSIZE = robot_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* robot_state_descriptor();
inline const ::std::string& robot_state_Name(robot_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    robot_state_descriptor(), value);
}
inline bool robot_state_Parse(
    const ::std::string& name, robot_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<robot_state>(
    robot_state_descriptor(), name, value);
}
enum move_mode {
  NO_MOVEMODE = 0,
  MODEJ = 1,
  MODEL = 2,
  MODEP = 3
};
bool move_mode_IsValid(int value);
const move_mode move_mode_MIN = NO_MOVEMODE;
const move_mode move_mode_MAX = MODEP;
const int move_mode_ARRAYSIZE = move_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* move_mode_descriptor();
inline const ::std::string& move_mode_Name(move_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    move_mode_descriptor(), value);
}
inline bool move_mode_Parse(
    const ::std::string& name, move_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<move_mode>(
    move_mode_descriptor(), name, value);
}
enum move_track {
  NO_TRACK = 0,
  TRACKING = 1,
  ARC_CIR = 2,
  CARTESIAN_MOVEP = 3,
  CARTESIAN_CUBICSPLINE = 4,
  CARTESIAN_UBSPLINEINTP = 5,
  CARTESIAN_GNUBSPLINEINTP = 6,
  CARTESIAN_LOOKAHEAD = 7,
  JIONT_CUBICSPLINE = 8,
  JOINT_UBSPLINEINTP = 9,
  JOINT_GNUBSPLINEINTP = 10
};
bool move_track_IsValid(int value);
const move_track move_track_MIN = NO_TRACK;
const move_track move_track_MAX = JOINT_GNUBSPLINEINTP;
const int move_track_ARRAYSIZE = move_track_MAX + 1;

const ::google::protobuf::EnumDescriptor* move_track_descriptor();
inline const ::std::string& move_track_Name(move_track value) {
  return ::google::protobuf::internal::NameOfEnum(
    move_track_descriptor(), value);
}
inline bool move_track_Parse(
    const ::std::string& name, move_track* value) {
  return ::google::protobuf::internal::ParseNamedEnum<move_track>(
    move_track_descriptor(), name, value);
}
enum coordinate_refer {
  BaseCoordinate = 0,
  EndCoordinate = 1,
  WorldCoordinate = 2
};
bool coordinate_refer_IsValid(int value);
const coordinate_refer coordinate_refer_MIN = BaseCoordinate;
const coordinate_refer coordinate_refer_MAX = WorldCoordinate;
const int coordinate_refer_ARRAYSIZE = coordinate_refer_MAX + 1;

const ::google::protobuf::EnumDescriptor* coordinate_refer_descriptor();
inline const ::std::string& coordinate_refer_Name(coordinate_refer value) {
  return ::google::protobuf::internal::NameOfEnum(
    coordinate_refer_descriptor(), value);
}
inline bool coordinate_refer_Parse(
    const ::std::string& name, coordinate_refer* value) {
  return ::google::protobuf::internal::ParseNamedEnum<coordinate_refer>(
    coordinate_refer_descriptor(), name, value);
}
enum teach_mode {
  NO_TEACH = 0,
  JOINT1 = 1,
  JOINT2 = 2,
  JOINT3 = 3,
  JOINT4 = 4,
  JOINT5 = 5,
  JOINT6 = 6,
  MOV_X = 7,
  MOV_Y = 8,
  MOV_Z = 9,
  ROT_X = 10,
  ROT_Y = 11,
  ROT_Z = 12
};
bool teach_mode_IsValid(int value);
const teach_mode teach_mode_MIN = NO_TEACH;
const teach_mode teach_mode_MAX = ROT_Z;
const int teach_mode_ARRAYSIZE = teach_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* teach_mode_descriptor();
inline const ::std::string& teach_mode_Name(teach_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    teach_mode_descriptor(), value);
}
inline bool teach_mode_Parse(
    const ::std::string& name, teach_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<teach_mode>(
    teach_mode_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace movecondition
}  // namespace robot
}  // namespace aubo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aubo::robot::movecondition::robot_state> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::movecondition::robot_state>() {
  return ::aubo::robot::movecondition::robot_state_descriptor();
}
template <> struct is_proto_enum< ::aubo::robot::movecondition::move_mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::movecondition::move_mode>() {
  return ::aubo::robot::movecondition::move_mode_descriptor();
}
template <> struct is_proto_enum< ::aubo::robot::movecondition::move_track> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::movecondition::move_track>() {
  return ::aubo::robot::movecondition::move_track_descriptor();
}
template <> struct is_proto_enum< ::aubo::robot::movecondition::coordinate_refer> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::movecondition::coordinate_refer>() {
  return ::aubo::robot::movecondition::coordinate_refer_descriptor();
}
template <> struct is_proto_enum< ::aubo::robot::movecondition::teach_mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::movecondition::teach_mode>() {
  return ::aubo::robot::movecondition::teach_mode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_robotmovecondition_2eproto
