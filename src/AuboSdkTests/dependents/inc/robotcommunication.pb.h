// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robotcommunication.proto

#ifndef PROTOBUF_INCLUDED_robotcommunication_2eproto
#define PROTOBUF_INCLUDED_robotcommunication_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_robotcommunication_2eproto 

namespace protobuf_robotcommunication_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[41];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_robotcommunication_2eproto
namespace aubo {
namespace robot {
namespace communication {
class InterfaceBoardError;
class InterfaceBoardErrorDefaultTypeInternal;
extern InterfaceBoardErrorDefaultTypeInternal _InterfaceBoardError_default_instance_;
class JointStatus;
class JointStatusDefaultTypeInternal;
extern JointStatusDefaultTypeInternal _JointStatus_default_instance_;
class JointVersion;
class JointVersionDefaultTypeInternal;
extern JointVersionDefaultTypeInternal _JointVersion_default_instance_;
class ModbusCfg;
class ModbusCfgDefaultTypeInternal;
extern ModbusCfgDefaultTypeInternal _ModbusCfg_default_instance_;
class OriginPose;
class OriginPoseDefaultTypeInternal;
extern OriginPoseDefaultTypeInternal _OriginPose_default_instance_;
class OrpeSafetyStatus;
class OrpeSafetyStatusDefaultTypeInternal;
extern OrpeSafetyStatusDefaultTypeInternal _OrpeSafetyStatus_default_instance_;
class OurRobotDevInfo;
class OurRobotDevInfoDefaultTypeInternal;
extern OurRobotDevInfoDefaultTypeInternal _OurRobotDevInfo_default_instance_;
class ProtoCommunicationDoubleVector;
class ProtoCommunicationDoubleVectorDefaultTypeInternal;
extern ProtoCommunicationDoubleVectorDefaultTypeInternal _ProtoCommunicationDoubleVector_default_instance_;
class ProtoCommunicationDoubleVectorResponse;
class ProtoCommunicationDoubleVectorResponseDefaultTypeInternal;
extern ProtoCommunicationDoubleVectorResponseDefaultTypeInternal _ProtoCommunicationDoubleVectorResponse_default_instance_;
class ProtoCommunicationDynIdentifyResults;
class ProtoCommunicationDynIdentifyResultsDefaultTypeInternal;
extern ProtoCommunicationDynIdentifyResultsDefaultTypeInternal _ProtoCommunicationDynIdentifyResults_default_instance_;
class ProtoCommunicationEthernetDeviceNameResponse;
class ProtoCommunicationEthernetDeviceNameResponseDefaultTypeInternal;
extern ProtoCommunicationEthernetDeviceNameResponseDefaultTypeInternal _ProtoCommunicationEthernetDeviceNameResponse_default_instance_;
class ProtoCommunicationGeneralData;
class ProtoCommunicationGeneralDataDefaultTypeInternal;
extern ProtoCommunicationGeneralDataDefaultTypeInternal _ProtoCommunicationGeneralData_default_instance_;
class ProtoCommunicationIntVector;
class ProtoCommunicationIntVectorDefaultTypeInternal;
extern ProtoCommunicationIntVectorDefaultTypeInternal _ProtoCommunicationIntVector_default_instance_;
class ProtoCommunicationIntVectorResponse;
class ProtoCommunicationIntVectorResponseDefaultTypeInternal;
extern ProtoCommunicationIntVectorResponseDefaultTypeInternal _ProtoCommunicationIntVectorResponse_default_instance_;
class ProtoCommunicationOfflineExcitTraj;
class ProtoCommunicationOfflineExcitTrajDefaultTypeInternal;
extern ProtoCommunicationOfflineExcitTrajDefaultTypeInternal _ProtoCommunicationOfflineExcitTraj_default_instance_;
class ProtoCommunicationRobotAnalogIOData;
class ProtoCommunicationRobotAnalogIODataDefaultTypeInternal;
extern ProtoCommunicationRobotAnalogIODataDefaultTypeInternal _ProtoCommunicationRobotAnalogIOData_default_instance_;
class ProtoCommunicationRobotBoardFirmware;
class ProtoCommunicationRobotBoardFirmwareDefaultTypeInternal;
extern ProtoCommunicationRobotBoardFirmwareDefaultTypeInternal _ProtoCommunicationRobotBoardFirmware_default_instance_;
class ProtoCommunicationRobotDiagnosisIOData;
class ProtoCommunicationRobotDiagnosisIODataDefaultTypeInternal;
extern ProtoCommunicationRobotDiagnosisIODataDefaultTypeInternal _ProtoCommunicationRobotDiagnosisIOData_default_instance_;
class ProtoCommunicationRobotDiagnosisInfo;
class ProtoCommunicationRobotDiagnosisInfoDefaultTypeInternal;
extern ProtoCommunicationRobotDiagnosisInfoDefaultTypeInternal _ProtoCommunicationRobotDiagnosisInfo_default_instance_;
class ProtoCommunicationRobotEvent;
class ProtoCommunicationRobotEventDefaultTypeInternal;
extern ProtoCommunicationRobotEventDefaultTypeInternal _ProtoCommunicationRobotEvent_default_instance_;
class ProtoCommunicationRobotStartupProfile;
class ProtoCommunicationRobotStartupProfileDefaultTypeInternal;
extern ProtoCommunicationRobotStartupProfileDefaultTypeInternal _ProtoCommunicationRobotStartupProfile_default_instance_;
class ProtoCommunicationToolAllIOStatusInfoResponse;
class ProtoCommunicationToolAllIOStatusInfoResponseDefaultTypeInternal;
extern ProtoCommunicationToolAllIOStatusInfoResponseDefaultTypeInternal _ProtoCommunicationToolAllIOStatusInfoResponse_default_instance_;
class ProtoJointCommonData;
class ProtoJointCommonDataDefaultTypeInternal;
extern ProtoJointCommonDataDefaultTypeInternal _ProtoJointCommonData_default_instance_;
class ProtoJointCommonDataResponse;
class ProtoJointCommonDataResponseDefaultTypeInternal;
extern ProtoJointCommonDataResponseDefaultTypeInternal _ProtoJointCommonDataResponse_default_instance_;
class ProtoRequestLogin;
class ProtoRequestLoginDefaultTypeInternal;
extern ProtoRequestLoginDefaultTypeInternal _ProtoRequestLogin_default_instance_;
class ProtoRobotAnalogIODesc;
class ProtoRobotAnalogIODescDefaultTypeInternal;
extern ProtoRobotAnalogIODescDefaultTypeInternal _ProtoRobotAnalogIODesc_default_instance_;
class ProtoRobotCommonResponse;
class ProtoRobotCommonResponseDefaultTypeInternal;
extern ProtoRobotCommonResponseDefaultTypeInternal _ProtoRobotCommonResponse_default_instance_;
class ProtoRobotDiagnosisIODesc;
class ProtoRobotDiagnosisIODescDefaultTypeInternal;
extern ProtoRobotDiagnosisIODescDefaultTypeInternal _ProtoRobotDiagnosisIODesc_default_instance_;
class RobotCollisionCurrent;
class RobotCollisionCurrentDefaultTypeInternal;
extern RobotCollisionCurrentDefaultTypeInternal _RobotCollisionCurrent_default_instance_;
class RobotDiagnosis;
class RobotDiagnosisDefaultTypeInternal;
extern RobotDiagnosisDefaultTypeInternal _RobotDiagnosis_default_instance_;
class RobotExtDiagnosis;
class RobotExtDiagnosisDefaultTypeInternal;
extern RobotExtDiagnosisDefaultTypeInternal _RobotExtDiagnosis_default_instance_;
class RobotGravityComponent;
class RobotGravityComponentDefaultTypeInternal;
extern RobotGravityComponentDefaultTypeInternal _RobotGravityComponent_default_instance_;
class RobotSafetyConfig;
class RobotSafetyConfigDefaultTypeInternal;
extern RobotSafetyConfigDefaultTypeInternal _RobotSafetyConfig_default_instance_;
class RobotTcpParam;
class RobotTcpParamDefaultTypeInternal;
extern RobotTcpParamDefaultTypeInternal _RobotTcpParam_default_instance_;
class RobotToolConfig;
class RobotToolConfigDefaultTypeInternal;
extern RobotToolConfigDefaultTypeInternal _RobotToolConfig_default_instance_;
class RobotToolStatus;
class RobotToolStatusDefaultTypeInternal;
extern RobotToolStatusDefaultTypeInternal _RobotToolStatus_default_instance_;
class TagIoCfg;
class TagIoCfgDefaultTypeInternal;
extern TagIoCfgDefaultTypeInternal _TagIoCfg_default_instance_;
class TcpParam;
class TcpParamDefaultTypeInternal;
extern TcpParamDefaultTypeInternal _TcpParam_default_instance_;
class ToolDigitalStatus;
class ToolDigitalStatusDefaultTypeInternal;
extern ToolDigitalStatusDefaultTypeInternal _ToolDigitalStatus_default_instance_;
class protoSafeCommunicationParam;
class protoSafeCommunicationParamDefaultTypeInternal;
extern protoSafeCommunicationParamDefaultTypeInternal _protoSafeCommunicationParam_default_instance_;
class toolAllIOStatus;
class toolAllIOStatusDefaultTypeInternal;
extern toolAllIOStatusDefaultTypeInternal _toolAllIOStatus_default_instance_;
}  // namespace communication
}  // namespace robot
}  // namespace aubo
namespace google {
namespace protobuf {
template<> ::aubo::robot::communication::InterfaceBoardError* Arena::CreateMaybeMessage<::aubo::robot::communication::InterfaceBoardError>(Arena*);
template<> ::aubo::robot::communication::JointStatus* Arena::CreateMaybeMessage<::aubo::robot::communication::JointStatus>(Arena*);
template<> ::aubo::robot::communication::JointVersion* Arena::CreateMaybeMessage<::aubo::robot::communication::JointVersion>(Arena*);
template<> ::aubo::robot::communication::ModbusCfg* Arena::CreateMaybeMessage<::aubo::robot::communication::ModbusCfg>(Arena*);
template<> ::aubo::robot::communication::OriginPose* Arena::CreateMaybeMessage<::aubo::robot::communication::OriginPose>(Arena*);
template<> ::aubo::robot::communication::OrpeSafetyStatus* Arena::CreateMaybeMessage<::aubo::robot::communication::OrpeSafetyStatus>(Arena*);
template<> ::aubo::robot::communication::OurRobotDevInfo* Arena::CreateMaybeMessage<::aubo::robot::communication::OurRobotDevInfo>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationDoubleVector* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationDoubleVector>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationDoubleVectorResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationDoubleVectorResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationDynIdentifyResults* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationDynIdentifyResults>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationEthernetDeviceNameResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationEthernetDeviceNameResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationGeneralData* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationGeneralData>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationIntVector* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationIntVector>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationIntVectorResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationIntVectorResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationOfflineExcitTraj* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationOfflineExcitTraj>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotAnalogIOData* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotAnalogIOData>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotBoardFirmware* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotBoardFirmware>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotDiagnosisIOData* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotDiagnosisIOData>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotDiagnosisInfo* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotDiagnosisInfo>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotEvent* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotEvent>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationRobotStartupProfile* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationRobotStartupProfile>(Arena*);
template<> ::aubo::robot::communication::ProtoCommunicationToolAllIOStatusInfoResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoCommunicationToolAllIOStatusInfoResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoJointCommonData* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoJointCommonData>(Arena*);
template<> ::aubo::robot::communication::ProtoJointCommonDataResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoJointCommonDataResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoRequestLogin* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoRequestLogin>(Arena*);
template<> ::aubo::robot::communication::ProtoRobotAnalogIODesc* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoRobotAnalogIODesc>(Arena*);
template<> ::aubo::robot::communication::ProtoRobotCommonResponse* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(Arena*);
template<> ::aubo::robot::communication::ProtoRobotDiagnosisIODesc* Arena::CreateMaybeMessage<::aubo::robot::communication::ProtoRobotDiagnosisIODesc>(Arena*);
template<> ::aubo::robot::communication::RobotCollisionCurrent* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotCollisionCurrent>(Arena*);
template<> ::aubo::robot::communication::RobotDiagnosis* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotDiagnosis>(Arena*);
template<> ::aubo::robot::communication::RobotExtDiagnosis* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotExtDiagnosis>(Arena*);
template<> ::aubo::robot::communication::RobotGravityComponent* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotGravityComponent>(Arena*);
template<> ::aubo::robot::communication::RobotSafetyConfig* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotSafetyConfig>(Arena*);
template<> ::aubo::robot::communication::RobotTcpParam* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotTcpParam>(Arena*);
template<> ::aubo::robot::communication::RobotToolConfig* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotToolConfig>(Arena*);
template<> ::aubo::robot::communication::RobotToolStatus* Arena::CreateMaybeMessage<::aubo::robot::communication::RobotToolStatus>(Arena*);
template<> ::aubo::robot::communication::TagIoCfg* Arena::CreateMaybeMessage<::aubo::robot::communication::TagIoCfg>(Arena*);
template<> ::aubo::robot::communication::TcpParam* Arena::CreateMaybeMessage<::aubo::robot::communication::TcpParam>(Arena*);
template<> ::aubo::robot::communication::ToolDigitalStatus* Arena::CreateMaybeMessage<::aubo::robot::communication::ToolDigitalStatus>(Arena*);
template<> ::aubo::robot::communication::protoSafeCommunicationParam* Arena::CreateMaybeMessage<::aubo::robot::communication::protoSafeCommunicationParam>(Arena*);
template<> ::aubo::robot::communication::toolAllIOStatus* Arena::CreateMaybeMessage<::aubo::robot::communication::toolAllIOStatus>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace aubo {
namespace robot {
namespace communication {

enum ModbusMode {
  MODBUS_MODE_TCP = 0,
  MODBUS_MODE_RTU = 1
};
bool ModbusMode_IsValid(int value);
const ModbusMode ModbusMode_MIN = MODBUS_MODE_TCP;
const ModbusMode ModbusMode_MAX = MODBUS_MODE_RTU;
const int ModbusMode_ARRAYSIZE = ModbusMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModbusMode_descriptor();
inline const ::std::string& ModbusMode_Name(ModbusMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModbusMode_descriptor(), value);
}
inline bool ModbusMode_Parse(
    const ::std::string& name, ModbusMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModbusMode>(
    ModbusMode_descriptor(), name, value);
}
enum TagIoType {
  USER_MODBUS_DI = 0,
  USER_MODBUS_DO = 1,
  USER_MODBUS_AI = 2,
  USER_MODBUS_AO = 3,
  ROBOT_BOARD_SAFE_DI = 4,
  ROBOT_BOARD_SAFE_DO = 5,
  ROBOT_BOARD_INTERNAL_DI = 6,
  ROBOT_BOARD_INTERNAL_DO = 7,
  ROBOT_BOARD_LINKAGE_DI = 8,
  ROBOT_BOARD_LINKAGE_DO = 9,
  ROBOT_BOARD_DPROJECT_DI = 10,
  ROBOT_BOARD_USER_AI = 11,
  ROBOT_BOARD_USER_AO = 12,
  ROBOT_BOARD_USER_DI = 13,
  ROBOT_BOARD_USER_DO = 14,
  ROBOT_TOOL_DI = 15,
  ROBOT_TOOL_DO = 16,
  ROBOT_TOOL_AI = 17,
  ROBOT_TOOL_AO = 18
};
bool TagIoType_IsValid(int value);
const TagIoType TagIoType_MIN = USER_MODBUS_DI;
const TagIoType TagIoType_MAX = ROBOT_TOOL_AO;
const int TagIoType_ARRAYSIZE = TagIoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TagIoType_descriptor();
inline const ::std::string& TagIoType_Name(TagIoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TagIoType_descriptor(), value);
}
inline bool TagIoType_Parse(
    const ::std::string& name, TagIoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TagIoType>(
    TagIoType_descriptor(), name, value);
}
// ===================================================================

class JointStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.JointStatus) */ {
 public:
  JointStatus();
  virtual ~JointStatus();

  JointStatus(const JointStatus& from);

  inline JointStatus& operator=(const JointStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointStatus(JointStatus&& from) noexcept
    : JointStatus() {
    *this = ::std::move(from);
  }

  inline JointStatus& operator=(JointStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointStatus* internal_default_instance() {
    return reinterpret_cast<const JointStatus*>(
               &_JointStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(JointStatus* other);
  friend void swap(JointStatus& a, JointStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointStatus* New() const final {
    return CreateMaybeMessage<JointStatus>(NULL);
  }

  JointStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JointStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JointStatus& from);
  void MergeFrom(const JointStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 jointCurrentI = 1;
  bool has_jointcurrenti() const;
  void clear_jointcurrenti();
  static const int kJointCurrentIFieldNumber = 1;
  ::google::protobuf::int32 jointcurrenti() const;
  void set_jointcurrenti(::google::protobuf::int32 value);

  // required int32 jointSpeedMoto = 2;
  bool has_jointspeedmoto() const;
  void clear_jointspeedmoto();
  static const int kJointSpeedMotoFieldNumber = 2;
  ::google::protobuf::int32 jointspeedmoto() const;
  void set_jointspeedmoto(::google::protobuf::int32 value);

  // required float jointPosJ = 3;
  bool has_jointposj() const;
  void clear_jointposj();
  static const int kJointPosJFieldNumber = 3;
  float jointposj() const;
  void set_jointposj(float value);

  // required float jointCurVol = 4;
  bool has_jointcurvol() const;
  void clear_jointcurvol();
  static const int kJointCurVolFieldNumber = 4;
  float jointcurvol() const;
  void set_jointcurvol(float value);

  // required float jointCurTemp = 5;
  bool has_jointcurtemp() const;
  void clear_jointcurtemp();
  static const int kJointCurTempFieldNumber = 5;
  float jointcurtemp() const;
  void set_jointcurtemp(float value);

  // required int32 jointTagCurrentI = 6;
  bool has_jointtagcurrenti() const;
  void clear_jointtagcurrenti();
  static const int kJointTagCurrentIFieldNumber = 6;
  ::google::protobuf::int32 jointtagcurrenti() const;
  void set_jointtagcurrenti(::google::protobuf::int32 value);

  // required float jointTagSpeedMoto = 7;
  bool has_jointtagspeedmoto() const;
  void clear_jointtagspeedmoto();
  static const int kJointTagSpeedMotoFieldNumber = 7;
  float jointtagspeedmoto() const;
  void set_jointtagspeedmoto(float value);

  // required float jointTagPosJ = 8;
  bool has_jointtagposj() const;
  void clear_jointtagposj();
  static const int kJointTagPosJFieldNumber = 8;
  float jointtagposj() const;
  void set_jointtagposj(float value);

  // required uint32 jointErrorNum = 9;
  bool has_jointerrornum() const;
  void clear_jointerrornum();
  static const int kJointErrorNumFieldNumber = 9;
  ::google::protobuf::uint32 jointerrornum() const;
  void set_jointerrornum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.JointStatus)
 private:
  void set_has_jointcurrenti();
  void clear_has_jointcurrenti();
  void set_has_jointspeedmoto();
  void clear_has_jointspeedmoto();
  void set_has_jointposj();
  void clear_has_jointposj();
  void set_has_jointcurvol();
  void clear_has_jointcurvol();
  void set_has_jointcurtemp();
  void clear_has_jointcurtemp();
  void set_has_jointtagcurrenti();
  void clear_has_jointtagcurrenti();
  void set_has_jointtagspeedmoto();
  void clear_has_jointtagspeedmoto();
  void set_has_jointtagposj();
  void clear_has_jointtagposj();
  void set_has_jointerrornum();
  void clear_has_jointerrornum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 jointcurrenti_;
  ::google::protobuf::int32 jointspeedmoto_;
  float jointposj_;
  float jointcurvol_;
  float jointcurtemp_;
  ::google::protobuf::int32 jointtagcurrenti_;
  float jointtagspeedmoto_;
  float jointtagposj_;
  ::google::protobuf::uint32 jointerrornum_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotCollisionCurrent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotCollisionCurrent) */ {
 public:
  RobotCollisionCurrent();
  virtual ~RobotCollisionCurrent();

  RobotCollisionCurrent(const RobotCollisionCurrent& from);

  inline RobotCollisionCurrent& operator=(const RobotCollisionCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotCollisionCurrent(RobotCollisionCurrent&& from) noexcept
    : RobotCollisionCurrent() {
    *this = ::std::move(from);
  }

  inline RobotCollisionCurrent& operator=(RobotCollisionCurrent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotCollisionCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCollisionCurrent* internal_default_instance() {
    return reinterpret_cast<const RobotCollisionCurrent*>(
               &_RobotCollisionCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RobotCollisionCurrent* other);
  friend void swap(RobotCollisionCurrent& a, RobotCollisionCurrent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotCollisionCurrent* New() const final {
    return CreateMaybeMessage<RobotCollisionCurrent>(NULL);
  }

  RobotCollisionCurrent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotCollisionCurrent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotCollisionCurrent& from);
  void MergeFrom(const RobotCollisionCurrent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCollisionCurrent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 jointCollisionCurrent = 1;
  int jointcollisioncurrent_size() const;
  void clear_jointcollisioncurrent();
  static const int kJointCollisionCurrentFieldNumber = 1;
  ::google::protobuf::uint32 jointcollisioncurrent(int index) const;
  void set_jointcollisioncurrent(int index, ::google::protobuf::uint32 value);
  void add_jointcollisioncurrent(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      jointcollisioncurrent() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_jointcollisioncurrent();

  // required uint32 collisionClass = 2;
  bool has_collisionclass() const;
  void clear_collisionclass();
  static const int kCollisionClassFieldNumber = 2;
  ::google::protobuf::uint32 collisionclass() const;
  void set_collisionclass(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotCollisionCurrent)
 private:
  void set_has_collisionclass();
  void clear_has_collisionclass();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > jointcollisioncurrent_;
  ::google::protobuf::uint32 collisionclass_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TcpParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.TcpParam) */ {
 public:
  TcpParam();
  virtual ~TcpParam();

  TcpParam(const TcpParam& from);

  inline TcpParam& operator=(const TcpParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TcpParam(TcpParam&& from) noexcept
    : TcpParam() {
    *this = ::std::move(from);
  }

  inline TcpParam& operator=(TcpParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TcpParam* internal_default_instance() {
    return reinterpret_cast<const TcpParam*>(
               &_TcpParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TcpParam* other);
  friend void swap(TcpParam& a, TcpParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TcpParam* New() const final {
    return CreateMaybeMessage<TcpParam>(NULL);
  }

  TcpParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TcpParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TcpParam& from);
  void MergeFrom(const TcpParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TcpParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float positionX = 1;
  bool has_positionx() const;
  void clear_positionx();
  static const int kPositionXFieldNumber = 1;
  float positionx() const;
  void set_positionx(float value);

  // required float positionY = 2;
  bool has_positiony() const;
  void clear_positiony();
  static const int kPositionYFieldNumber = 2;
  float positiony() const;
  void set_positiony(float value);

  // required float positionZ = 3;
  bool has_positionz() const;
  void clear_positionz();
  static const int kPositionZFieldNumber = 3;
  float positionz() const;
  void set_positionz(float value);

  // required float payload = 4;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 4;
  float payload() const;
  void set_payload(float value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.TcpParam)
 private:
  void set_has_positionx();
  void clear_has_positionx();
  void set_has_positiony();
  void clear_has_positiony();
  void set_has_positionz();
  void clear_has_positionz();
  void set_has_payload();
  void clear_has_payload();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float positionx_;
  float positiony_;
  float positionz_;
  float payload_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotTcpParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotTcpParam) */ {
 public:
  RobotTcpParam();
  virtual ~RobotTcpParam();

  RobotTcpParam(const RobotTcpParam& from);

  inline RobotTcpParam& operator=(const RobotTcpParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotTcpParam(RobotTcpParam&& from) noexcept
    : RobotTcpParam() {
    *this = ::std::move(from);
  }

  inline RobotTcpParam& operator=(RobotTcpParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotTcpParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotTcpParam* internal_default_instance() {
    return reinterpret_cast<const RobotTcpParam*>(
               &_RobotTcpParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RobotTcpParam* other);
  friend void swap(RobotTcpParam& a, RobotTcpParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotTcpParam* New() const final {
    return CreateMaybeMessage<RobotTcpParam>(NULL);
  }

  RobotTcpParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotTcpParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotTcpParam& from);
  void MergeFrom(const RobotTcpParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotTcpParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .aubo.robot.communication.TcpParam paramAutorun = 1;
  bool has_paramautorun() const;
  void clear_paramautorun();
  static const int kParamAutorunFieldNumber = 1;
  private:
  const ::aubo::robot::communication::TcpParam& _internal_paramautorun() const;
  public:
  const ::aubo::robot::communication::TcpParam& paramautorun() const;
  ::aubo::robot::communication::TcpParam* release_paramautorun();
  ::aubo::robot::communication::TcpParam* mutable_paramautorun();
  void set_allocated_paramautorun(::aubo::robot::communication::TcpParam* paramautorun);

  // required .aubo.robot.communication.TcpParam paramManual = 2;
  bool has_parammanual() const;
  void clear_parammanual();
  static const int kParamManualFieldNumber = 2;
  private:
  const ::aubo::robot::communication::TcpParam& _internal_parammanual() const;
  public:
  const ::aubo::robot::communication::TcpParam& parammanual() const;
  ::aubo::robot::communication::TcpParam* release_parammanual();
  ::aubo::robot::communication::TcpParam* mutable_parammanual();
  void set_allocated_parammanual(::aubo::robot::communication::TcpParam* parammanual);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotTcpParam)
 private:
  void set_has_paramautorun();
  void clear_has_paramautorun();
  void set_has_parammanual();
  void clear_has_parammanual();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::aubo::robot::communication::TcpParam* paramautorun_;
  ::aubo::robot::communication::TcpParam* parammanual_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotGravityComponent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotGravityComponent) */ {
 public:
  RobotGravityComponent();
  virtual ~RobotGravityComponent();

  RobotGravityComponent(const RobotGravityComponent& from);

  inline RobotGravityComponent& operator=(const RobotGravityComponent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotGravityComponent(RobotGravityComponent&& from) noexcept
    : RobotGravityComponent() {
    *this = ::std::move(from);
  }

  inline RobotGravityComponent& operator=(RobotGravityComponent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotGravityComponent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotGravityComponent* internal_default_instance() {
    return reinterpret_cast<const RobotGravityComponent*>(
               &_RobotGravityComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RobotGravityComponent* other);
  friend void swap(RobotGravityComponent& a, RobotGravityComponent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotGravityComponent* New() const final {
    return CreateMaybeMessage<RobotGravityComponent>(NULL);
  }

  RobotGravityComponent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotGravityComponent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotGravityComponent& from);
  void MergeFrom(const RobotGravityComponent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotGravityComponent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotGravityComponent)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JointVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.JointVersion) */ {
 public:
  JointVersion();
  virtual ~JointVersion();

  JointVersion(const JointVersion& from);

  inline JointVersion& operator=(const JointVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointVersion(JointVersion&& from) noexcept
    : JointVersion() {
    *this = ::std::move(from);
  }

  inline JointVersion& operator=(JointVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointVersion* internal_default_instance() {
    return reinterpret_cast<const JointVersion*>(
               &_JointVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(JointVersion* other);
  friend void swap(JointVersion& a, JointVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointVersion* New() const final {
    return CreateMaybeMessage<JointVersion>(NULL);
  }

  JointVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JointVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JointVersion& from);
  void MergeFrom(const JointVersion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hwVersion = 1;
  bool has_hwversion() const;
  void clear_hwversion();
  static const int kHwVersionFieldNumber = 1;
  const ::std::string& hwversion() const;
  void set_hwversion(const ::std::string& value);
  #if LANG_CXX11
  void set_hwversion(::std::string&& value);
  #endif
  void set_hwversion(const char* value);
  void set_hwversion(const char* value, size_t size);
  ::std::string* mutable_hwversion();
  ::std::string* release_hwversion();
  void set_allocated_hwversion(::std::string* hwversion);

  // required string swVersion = 2;
  bool has_swversion() const;
  void clear_swversion();
  static const int kSwVersionFieldNumber = 2;
  const ::std::string& swversion() const;
  void set_swversion(const ::std::string& value);
  #if LANG_CXX11
  void set_swversion(::std::string&& value);
  #endif
  void set_swversion(const char* value);
  void set_swversion(const char* value, size_t size);
  ::std::string* mutable_swversion();
  ::std::string* release_swversion();
  void set_allocated_swversion(::std::string* swversion);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.JointVersion)
 private:
  void set_has_hwversion();
  void clear_has_hwversion();
  void set_has_swversion();
  void clear_has_swversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hwversion_;
  ::google::protobuf::internal::ArenaStringPtr swversion_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OurRobotDevInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.OurRobotDevInfo) */ {
 public:
  OurRobotDevInfo();
  virtual ~OurRobotDevInfo();

  OurRobotDevInfo(const OurRobotDevInfo& from);

  inline OurRobotDevInfo& operator=(const OurRobotDevInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OurRobotDevInfo(OurRobotDevInfo&& from) noexcept
    : OurRobotDevInfo() {
    *this = ::std::move(from);
  }

  inline OurRobotDevInfo& operator=(OurRobotDevInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OurRobotDevInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OurRobotDevInfo* internal_default_instance() {
    return reinterpret_cast<const OurRobotDevInfo*>(
               &_OurRobotDevInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OurRobotDevInfo* other);
  friend void swap(OurRobotDevInfo& a, OurRobotDevInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OurRobotDevInfo* New() const final {
    return CreateMaybeMessage<OurRobotDevInfo>(NULL);
  }

  OurRobotDevInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OurRobotDevInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OurRobotDevInfo& from);
  void MergeFrom(const OurRobotDevInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OurRobotDevInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.JointVersion jointVer = 5;
  int jointver_size() const;
  void clear_jointver();
  static const int kJointVerFieldNumber = 5;
  ::aubo::robot::communication::JointVersion* mutable_jointver(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::JointVersion >*
      mutable_jointver();
  const ::aubo::robot::communication::JointVersion& jointver(int index) const;
  ::aubo::robot::communication::JointVersion* add_jointver();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::JointVersion >&
      jointver() const;

  // repeated string jointProductID = 7;
  int jointproductid_size() const;
  void clear_jointproductid();
  static const int kJointProductIDFieldNumber = 7;
  const ::std::string& jointproductid(int index) const;
  ::std::string* mutable_jointproductid(int index);
  void set_jointproductid(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_jointproductid(int index, ::std::string&& value);
  #endif
  void set_jointproductid(int index, const char* value);
  void set_jointproductid(int index, const char* value, size_t size);
  ::std::string* add_jointproductid();
  void add_jointproductid(const ::std::string& value);
  #if LANG_CXX11
  void add_jointproductid(::std::string&& value);
  #endif
  void add_jointproductid(const char* value);
  void add_jointproductid(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& jointproductid() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_jointproductid();

  // required string revision = 2;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 2;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // required string manuID = 3;
  bool has_manuid() const;
  void clear_manuid();
  static const int kManuIDFieldNumber = 3;
  const ::std::string& manuid() const;
  void set_manuid(const ::std::string& value);
  #if LANG_CXX11
  void set_manuid(::std::string&& value);
  #endif
  void set_manuid(const char* value);
  void set_manuid(const char* value, size_t size);
  ::std::string* mutable_manuid();
  ::std::string* release_manuid();
  void set_allocated_manuid(::std::string* manuid);

  // required string jointType = 4;
  bool has_jointtype() const;
  void clear_jointtype();
  static const int kJointTypeFieldNumber = 4;
  const ::std::string& jointtype() const;
  void set_jointtype(const ::std::string& value);
  #if LANG_CXX11
  void set_jointtype(::std::string&& value);
  #endif
  void set_jointtype(const char* value);
  void set_jointtype(const char* value, size_t size);
  ::std::string* mutable_jointtype();
  ::std::string* release_jointtype();
  void set_allocated_jointtype(::std::string* jointtype);

  // required string desc = 6;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 6;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // required string slaveDevVersion = 8;
  bool has_slavedevversion() const;
  void clear_slavedevversion();
  static const int kSlaveDevVersionFieldNumber = 8;
  const ::std::string& slavedevversion() const;
  void set_slavedevversion(const ::std::string& value);
  #if LANG_CXX11
  void set_slavedevversion(::std::string&& value);
  #endif
  void set_slavedevversion(const char* value);
  void set_slavedevversion(const char* value, size_t size);
  ::std::string* mutable_slavedevversion();
  ::std::string* release_slavedevversion();
  void set_allocated_slavedevversion(::std::string* slavedevversion);

  // required string extendIoBoardVersion = 9;
  bool has_extendioboardversion() const;
  void clear_extendioboardversion();
  static const int kExtendIoBoardVersionFieldNumber = 9;
  const ::std::string& extendioboardversion() const;
  void set_extendioboardversion(const ::std::string& value);
  #if LANG_CXX11
  void set_extendioboardversion(::std::string&& value);
  #endif
  void set_extendioboardversion(const char* value);
  void set_extendioboardversion(const char* value, size_t size);
  ::std::string* mutable_extendioboardversion();
  ::std::string* release_extendioboardversion();
  void set_allocated_extendioboardversion(::std::string* extendioboardversion);

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.OurRobotDevInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_revision();
  void clear_has_revision();
  void set_has_manuid();
  void clear_has_manuid();
  void set_has_jointtype();
  void clear_has_jointtype();
  void set_has_desc();
  void clear_has_desc();
  void set_has_slavedevversion();
  void clear_has_slavedevversion();
  void set_has_extendioboardversion();
  void clear_has_extendioboardversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::JointVersion > jointver_;
  ::google::protobuf::RepeatedPtrField< ::std::string> jointproductid_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr manuid_;
  ::google::protobuf::internal::ArenaStringPtr jointtype_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr slavedevversion_;
  ::google::protobuf::internal::ArenaStringPtr extendioboardversion_;
  ::google::protobuf::uint32 type_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotDiagnosis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotDiagnosis) */ {
 public:
  RobotDiagnosis();
  virtual ~RobotDiagnosis();

  RobotDiagnosis(const RobotDiagnosis& from);

  inline RobotDiagnosis& operator=(const RobotDiagnosis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotDiagnosis(RobotDiagnosis&& from) noexcept
    : RobotDiagnosis() {
    *this = ::std::move(from);
  }

  inline RobotDiagnosis& operator=(RobotDiagnosis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotDiagnosis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotDiagnosis* internal_default_instance() {
    return reinterpret_cast<const RobotDiagnosis*>(
               &_RobotDiagnosis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RobotDiagnosis* other);
  friend void swap(RobotDiagnosis& a, RobotDiagnosis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotDiagnosis* New() const final {
    return CreateMaybeMessage<RobotDiagnosis>(NULL);
  }

  RobotDiagnosis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotDiagnosis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotDiagnosis& from);
  void MergeFrom(const RobotDiagnosis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotDiagnosis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 armCanbusStatus = 1;
  bool has_armcanbusstatus() const;
  void clear_armcanbusstatus();
  static const int kArmCanbusStatusFieldNumber = 1;
  ::google::protobuf::uint32 armcanbusstatus() const;
  void set_armcanbusstatus(::google::protobuf::uint32 value);

  // required float armPowerCurrent = 2;
  bool has_armpowercurrent() const;
  void clear_armpowercurrent();
  static const int kArmPowerCurrentFieldNumber = 2;
  float armpowercurrent() const;
  void set_armpowercurrent(float value);

  // required float armPowerVoltage = 3;
  bool has_armpowervoltage() const;
  void clear_armpowervoltage();
  static const int kArmPowerVoltageFieldNumber = 3;
  float armpowervoltage() const;
  void set_armpowervoltage(float value);

  // required int32 contorllerTemp = 5;
  bool has_contorllertemp() const;
  void clear_contorllertemp();
  static const int kContorllerTempFieldNumber = 5;
  ::google::protobuf::int32 contorllertemp() const;
  void set_contorllertemp(::google::protobuf::int32 value);

  // required uint32 contorllerHumidity = 6;
  bool has_contorllerhumidity() const;
  void clear_contorllerhumidity();
  static const int kContorllerHumidityFieldNumber = 6;
  ::google::protobuf::uint32 contorllerhumidity() const;
  void set_contorllerhumidity(::google::protobuf::uint32 value);

  // required bool armPowerStatus = 4;
  bool has_armpowerstatus() const;
  void clear_armpowerstatus();
  static const int kArmPowerStatusFieldNumber = 4;
  bool armpowerstatus() const;
  void set_armpowerstatus(bool value);

  // required bool remoteHalt = 7;
  bool has_remotehalt() const;
  void clear_remotehalt();
  static const int kRemoteHaltFieldNumber = 7;
  bool remotehalt() const;
  void set_remotehalt(bool value);

  // required bool softEmergency = 8;
  bool has_softemergency() const;
  void clear_softemergency();
  static const int kSoftEmergencyFieldNumber = 8;
  bool softemergency() const;
  void set_softemergency(bool value);

  // required bool remoteEmergency = 9;
  bool has_remoteemergency() const;
  void clear_remoteemergency();
  static const int kRemoteEmergencyFieldNumber = 9;
  bool remoteemergency() const;
  void set_remoteemergency(bool value);

  // required bool robotCollision = 10;
  bool has_robotcollision() const;
  void clear_robotcollision();
  static const int kRobotCollisionFieldNumber = 10;
  bool robotcollision() const;
  void set_robotcollision(bool value);

  // required bool forceControlMode = 11;
  bool has_forcecontrolmode() const;
  void clear_forcecontrolmode();
  static const int kForceControlModeFieldNumber = 11;
  bool forcecontrolmode() const;
  void set_forcecontrolmode(bool value);

  // required bool brakeStuats = 12;
  bool has_brakestuats() const;
  void clear_brakestuats();
  static const int kBrakeStuatsFieldNumber = 12;
  bool brakestuats() const;
  void set_brakestuats(bool value);

  // required bool orpeStatus = 15;
  bool has_orpestatus() const;
  void clear_orpestatus();
  static const int kOrpeStatusFieldNumber = 15;
  bool orpestatus() const;
  void set_orpestatus(bool value);

  // required float robotEndSpeed = 13;
  bool has_robotendspeed() const;
  void clear_robotendspeed();
  static const int kRobotEndSpeedFieldNumber = 13;
  float robotendspeed() const;
  void set_robotendspeed(float value);

  // required int32 robotMaxAcc = 14;
  bool has_robotmaxacc() const;
  void clear_robotmaxacc();
  static const int kRobotMaxAccFieldNumber = 14;
  ::google::protobuf::int32 robotmaxacc() const;
  void set_robotmaxacc(::google::protobuf::int32 value);

  // required bool enableReadPose = 16;
  bool has_enablereadpose() const;
  void clear_enablereadpose();
  static const int kEnableReadPoseFieldNumber = 16;
  bool enablereadpose() const;
  void set_enablereadpose(bool value);

  // required bool robotMountingPoseChanged = 17;
  bool has_robotmountingposechanged() const;
  void clear_robotmountingposechanged();
  static const int kRobotMountingPoseChangedFieldNumber = 17;
  bool robotmountingposechanged() const;
  void set_robotmountingposechanged(bool value);

  // required bool encoderErrorStatus = 18;
  bool has_encodererrorstatus() const;
  void clear_encodererrorstatus();
  static const int kEncoderErrorStatusFieldNumber = 18;
  bool encodererrorstatus() const;
  void set_encodererrorstatus(bool value);

  // required bool staticCollisionDetect = 19;
  bool has_staticcollisiondetect() const;
  void clear_staticcollisiondetect();
  static const int kStaticCollisionDetectFieldNumber = 19;
  bool staticcollisiondetect() const;
  void set_staticcollisiondetect(bool value);

  // required uint32 jointCollisionDetect = 20;
  bool has_jointcollisiondetect() const;
  void clear_jointcollisiondetect();
  static const int kJointCollisionDetectFieldNumber = 20;
  ::google::protobuf::uint32 jointcollisiondetect() const;
  void set_jointcollisiondetect(::google::protobuf::uint32 value);

  // required bool encoderLinesError = 21;
  bool has_encoderlineserror() const;
  void clear_encoderlineserror();
  static const int kEncoderLinesErrorFieldNumber = 21;
  bool encoderlineserror() const;
  void set_encoderlineserror(bool value);

  // required bool jointErrorStatus = 22;
  bool has_jointerrorstatus() const;
  void clear_jointerrorstatus();
  static const int kJointErrorStatusFieldNumber = 22;
  bool jointerrorstatus() const;
  void set_jointerrorstatus(bool value);

  // required bool singularityOverSpeedAlarm = 23;
  bool has_singularityoverspeedalarm() const;
  void clear_singularityoverspeedalarm();
  static const int kSingularityOverSpeedAlarmFieldNumber = 23;
  bool singularityoverspeedalarm() const;
  void set_singularityoverspeedalarm(bool value);

  // required bool robotCurrentAlarm = 24;
  bool has_robotcurrentalarm() const;
  void clear_robotcurrentalarm();
  static const int kRobotCurrentAlarmFieldNumber = 24;
  bool robotcurrentalarm() const;
  void set_robotcurrentalarm(bool value);

  // required int32 toolIoError = 25;
  bool has_toolioerror() const;
  void clear_toolioerror();
  static const int kToolIoErrorFieldNumber = 25;
  ::google::protobuf::int32 toolioerror() const;
  void set_toolioerror(::google::protobuf::int32 value);

  // required bool robotMountingPoseWarning = 26;
  bool has_robotmountingposewarning() const;
  void clear_robotmountingposewarning();
  static const int kRobotMountingPoseWarningFieldNumber = 26;
  bool robotmountingposewarning() const;
  void set_robotmountingposewarning(bool value);

  // required uint32 macTargetPosBufferSize = 27;
  bool has_mactargetposbuffersize() const;
  void clear_mactargetposbuffersize();
  static const int kMacTargetPosBufferSizeFieldNumber = 27;
  ::google::protobuf::uint32 mactargetposbuffersize() const;
  void set_mactargetposbuffersize(::google::protobuf::uint32 value);

  // required uint32 macTargetPosDataSize = 28;
  bool has_mactargetposdatasize() const;
  void clear_mactargetposdatasize();
  static const int kMacTargetPosDataSizeFieldNumber = 28;
  ::google::protobuf::uint32 mactargetposdatasize() const;
  void set_mactargetposdatasize(::google::protobuf::uint32 value);

  // required uint32 macDataInterruptWarning = 29;
  bool has_macdatainterruptwarning() const;
  void clear_macdatainterruptwarning();
  static const int kMacDataInterruptWarningFieldNumber = 29;
  ::google::protobuf::uint32 macdatainterruptwarning() const;
  void set_macdatainterruptwarning(::google::protobuf::uint32 value);

  // optional uint32 controlBoardAbnormalStateFlag = 30;
  bool has_controlboardabnormalstateflag() const;
  void clear_controlboardabnormalstateflag();
  static const int kControlBoardAbnormalStateFlagFieldNumber = 30;
  ::google::protobuf::uint32 controlboardabnormalstateflag() const;
  void set_controlboardabnormalstateflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotDiagnosis)
 private:
  void set_has_armcanbusstatus();
  void clear_has_armcanbusstatus();
  void set_has_armpowercurrent();
  void clear_has_armpowercurrent();
  void set_has_armpowervoltage();
  void clear_has_armpowervoltage();
  void set_has_armpowerstatus();
  void clear_has_armpowerstatus();
  void set_has_contorllertemp();
  void clear_has_contorllertemp();
  void set_has_contorllerhumidity();
  void clear_has_contorllerhumidity();
  void set_has_remotehalt();
  void clear_has_remotehalt();
  void set_has_softemergency();
  void clear_has_softemergency();
  void set_has_remoteemergency();
  void clear_has_remoteemergency();
  void set_has_robotcollision();
  void clear_has_robotcollision();
  void set_has_forcecontrolmode();
  void clear_has_forcecontrolmode();
  void set_has_brakestuats();
  void clear_has_brakestuats();
  void set_has_robotendspeed();
  void clear_has_robotendspeed();
  void set_has_robotmaxacc();
  void clear_has_robotmaxacc();
  void set_has_orpestatus();
  void clear_has_orpestatus();
  void set_has_enablereadpose();
  void clear_has_enablereadpose();
  void set_has_robotmountingposechanged();
  void clear_has_robotmountingposechanged();
  void set_has_encodererrorstatus();
  void clear_has_encodererrorstatus();
  void set_has_staticcollisiondetect();
  void clear_has_staticcollisiondetect();
  void set_has_jointcollisiondetect();
  void clear_has_jointcollisiondetect();
  void set_has_encoderlineserror();
  void clear_has_encoderlineserror();
  void set_has_jointerrorstatus();
  void clear_has_jointerrorstatus();
  void set_has_singularityoverspeedalarm();
  void clear_has_singularityoverspeedalarm();
  void set_has_robotcurrentalarm();
  void clear_has_robotcurrentalarm();
  void set_has_toolioerror();
  void clear_has_toolioerror();
  void set_has_robotmountingposewarning();
  void clear_has_robotmountingposewarning();
  void set_has_mactargetposbuffersize();
  void clear_has_mactargetposbuffersize();
  void set_has_mactargetposdatasize();
  void clear_has_mactargetposdatasize();
  void set_has_macdatainterruptwarning();
  void clear_has_macdatainterruptwarning();
  void set_has_controlboardabnormalstateflag();
  void clear_has_controlboardabnormalstateflag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 armcanbusstatus_;
  float armpowercurrent_;
  float armpowervoltage_;
  ::google::protobuf::int32 contorllertemp_;
  ::google::protobuf::uint32 contorllerhumidity_;
  bool armpowerstatus_;
  bool remotehalt_;
  bool softemergency_;
  bool remoteemergency_;
  bool robotcollision_;
  bool forcecontrolmode_;
  bool brakestuats_;
  bool orpestatus_;
  float robotendspeed_;
  ::google::protobuf::int32 robotmaxacc_;
  bool enablereadpose_;
  bool robotmountingposechanged_;
  bool encodererrorstatus_;
  bool staticcollisiondetect_;
  ::google::protobuf::uint32 jointcollisiondetect_;
  bool encoderlineserror_;
  bool jointerrorstatus_;
  bool singularityoverspeedalarm_;
  bool robotcurrentalarm_;
  ::google::protobuf::int32 toolioerror_;
  bool robotmountingposewarning_;
  ::google::protobuf::uint32 mactargetposbuffersize_;
  ::google::protobuf::uint32 mactargetposdatasize_;
  ::google::protobuf::uint32 macdatainterruptwarning_;
  ::google::protobuf::uint32 controlboardabnormalstateflag_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotExtDiagnosis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotExtDiagnosis) */ {
 public:
  RobotExtDiagnosis();
  virtual ~RobotExtDiagnosis();

  RobotExtDiagnosis(const RobotExtDiagnosis& from);

  inline RobotExtDiagnosis& operator=(const RobotExtDiagnosis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotExtDiagnosis(RobotExtDiagnosis&& from) noexcept
    : RobotExtDiagnosis() {
    *this = ::std::move(from);
  }

  inline RobotExtDiagnosis& operator=(RobotExtDiagnosis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotExtDiagnosis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotExtDiagnosis* internal_default_instance() {
    return reinterpret_cast<const RobotExtDiagnosis*>(
               &_RobotExtDiagnosis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RobotExtDiagnosis* other);
  friend void swap(RobotExtDiagnosis& a, RobotExtDiagnosis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotExtDiagnosis* New() const final {
    return CreateMaybeMessage<RobotExtDiagnosis>(NULL);
  }

  RobotExtDiagnosis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotExtDiagnosis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotExtDiagnosis& from);
  void MergeFrom(const RobotExtDiagnosis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotExtDiagnosis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float targetPos = 3;
  int targetpos_size() const;
  void clear_targetpos();
  static const int kTargetPosFieldNumber = 3;
  float targetpos(int index) const;
  void set_targetpos(int index, float value);
  void add_targetpos(float value);
  const ::google::protobuf::RepeatedField< float >&
      targetpos() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_targetpos();

  // repeated float theoreticalSpeed = 4;
  int theoreticalspeed_size() const;
  void clear_theoreticalspeed();
  static const int kTheoreticalSpeedFieldNumber = 4;
  float theoreticalspeed(int index) const;
  void set_theoreticalspeed(int index, float value);
  void add_theoreticalspeed(float value);
  const ::google::protobuf::RepeatedField< float >&
      theoreticalspeed() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_theoreticalspeed();

  // repeated float theoreticalAcc = 5;
  int theoreticalacc_size() const;
  void clear_theoreticalacc();
  static const int kTheoreticalAccFieldNumber = 5;
  float theoreticalacc(int index) const;
  void set_theoreticalacc(int index, float value);
  void add_theoreticalacc(float value);
  const ::google::protobuf::RepeatedField< float >&
      theoreticalacc() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_theoreticalacc();

  // repeated uint32 theoreticalCurrent = 6;
  int theoreticalcurrent_size() const;
  void clear_theoreticalcurrent();
  static const int kTheoreticalCurrentFieldNumber = 6;
  ::google::protobuf::uint32 theoreticalcurrent(int index) const;
  void set_theoreticalcurrent(int index, ::google::protobuf::uint32 value);
  void add_theoreticalcurrent(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      theoreticalcurrent() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_theoreticalcurrent();

  // required uint32 robotState = 1;
  bool has_robotstate() const;
  void clear_robotstate();
  static const int kRobotStateFieldNumber = 1;
  ::google::protobuf::uint32 robotstate() const;
  void set_robotstate(::google::protobuf::uint32 value);

  // required uint32 robotStatus = 2;
  bool has_robotstatus() const;
  void clear_robotstatus();
  static const int kRobotStatusFieldNumber = 2;
  ::google::protobuf::uint32 robotstatus() const;
  void set_robotstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotExtDiagnosis)
 private:
  void set_has_robotstate();
  void clear_has_robotstate();
  void set_has_robotstatus();
  void clear_has_robotstatus();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > targetpos_;
  ::google::protobuf::RepeatedField< float > theoreticalspeed_;
  ::google::protobuf::RepeatedField< float > theoreticalacc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > theoreticalcurrent_;
  ::google::protobuf::uint32 robotstate_;
  ::google::protobuf::uint32 robotstatus_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotSafetyConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotSafetyConfig) */ {
 public:
  RobotSafetyConfig();
  virtual ~RobotSafetyConfig();

  RobotSafetyConfig(const RobotSafetyConfig& from);

  inline RobotSafetyConfig& operator=(const RobotSafetyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotSafetyConfig(RobotSafetyConfig&& from) noexcept
    : RobotSafetyConfig() {
    *this = ::std::move(from);
  }

  inline RobotSafetyConfig& operator=(RobotSafetyConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSafetyConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotSafetyConfig* internal_default_instance() {
    return reinterpret_cast<const RobotSafetyConfig*>(
               &_RobotSafetyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RobotSafetyConfig* other);
  friend void swap(RobotSafetyConfig& a, RobotSafetyConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotSafetyConfig* New() const final {
    return CreateMaybeMessage<RobotSafetyConfig>(NULL);
  }

  RobotSafetyConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotSafetyConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotSafetyConfig& from);
  void MergeFrom(const RobotSafetyConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotSafetyConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 robotReducedConfigJointSpeed = 1;
  int robotreducedconfigjointspeed_size() const;
  void clear_robotreducedconfigjointspeed();
  static const int kRobotReducedConfigJointSpeedFieldNumber = 1;
  ::google::protobuf::uint32 robotreducedconfigjointspeed(int index) const;
  void set_robotreducedconfigjointspeed(int index, ::google::protobuf::uint32 value);
  void add_robotreducedconfigjointspeed(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      robotreducedconfigjointspeed() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_robotreducedconfigjointspeed();

  // required uint32 robotReducedConfigTcpSpeed = 2;
  bool has_robotreducedconfigtcpspeed() const;
  void clear_robotreducedconfigtcpspeed();
  static const int kRobotReducedConfigTcpSpeedFieldNumber = 2;
  ::google::protobuf::uint32 robotreducedconfigtcpspeed() const;
  void set_robotreducedconfigtcpspeed(::google::protobuf::uint32 value);

  // required uint32 robotReducedConfigTcpForce = 3;
  bool has_robotreducedconfigtcpforce() const;
  void clear_robotreducedconfigtcpforce();
  static const int kRobotReducedConfigTcpForceFieldNumber = 3;
  ::google::protobuf::uint32 robotreducedconfigtcpforce() const;
  void set_robotreducedconfigtcpforce(::google::protobuf::uint32 value);

  // required uint32 robotReducedConfigMomentum = 4;
  bool has_robotreducedconfigmomentum() const;
  void clear_robotreducedconfigmomentum();
  static const int kRobotReducedConfigMomentumFieldNumber = 4;
  ::google::protobuf::uint32 robotreducedconfigmomentum() const;
  void set_robotreducedconfigmomentum(::google::protobuf::uint32 value);

  // required uint32 robotReducedConfigPower = 5;
  bool has_robotreducedconfigpower() const;
  void clear_robotreducedconfigpower();
  static const int kRobotReducedConfigPowerFieldNumber = 5;
  ::google::protobuf::uint32 robotreducedconfigpower() const;
  void set_robotreducedconfigpower(::google::protobuf::uint32 value);

  // required uint32 robotSafeguradResetConfig = 6;
  bool has_robotsafeguradresetconfig() const;
  void clear_robotsafeguradresetconfig();
  static const int kRobotSafeguradResetConfigFieldNumber = 6;
  ::google::protobuf::uint32 robotsafeguradresetconfig() const;
  void set_robotsafeguradresetconfig(::google::protobuf::uint32 value);

  // required uint32 robotOperationalModeConfig = 7;
  bool has_robotoperationalmodeconfig() const;
  void clear_robotoperationalmodeconfig();
  static const int kRobotOperationalModeConfigFieldNumber = 7;
  ::google::protobuf::uint32 robotoperationalmodeconfig() const;
  void set_robotoperationalmodeconfig(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotSafetyConfig)
 private:
  void set_has_robotreducedconfigtcpspeed();
  void clear_has_robotreducedconfigtcpspeed();
  void set_has_robotreducedconfigtcpforce();
  void clear_has_robotreducedconfigtcpforce();
  void set_has_robotreducedconfigmomentum();
  void clear_has_robotreducedconfigmomentum();
  void set_has_robotreducedconfigpower();
  void clear_has_robotreducedconfigpower();
  void set_has_robotsafeguradresetconfig();
  void clear_has_robotsafeguradresetconfig();
  void set_has_robotoperationalmodeconfig();
  void clear_has_robotoperationalmodeconfig();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > robotreducedconfigjointspeed_;
  ::google::protobuf::uint32 robotreducedconfigtcpspeed_;
  ::google::protobuf::uint32 robotreducedconfigtcpforce_;
  ::google::protobuf::uint32 robotreducedconfigmomentum_;
  ::google::protobuf::uint32 robotreducedconfigpower_;
  ::google::protobuf::uint32 robotsafeguradresetconfig_;
  ::google::protobuf::uint32 robotoperationalmodeconfig_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrpeSafetyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.OrpeSafetyStatus) */ {
 public:
  OrpeSafetyStatus();
  virtual ~OrpeSafetyStatus();

  OrpeSafetyStatus(const OrpeSafetyStatus& from);

  inline OrpeSafetyStatus& operator=(const OrpeSafetyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrpeSafetyStatus(OrpeSafetyStatus&& from) noexcept
    : OrpeSafetyStatus() {
    *this = ::std::move(from);
  }

  inline OrpeSafetyStatus& operator=(OrpeSafetyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrpeSafetyStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrpeSafetyStatus* internal_default_instance() {
    return reinterpret_cast<const OrpeSafetyStatus*>(
               &_OrpeSafetyStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(OrpeSafetyStatus* other);
  friend void swap(OrpeSafetyStatus& a, OrpeSafetyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrpeSafetyStatus* New() const final {
    return CreateMaybeMessage<OrpeSafetyStatus>(NULL);
  }

  OrpeSafetyStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrpeSafetyStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrpeSafetyStatus& from);
  void MergeFrom(const OrpeSafetyStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrpeSafetyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 orpeError = 3;
  int orpeerror_size() const;
  void clear_orpeerror();
  static const int kOrpeErrorFieldNumber = 3;
  ::google::protobuf::uint32 orpeerror(int index) const;
  void set_orpeerror(int index, ::google::protobuf::uint32 value);
  void add_orpeerror(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      orpeerror() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_orpeerror();

  // required uint32 orpePause = 1;
  bool has_orpepause() const;
  void clear_orpepause();
  static const int kOrpePauseFieldNumber = 1;
  ::google::protobuf::uint32 orpepause() const;
  void set_orpepause(::google::protobuf::uint32 value);

  // required uint32 orpeStop = 2;
  bool has_orpestop() const;
  void clear_orpestop();
  static const int kOrpeStopFieldNumber = 2;
  ::google::protobuf::uint32 orpestop() const;
  void set_orpestop(::google::protobuf::uint32 value);

  // required uint32 systemEmergencyStop = 4;
  bool has_systememergencystop() const;
  void clear_systememergencystop();
  static const int kSystemEmergencyStopFieldNumber = 4;
  ::google::protobuf::uint32 systememergencystop() const;
  void set_systememergencystop(::google::protobuf::uint32 value);

  // required uint32 reducedModeError = 5;
  bool has_reducedmodeerror() const;
  void clear_reducedmodeerror();
  static const int kReducedModeErrorFieldNumber = 5;
  ::google::protobuf::uint32 reducedmodeerror() const;
  void set_reducedmodeerror(::google::protobuf::uint32 value);

  // required uint32 safetyguardResetSucc = 6;
  bool has_safetyguardresetsucc() const;
  void clear_safetyguardresetsucc();
  static const int kSafetyguardResetSuccFieldNumber = 6;
  ::google::protobuf::uint32 safetyguardresetsucc() const;
  void set_safetyguardresetsucc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.OrpeSafetyStatus)
 private:
  void set_has_orpepause();
  void clear_has_orpepause();
  void set_has_orpestop();
  void clear_has_orpestop();
  void set_has_systememergencystop();
  void clear_has_systememergencystop();
  void set_has_reducedmodeerror();
  void clear_has_reducedmodeerror();
  void set_has_safetyguardresetsucc();
  void clear_has_safetyguardresetsucc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > orpeerror_;
  ::google::protobuf::uint32 orpepause_;
  ::google::protobuf::uint32 orpestop_;
  ::google::protobuf::uint32 systememergencystop_;
  ::google::protobuf::uint32 reducedmodeerror_;
  ::google::protobuf::uint32 safetyguardresetsucc_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class protoSafeCommunicationParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.protoSafeCommunicationParam) */ {
 public:
  protoSafeCommunicationParam();
  virtual ~protoSafeCommunicationParam();

  protoSafeCommunicationParam(const protoSafeCommunicationParam& from);

  inline protoSafeCommunicationParam& operator=(const protoSafeCommunicationParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  protoSafeCommunicationParam(protoSafeCommunicationParam&& from) noexcept
    : protoSafeCommunicationParam() {
    *this = ::std::move(from);
  }

  inline protoSafeCommunicationParam& operator=(protoSafeCommunicationParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const protoSafeCommunicationParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const protoSafeCommunicationParam* internal_default_instance() {
    return reinterpret_cast<const protoSafeCommunicationParam*>(
               &_protoSafeCommunicationParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(protoSafeCommunicationParam* other);
  friend void swap(protoSafeCommunicationParam& a, protoSafeCommunicationParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline protoSafeCommunicationParam* New() const final {
    return CreateMaybeMessage<protoSafeCommunicationParam>(NULL);
  }

  protoSafeCommunicationParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<protoSafeCommunicationParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const protoSafeCommunicationParam& from);
  void MergeFrom(const protoSafeCommunicationParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(protoSafeCommunicationParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  ::google::protobuf::uint32 param(int index) const;
  void set_param(int index, ::google::protobuf::uint32 value);
  void add_param(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      param() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_param();

  // required uint32 paramReserved = 1;
  bool has_paramreserved() const;
  void clear_paramreserved();
  static const int kParamReservedFieldNumber = 1;
  ::google::protobuf::uint32 paramreserved() const;
  void set_paramreserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.protoSafeCommunicationParam)
 private:
  void set_has_paramreserved();
  void clear_has_paramreserved();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > param_;
  ::google::protobuf::uint32 paramreserved_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OriginPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.OriginPose) */ {
 public:
  OriginPose();
  virtual ~OriginPose();

  OriginPose(const OriginPose& from);

  inline OriginPose& operator=(const OriginPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OriginPose(OriginPose&& from) noexcept
    : OriginPose() {
    *this = ::std::move(from);
  }

  inline OriginPose& operator=(OriginPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OriginPose* internal_default_instance() {
    return reinterpret_cast<const OriginPose*>(
               &_OriginPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(OriginPose* other);
  friend void swap(OriginPose& a, OriginPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OriginPose* New() const final {
    return CreateMaybeMessage<OriginPose>(NULL);
  }

  OriginPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OriginPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OriginPose& from);
  void MergeFrom(const OriginPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float OriginPose = 2;
  int originpose_size() const;
  void clear_originpose();
  static const int kOriginPoseFieldNumber = 2;
  float originpose(int index) const;
  void set_originpose(int index, float value);
  void add_originpose(float value);
  const ::google::protobuf::RepeatedField< float >&
      originpose() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_originpose();

  // required uint32 OriginPoseState = 1;
  bool has_originposestate() const;
  void clear_originposestate();
  static const int kOriginPoseStateFieldNumber = 1;
  ::google::protobuf::uint32 originposestate() const;
  void set_originposestate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.OriginPose)
 private:
  void set_has_originposestate();
  void clear_has_originposestate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > originpose_;
  ::google::protobuf::uint32 originposestate_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotToolConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotToolConfig) */ {
 public:
  RobotToolConfig();
  virtual ~RobotToolConfig();

  RobotToolConfig(const RobotToolConfig& from);

  inline RobotToolConfig& operator=(const RobotToolConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotToolConfig(RobotToolConfig&& from) noexcept
    : RobotToolConfig() {
    *this = ::std::move(from);
  }

  inline RobotToolConfig& operator=(RobotToolConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotToolConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotToolConfig* internal_default_instance() {
    return reinterpret_cast<const RobotToolConfig*>(
               &_RobotToolConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RobotToolConfig* other);
  friend void swap(RobotToolConfig& a, RobotToolConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotToolConfig* New() const final {
    return CreateMaybeMessage<RobotToolConfig>(NULL);
  }

  RobotToolConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotToolConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotToolConfig& from);
  void MergeFrom(const RobotToolConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotToolConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  ::google::protobuf::uint32 config() const;
  void set_config(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotToolConfig)
 private:
  void set_has_config();
  void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 config_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoRobotCommonResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoRobotCommonResponse) */ {
 public:
  ProtoRobotCommonResponse();
  virtual ~ProtoRobotCommonResponse();

  ProtoRobotCommonResponse(const ProtoRobotCommonResponse& from);

  inline ProtoRobotCommonResponse& operator=(const ProtoRobotCommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoRobotCommonResponse(ProtoRobotCommonResponse&& from) noexcept
    : ProtoRobotCommonResponse() {
    *this = ::std::move(from);
  }

  inline ProtoRobotCommonResponse& operator=(ProtoRobotCommonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoRobotCommonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoRobotCommonResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoRobotCommonResponse*>(
               &_ProtoRobotCommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ProtoRobotCommonResponse* other);
  friend void swap(ProtoRobotCommonResponse& a, ProtoRobotCommonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoRobotCommonResponse* New() const final {
    return CreateMaybeMessage<ProtoRobotCommonResponse>(NULL);
  }

  ProtoRobotCommonResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoRobotCommonResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoRobotCommonResponse& from);
  void MergeFrom(const ProtoRobotCommonResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoRobotCommonResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errorMsg = 2;
  bool has_errormsg() const;
  void clear_errormsg();
  static const int kErrorMsgFieldNumber = 2;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errormsg(::std::string&& value);
  #endif
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // required int32 errorCode = 1;
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 errorcode() const;
  void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoRobotCommonResponse)
 private:
  void set_has_errorcode();
  void clear_has_errorcode();
  void set_has_errormsg();
  void clear_has_errormsg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  ::google::protobuf::int32 errorcode_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoRequestLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoRequestLogin) */ {
 public:
  ProtoRequestLogin();
  virtual ~ProtoRequestLogin();

  ProtoRequestLogin(const ProtoRequestLogin& from);

  inline ProtoRequestLogin& operator=(const ProtoRequestLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoRequestLogin(ProtoRequestLogin&& from) noexcept
    : ProtoRequestLogin() {
    *this = ::std::move(from);
  }

  inline ProtoRequestLogin& operator=(ProtoRequestLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoRequestLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoRequestLogin* internal_default_instance() {
    return reinterpret_cast<const ProtoRequestLogin*>(
               &_ProtoRequestLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ProtoRequestLogin* other);
  friend void swap(ProtoRequestLogin& a, ProtoRequestLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoRequestLogin* New() const final {
    return CreateMaybeMessage<ProtoRequestLogin>(NULL);
  }

  ProtoRequestLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoRequestLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoRequestLogin& from);
  void MergeFrom(const ProtoRequestLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoRequestLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string passwd = 2;
  bool has_passwd() const;
  void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoRequestLogin)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_passwd();
  void clear_has_passwd();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoRobotDiagnosisIODesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoRobotDiagnosisIODesc) */ {
 public:
  ProtoRobotDiagnosisIODesc();
  virtual ~ProtoRobotDiagnosisIODesc();

  ProtoRobotDiagnosisIODesc(const ProtoRobotDiagnosisIODesc& from);

  inline ProtoRobotDiagnosisIODesc& operator=(const ProtoRobotDiagnosisIODesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoRobotDiagnosisIODesc(ProtoRobotDiagnosisIODesc&& from) noexcept
    : ProtoRobotDiagnosisIODesc() {
    *this = ::std::move(from);
  }

  inline ProtoRobotDiagnosisIODesc& operator=(ProtoRobotDiagnosisIODesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoRobotDiagnosisIODesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoRobotDiagnosisIODesc* internal_default_instance() {
    return reinterpret_cast<const ProtoRobotDiagnosisIODesc*>(
               &_ProtoRobotDiagnosisIODesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ProtoRobotDiagnosisIODesc* other);
  friend void swap(ProtoRobotDiagnosisIODesc& a, ProtoRobotDiagnosisIODesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoRobotDiagnosisIODesc* New() const final {
    return CreateMaybeMessage<ProtoRobotDiagnosisIODesc>(NULL);
  }

  ProtoRobotDiagnosisIODesc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoRobotDiagnosisIODesc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoRobotDiagnosisIODesc& from);
  void MergeFrom(const ProtoRobotDiagnosisIODesc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoRobotDiagnosisIODesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint32 addr() const;
  void set_addr(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoRobotDiagnosisIODesc)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoRobotAnalogIODesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoRobotAnalogIODesc) */ {
 public:
  ProtoRobotAnalogIODesc();
  virtual ~ProtoRobotAnalogIODesc();

  ProtoRobotAnalogIODesc(const ProtoRobotAnalogIODesc& from);

  inline ProtoRobotAnalogIODesc& operator=(const ProtoRobotAnalogIODesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoRobotAnalogIODesc(ProtoRobotAnalogIODesc&& from) noexcept
    : ProtoRobotAnalogIODesc() {
    *this = ::std::move(from);
  }

  inline ProtoRobotAnalogIODesc& operator=(ProtoRobotAnalogIODesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoRobotAnalogIODesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoRobotAnalogIODesc* internal_default_instance() {
    return reinterpret_cast<const ProtoRobotAnalogIODesc*>(
               &_ProtoRobotAnalogIODesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ProtoRobotAnalogIODesc* other);
  friend void swap(ProtoRobotAnalogIODesc& a, ProtoRobotAnalogIODesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoRobotAnalogIODesc* New() const final {
    return CreateMaybeMessage<ProtoRobotAnalogIODesc>(NULL);
  }

  ProtoRobotAnalogIODesc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoRobotAnalogIODesc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoRobotAnalogIODesc& from);
  void MergeFrom(const ProtoRobotAnalogIODesc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoRobotAnalogIODesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint32 addr() const;
  void set_addr(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required float value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoRobotAnalogIODesc)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 addr_;
  ::google::protobuf::uint32 type_;
  float value_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotDiagnosisIOData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData) */ {
 public:
  ProtoCommunicationRobotDiagnosisIOData();
  virtual ~ProtoCommunicationRobotDiagnosisIOData();

  ProtoCommunicationRobotDiagnosisIOData(const ProtoCommunicationRobotDiagnosisIOData& from);

  inline ProtoCommunicationRobotDiagnosisIOData& operator=(const ProtoCommunicationRobotDiagnosisIOData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotDiagnosisIOData(ProtoCommunicationRobotDiagnosisIOData&& from) noexcept
    : ProtoCommunicationRobotDiagnosisIOData() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotDiagnosisIOData& operator=(ProtoCommunicationRobotDiagnosisIOData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotDiagnosisIOData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotDiagnosisIOData* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotDiagnosisIOData*>(
               &_ProtoCommunicationRobotDiagnosisIOData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ProtoCommunicationRobotDiagnosisIOData* other);
  friend void swap(ProtoCommunicationRobotDiagnosisIOData& a, ProtoCommunicationRobotDiagnosisIOData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotDiagnosisIOData* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotDiagnosisIOData>(NULL);
  }

  ProtoCommunicationRobotDiagnosisIOData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotDiagnosisIOData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotDiagnosisIOData& from);
  void MergeFrom(const ProtoCommunicationRobotDiagnosisIOData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotDiagnosisIOData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
      mutable_errorinfo();
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo(int index) const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
      errorinfo() const;

  // repeated .aubo.robot.communication.ProtoRobotDiagnosisIODesc ioDesc = 3;
  int iodesc_size() const;
  void clear_iodesc();
  static const int kIoDescFieldNumber = 3;
  ::aubo::robot::communication::ProtoRobotDiagnosisIODesc* mutable_iodesc(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotDiagnosisIODesc >*
      mutable_iodesc();
  const ::aubo::robot::communication::ProtoRobotDiagnosisIODesc& iodesc(int index) const;
  ::aubo::robot::communication::ProtoRobotDiagnosisIODesc* add_iodesc();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotDiagnosisIODesc >&
      iodesc() const;

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse > errorinfo_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotDiagnosisIODesc > iodesc_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotAnalogIOData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData) */ {
 public:
  ProtoCommunicationRobotAnalogIOData();
  virtual ~ProtoCommunicationRobotAnalogIOData();

  ProtoCommunicationRobotAnalogIOData(const ProtoCommunicationRobotAnalogIOData& from);

  inline ProtoCommunicationRobotAnalogIOData& operator=(const ProtoCommunicationRobotAnalogIOData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotAnalogIOData(ProtoCommunicationRobotAnalogIOData&& from) noexcept
    : ProtoCommunicationRobotAnalogIOData() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotAnalogIOData& operator=(ProtoCommunicationRobotAnalogIOData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotAnalogIOData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotAnalogIOData* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotAnalogIOData*>(
               &_ProtoCommunicationRobotAnalogIOData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ProtoCommunicationRobotAnalogIOData* other);
  friend void swap(ProtoCommunicationRobotAnalogIOData& a, ProtoCommunicationRobotAnalogIOData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotAnalogIOData* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotAnalogIOData>(NULL);
  }

  ProtoCommunicationRobotAnalogIOData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotAnalogIOData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotAnalogIOData& from);
  void MergeFrom(const ProtoCommunicationRobotAnalogIOData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotAnalogIOData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.ProtoRobotAnalogIODesc ioDesc = 1;
  int iodesc_size() const;
  void clear_iodesc();
  static const int kIoDescFieldNumber = 1;
  ::aubo::robot::communication::ProtoRobotAnalogIODesc* mutable_iodesc(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotAnalogIODesc >*
      mutable_iodesc();
  const ::aubo::robot::communication::ProtoRobotAnalogIODesc& iodesc(int index) const;
  ::aubo::robot::communication::ProtoRobotAnalogIODesc* add_iodesc();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotAnalogIODesc >&
      iodesc() const;

  // repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
      mutable_errorinfo();
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo(int index) const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
      errorinfo() const;

  // required int32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotAnalogIODesc > iodesc_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse > errorinfo_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationGeneralData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationGeneralData) */ {
 public:
  ProtoCommunicationGeneralData();
  virtual ~ProtoCommunicationGeneralData();

  ProtoCommunicationGeneralData(const ProtoCommunicationGeneralData& from);

  inline ProtoCommunicationGeneralData& operator=(const ProtoCommunicationGeneralData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationGeneralData(ProtoCommunicationGeneralData&& from) noexcept
    : ProtoCommunicationGeneralData() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationGeneralData& operator=(ProtoCommunicationGeneralData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationGeneralData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationGeneralData* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationGeneralData*>(
               &_ProtoCommunicationGeneralData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ProtoCommunicationGeneralData* other);
  friend void swap(ProtoCommunicationGeneralData& a, ProtoCommunicationGeneralData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationGeneralData* New() const final {
    return CreateMaybeMessage<ProtoCommunicationGeneralData>(NULL);
  }

  ProtoCommunicationGeneralData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationGeneralData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationGeneralData& from);
  void MergeFrom(const ProtoCommunicationGeneralData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationGeneralData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 property1 = 1;
  int property1_size() const;
  void clear_property1();
  static const int kProperty1FieldNumber = 1;
  ::google::protobuf::int32 property1(int index) const;
  void set_property1(int index, ::google::protobuf::int32 value);
  void add_property1(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      property1() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_property1();

  // repeated bool property2 = 2;
  int property2_size() const;
  void clear_property2();
  static const int kProperty2FieldNumber = 2;
  bool property2(int index) const;
  void set_property2(int index, bool value);
  void add_property2(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      property2() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_property2();

  // repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
      mutable_errorinfo();
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo(int index) const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
      errorinfo() const;

  // required int32 type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationGeneralData)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > property1_;
  ::google::protobuf::RepeatedField< bool > property2_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse > errorinfo_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotDiagnosisInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo) */ {
 public:
  ProtoCommunicationRobotDiagnosisInfo();
  virtual ~ProtoCommunicationRobotDiagnosisInfo();

  ProtoCommunicationRobotDiagnosisInfo(const ProtoCommunicationRobotDiagnosisInfo& from);

  inline ProtoCommunicationRobotDiagnosisInfo& operator=(const ProtoCommunicationRobotDiagnosisInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotDiagnosisInfo(ProtoCommunicationRobotDiagnosisInfo&& from) noexcept
    : ProtoCommunicationRobotDiagnosisInfo() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotDiagnosisInfo& operator=(ProtoCommunicationRobotDiagnosisInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotDiagnosisInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotDiagnosisInfo* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotDiagnosisInfo*>(
               &_ProtoCommunicationRobotDiagnosisInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ProtoCommunicationRobotDiagnosisInfo* other);
  friend void swap(ProtoCommunicationRobotDiagnosisInfo& a, ProtoCommunicationRobotDiagnosisInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotDiagnosisInfo* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotDiagnosisInfo>(NULL);
  }

  ProtoCommunicationRobotDiagnosisInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotDiagnosisInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotDiagnosisInfo& from);
  void MergeFrom(const ProtoCommunicationRobotDiagnosisInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotDiagnosisInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.RobotDiagnosis robotDiagnosis = 2;
  int robotdiagnosis_size() const;
  void clear_robotdiagnosis();
  static const int kRobotDiagnosisFieldNumber = 2;
  ::aubo::robot::communication::RobotDiagnosis* mutable_robotdiagnosis(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::RobotDiagnosis >*
      mutable_robotdiagnosis();
  const ::aubo::robot::communication::RobotDiagnosis& robotdiagnosis(int index) const;
  ::aubo::robot::communication::RobotDiagnosis* add_robotdiagnosis();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::RobotDiagnosis >&
      robotdiagnosis() const;

  // repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
      mutable_errorinfo();
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo(int index) const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
      errorinfo() const;

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo)
 private:
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::RobotDiagnosis > robotdiagnosis_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse > errorinfo_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotEvent) */ {
 public:
  ProtoCommunicationRobotEvent();
  virtual ~ProtoCommunicationRobotEvent();

  ProtoCommunicationRobotEvent(const ProtoCommunicationRobotEvent& from);

  inline ProtoCommunicationRobotEvent& operator=(const ProtoCommunicationRobotEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotEvent(ProtoCommunicationRobotEvent&& from) noexcept
    : ProtoCommunicationRobotEvent() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotEvent& operator=(ProtoCommunicationRobotEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotEvent* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotEvent*>(
               &_ProtoCommunicationRobotEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ProtoCommunicationRobotEvent* other);
  friend void swap(ProtoCommunicationRobotEvent& a, ProtoCommunicationRobotEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotEvent* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotEvent>(NULL);
  }

  ProtoCommunicationRobotEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotEvent& from);
  void MergeFrom(const ProtoCommunicationRobotEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes eventContent = 3;
  bool has_eventcontent() const;
  void clear_eventcontent();
  static const int kEventContentFieldNumber = 3;
  const ::std::string& eventcontent() const;
  void set_eventcontent(const ::std::string& value);
  #if LANG_CXX11
  void set_eventcontent(::std::string&& value);
  #endif
  void set_eventcontent(const char* value);
  void set_eventcontent(const void* value, size_t size);
  ::std::string* mutable_eventcontent();
  ::std::string* release_eventcontent();
  void set_allocated_eventcontent(::std::string* eventcontent);

  // required int32 eventType = 1;
  bool has_eventtype() const;
  void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  ::google::protobuf::int32 eventtype() const;
  void set_eventtype(::google::protobuf::int32 value);

  // required int32 eventCode = 2;
  bool has_eventcode() const;
  void clear_eventcode();
  static const int kEventCodeFieldNumber = 2;
  ::google::protobuf::int32 eventcode() const;
  void set_eventcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotEvent)
 private:
  void set_has_eventtype();
  void clear_has_eventtype();
  void set_has_eventcode();
  void clear_has_eventcode();
  void set_has_eventcontent();
  void clear_has_eventcontent();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr eventcontent_;
  ::google::protobuf::int32 eventtype_;
  ::google::protobuf::int32 eventcode_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotStartupProfile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotStartupProfile) */ {
 public:
  ProtoCommunicationRobotStartupProfile();
  virtual ~ProtoCommunicationRobotStartupProfile();

  ProtoCommunicationRobotStartupProfile(const ProtoCommunicationRobotStartupProfile& from);

  inline ProtoCommunicationRobotStartupProfile& operator=(const ProtoCommunicationRobotStartupProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotStartupProfile(ProtoCommunicationRobotStartupProfile&& from) noexcept
    : ProtoCommunicationRobotStartupProfile() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotStartupProfile& operator=(ProtoCommunicationRobotStartupProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotStartupProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotStartupProfile* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotStartupProfile*>(
               &_ProtoCommunicationRobotStartupProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ProtoCommunicationRobotStartupProfile* other);
  friend void swap(ProtoCommunicationRobotStartupProfile& a, ProtoCommunicationRobotStartupProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotStartupProfile* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotStartupProfile>(NULL);
  }

  ProtoCommunicationRobotStartupProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotStartupProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotStartupProfile& from);
  void MergeFrom(const ProtoCommunicationRobotStartupProfile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotStartupProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .aubo.robot.communication.RobotTcpParam tcpParam = 1;
  bool has_tcpparam() const;
  void clear_tcpparam();
  static const int kTcpParamFieldNumber = 1;
  private:
  const ::aubo::robot::communication::RobotTcpParam& _internal_tcpparam() const;
  public:
  const ::aubo::robot::communication::RobotTcpParam& tcpparam() const;
  ::aubo::robot::communication::RobotTcpParam* release_tcpparam();
  ::aubo::robot::communication::RobotTcpParam* mutable_tcpparam();
  void set_allocated_tcpparam(::aubo::robot::communication::RobotTcpParam* tcpparam);

  // required bool readPose = 2;
  bool has_readpose() const;
  void clear_readpose();
  static const int kReadPoseFieldNumber = 2;
  bool readpose() const;
  void set_readpose(bool value);

  // required bool staticCollisionDetect = 3;
  bool has_staticcollisiondetect() const;
  void clear_staticcollisiondetect();
  static const int kStaticCollisionDetectFieldNumber = 3;
  bool staticcollisiondetect() const;
  void set_staticcollisiondetect(bool value);

  // required int32 collisionClass = 4;
  bool has_collisionclass() const;
  void clear_collisionclass();
  static const int kCollisionClassFieldNumber = 4;
  ::google::protobuf::int32 collisionclass() const;
  void set_collisionclass(::google::protobuf::int32 value);

  // required int32 maxAcc = 5;
  bool has_maxacc() const;
  void clear_maxacc();
  static const int kMaxAccFieldNumber = 5;
  ::google::protobuf::int32 maxacc() const;
  void set_maxacc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotStartupProfile)
 private:
  void set_has_tcpparam();
  void clear_has_tcpparam();
  void set_has_readpose();
  void clear_has_readpose();
  void set_has_staticcollisiondetect();
  void clear_has_staticcollisiondetect();
  void set_has_collisionclass();
  void clear_has_collisionclass();
  void set_has_maxacc();
  void clear_has_maxacc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::aubo::robot::communication::RobotTcpParam* tcpparam_;
  bool readpose_;
  bool staticcollisiondetect_;
  ::google::protobuf::int32 collisionclass_;
  ::google::protobuf::int32 maxacc_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationOfflineExcitTraj : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj) */ {
 public:
  ProtoCommunicationOfflineExcitTraj();
  virtual ~ProtoCommunicationOfflineExcitTraj();

  ProtoCommunicationOfflineExcitTraj(const ProtoCommunicationOfflineExcitTraj& from);

  inline ProtoCommunicationOfflineExcitTraj& operator=(const ProtoCommunicationOfflineExcitTraj& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationOfflineExcitTraj(ProtoCommunicationOfflineExcitTraj&& from) noexcept
    : ProtoCommunicationOfflineExcitTraj() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationOfflineExcitTraj& operator=(ProtoCommunicationOfflineExcitTraj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationOfflineExcitTraj& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationOfflineExcitTraj* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationOfflineExcitTraj*>(
               &_ProtoCommunicationOfflineExcitTraj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ProtoCommunicationOfflineExcitTraj* other);
  friend void swap(ProtoCommunicationOfflineExcitTraj& a, ProtoCommunicationOfflineExcitTraj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationOfflineExcitTraj* New() const final {
    return CreateMaybeMessage<ProtoCommunicationOfflineExcitTraj>(NULL);
  }

  ProtoCommunicationOfflineExcitTraj* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationOfflineExcitTraj>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationOfflineExcitTraj& from);
  void MergeFrom(const ProtoCommunicationOfflineExcitTraj& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationOfflineExcitTraj* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string trackFile = 1;
  bool has_trackfile() const;
  void clear_trackfile();
  static const int kTrackFileFieldNumber = 1;
  const ::std::string& trackfile() const;
  void set_trackfile(const ::std::string& value);
  #if LANG_CXX11
  void set_trackfile(::std::string&& value);
  #endif
  void set_trackfile(const char* value);
  void set_trackfile(const char* value, size_t size);
  ::std::string* mutable_trackfile();
  ::std::string* release_trackfile();
  void set_allocated_trackfile(::std::string* trackfile);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required int32 subtype = 3;
  bool has_subtype() const;
  void clear_subtype();
  static const int kSubtypeFieldNumber = 3;
  ::google::protobuf::int32 subtype() const;
  void set_subtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj)
 private:
  void set_has_trackfile();
  void clear_has_trackfile();
  void set_has_type();
  void clear_has_type();
  void set_has_subtype();
  void clear_has_subtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trackfile_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 subtype_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationDynIdentifyResults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationDynIdentifyResults) */ {
 public:
  ProtoCommunicationDynIdentifyResults();
  virtual ~ProtoCommunicationDynIdentifyResults();

  ProtoCommunicationDynIdentifyResults(const ProtoCommunicationDynIdentifyResults& from);

  inline ProtoCommunicationDynIdentifyResults& operator=(const ProtoCommunicationDynIdentifyResults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationDynIdentifyResults(ProtoCommunicationDynIdentifyResults&& from) noexcept
    : ProtoCommunicationDynIdentifyResults() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationDynIdentifyResults& operator=(ProtoCommunicationDynIdentifyResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationDynIdentifyResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationDynIdentifyResults* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationDynIdentifyResults*>(
               &_ProtoCommunicationDynIdentifyResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ProtoCommunicationDynIdentifyResults* other);
  friend void swap(ProtoCommunicationDynIdentifyResults& a, ProtoCommunicationDynIdentifyResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationDynIdentifyResults* New() const final {
    return CreateMaybeMessage<ProtoCommunicationDynIdentifyResults>(NULL);
  }

  ProtoCommunicationDynIdentifyResults* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationDynIdentifyResults>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationDynIdentifyResults& from);
  void MergeFrom(const ProtoCommunicationDynIdentifyResults& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationDynIdentifyResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  ::google::protobuf::int32 param(int index) const;
  void set_param(int index, ::google::protobuf::int32 value);
  void add_param(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      param() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_param();

  // repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
  int errorinfo_size() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
      mutable_errorinfo();
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo(int index) const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* add_errorinfo();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
      errorinfo() const;

  // required int32 temp = 1;
  bool has_temp() const;
  void clear_temp();
  static const int kTempFieldNumber = 1;
  ::google::protobuf::int32 temp() const;
  void set_temp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationDynIdentifyResults)
 private:
  void set_has_temp();
  void clear_has_temp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > param_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse > errorinfo_;
  ::google::protobuf::int32 temp_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InterfaceBoardError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.InterfaceBoardError) */ {
 public:
  InterfaceBoardError();
  virtual ~InterfaceBoardError();

  InterfaceBoardError(const InterfaceBoardError& from);

  inline InterfaceBoardError& operator=(const InterfaceBoardError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InterfaceBoardError(InterfaceBoardError&& from) noexcept
    : InterfaceBoardError() {
    *this = ::std::move(from);
  }

  inline InterfaceBoardError& operator=(InterfaceBoardError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterfaceBoardError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InterfaceBoardError* internal_default_instance() {
    return reinterpret_cast<const InterfaceBoardError*>(
               &_InterfaceBoardError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(InterfaceBoardError* other);
  friend void swap(InterfaceBoardError& a, InterfaceBoardError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InterfaceBoardError* New() const final {
    return CreateMaybeMessage<InterfaceBoardError>(NULL);
  }

  InterfaceBoardError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InterfaceBoardError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InterfaceBoardError& from);
  void MergeFrom(const InterfaceBoardError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceBoardError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes boardError = 1;
  bool has_boarderror() const;
  void clear_boarderror();
  static const int kBoardErrorFieldNumber = 1;
  const ::std::string& boarderror() const;
  void set_boarderror(const ::std::string& value);
  #if LANG_CXX11
  void set_boarderror(::std::string&& value);
  #endif
  void set_boarderror(const char* value);
  void set_boarderror(const void* value, size_t size);
  ::std::string* mutable_boarderror();
  ::std::string* release_boarderror();
  void set_allocated_boarderror(::std::string* boarderror);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.InterfaceBoardError)
 private:
  void set_has_boarderror();
  void clear_has_boarderror();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr boarderror_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModbusCfg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ModbusCfg) */ {
 public:
  ModbusCfg();
  virtual ~ModbusCfg();

  ModbusCfg(const ModbusCfg& from);

  inline ModbusCfg& operator=(const ModbusCfg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModbusCfg(ModbusCfg&& from) noexcept
    : ModbusCfg() {
    *this = ::std::move(from);
  }

  inline ModbusCfg& operator=(ModbusCfg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModbusCfg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModbusCfg* internal_default_instance() {
    return reinterpret_cast<const ModbusCfg*>(
               &_ModbusCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ModbusCfg* other);
  friend void swap(ModbusCfg& a, ModbusCfg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModbusCfg* New() const final {
    return CreateMaybeMessage<ModbusCfg>(NULL);
  }

  ModbusCfg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModbusCfg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModbusCfg& from);
  void MergeFrom(const ModbusCfg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModbusCfg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string ip = 5;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 5;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required string device = 7;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 7;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // required string parity = 9;
  bool has_parity() const;
  void clear_parity();
  static const int kParityFieldNumber = 9;
  const ::std::string& parity() const;
  void set_parity(const ::std::string& value);
  #if LANG_CXX11
  void set_parity(::std::string&& value);
  #endif
  void set_parity(const char* value);
  void set_parity(const char* value, size_t size);
  ::std::string* mutable_parity();
  ::std::string* release_parity();
  void set_allocated_parity(::std::string* parity);

  // required .aubo.robot.communication.ModbusMode mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::aubo::robot::communication::ModbusMode mode() const;
  void set_mode(::aubo::robot::communication::ModbusMode value);

  // required uint32 slave = 4;
  bool has_slave() const;
  void clear_slave();
  static const int kSlaveFieldNumber = 4;
  ::google::protobuf::uint32 slave() const;
  void set_slave(::google::protobuf::uint32 value);

  // required uint32 port = 6;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 6;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // required uint32 baud = 8;
  bool has_baud() const;
  void clear_baud();
  static const int kBaudFieldNumber = 8;
  ::google::protobuf::uint32 baud() const;
  void set_baud(::google::protobuf::uint32 value);

  // required uint32 data_bits = 10;
  bool has_data_bits() const;
  void clear_data_bits();
  static const int kDataBitsFieldNumber = 10;
  ::google::protobuf::uint32 data_bits() const;
  void set_data_bits(::google::protobuf::uint32 value);

  // required uint32 stop_bits = 11;
  bool has_stop_bits() const;
  void clear_stop_bits();
  static const int kStopBitsFieldNumber = 11;
  ::google::protobuf::uint32 stop_bits() const;
  void set_stop_bits(::google::protobuf::uint32 value);

  // required uint32 response = 12;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 12;
  ::google::protobuf::uint32 response() const;
  void set_response(::google::protobuf::uint32 value);

  // required uint32 frequency = 13;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 13;
  ::google::protobuf::uint32 frequency() const;
  void set_frequency(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ModbusCfg)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_name();
  void clear_has_name();
  void set_has_mode();
  void clear_has_mode();
  void set_has_slave();
  void clear_has_slave();
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_device();
  void clear_has_device();
  void set_has_baud();
  void clear_has_baud();
  void set_has_parity();
  void clear_has_parity();
  void set_has_data_bits();
  void clear_has_data_bits();
  void set_has_stop_bits();
  void clear_has_stop_bits();
  void set_has_response();
  void clear_has_response();
  void set_has_frequency();
  void clear_has_frequency();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr parity_;
  int mode_;
  ::google::protobuf::uint32 slave_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 baud_;
  ::google::protobuf::uint32 data_bits_;
  ::google::protobuf::uint32 stop_bits_;
  ::google::protobuf::uint32 response_;
  ::google::protobuf::uint32 frequency_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TagIoCfg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.TagIoCfg) */ {
 public:
  TagIoCfg();
  virtual ~TagIoCfg();

  TagIoCfg(const TagIoCfg& from);

  inline TagIoCfg& operator=(const TagIoCfg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TagIoCfg(TagIoCfg&& from) noexcept
    : TagIoCfg() {
    *this = ::std::move(from);
  }

  inline TagIoCfg& operator=(TagIoCfg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TagIoCfg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagIoCfg* internal_default_instance() {
    return reinterpret_cast<const TagIoCfg*>(
               &_TagIoCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(TagIoCfg* other);
  friend void swap(TagIoCfg& a, TagIoCfg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TagIoCfg* New() const final {
    return CreateMaybeMessage<TagIoCfg>(NULL);
  }

  TagIoCfg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TagIoCfg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TagIoCfg& from);
  void MergeFrom(const TagIoCfg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagIoCfg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string io_name = 1;
  bool has_io_name() const;
  void clear_io_name();
  static const int kIoNameFieldNumber = 1;
  const ::std::string& io_name() const;
  void set_io_name(const ::std::string& value);
  #if LANG_CXX11
  void set_io_name(::std::string&& value);
  #endif
  void set_io_name(const char* value);
  void set_io_name(const char* value, size_t size);
  ::std::string* mutable_io_name();
  ::std::string* release_io_name();
  void set_allocated_io_name(::std::string* io_name);

  // required string modbus_uuid = 4;
  bool has_modbus_uuid() const;
  void clear_modbus_uuid();
  static const int kModbusUuidFieldNumber = 4;
  const ::std::string& modbus_uuid() const;
  void set_modbus_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_modbus_uuid(::std::string&& value);
  #endif
  void set_modbus_uuid(const char* value);
  void set_modbus_uuid(const char* value, size_t size);
  ::std::string* mutable_modbus_uuid();
  ::std::string* release_modbus_uuid();
  void set_allocated_modbus_uuid(::std::string* modbus_uuid);

  // required string io_id = 5;
  bool has_io_id() const;
  void clear_io_id();
  static const int kIoIdFieldNumber = 5;
  const ::std::string& io_id() const;
  void set_io_id(const ::std::string& value);
  #if LANG_CXX11
  void set_io_id(::std::string&& value);
  #endif
  void set_io_id(const char* value);
  void set_io_id(const char* value, size_t size);
  ::std::string* mutable_io_id();
  ::std::string* release_io_id();
  void set_allocated_io_id(::std::string* io_id);

  // required .aubo.robot.communication.TagIoType io_type = 2;
  bool has_io_type() const;
  void clear_io_type();
  static const int kIoTypeFieldNumber = 2;
  ::aubo::robot::communication::TagIoType io_type() const;
  void set_io_type(::aubo::robot::communication::TagIoType value);

  // required uint32 register_addr = 3;
  bool has_register_addr() const;
  void clear_register_addr();
  static const int kRegisterAddrFieldNumber = 3;
  ::google::protobuf::uint32 register_addr() const;
  void set_register_addr(::google::protobuf::uint32 value);

  // required double io_value = 6;
  bool has_io_value() const;
  void clear_io_value();
  static const int kIoValueFieldNumber = 6;
  double io_value() const;
  void set_io_value(double value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.TagIoCfg)
 private:
  void set_has_io_name();
  void clear_has_io_name();
  void set_has_io_type();
  void clear_has_io_type();
  void set_has_register_addr();
  void clear_has_register_addr();
  void set_has_modbus_uuid();
  void clear_has_modbus_uuid();
  void set_has_io_id();
  void clear_has_io_id();
  void set_has_io_value();
  void clear_has_io_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr io_name_;
  ::google::protobuf::internal::ArenaStringPtr modbus_uuid_;
  ::google::protobuf::internal::ArenaStringPtr io_id_;
  int io_type_;
  ::google::protobuf::uint32 register_addr_;
  double io_value_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToolDigitalStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ToolDigitalStatus) */ {
 public:
  ToolDigitalStatus();
  virtual ~ToolDigitalStatus();

  ToolDigitalStatus(const ToolDigitalStatus& from);

  inline ToolDigitalStatus& operator=(const ToolDigitalStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToolDigitalStatus(ToolDigitalStatus&& from) noexcept
    : ToolDigitalStatus() {
    *this = ::std::move(from);
  }

  inline ToolDigitalStatus& operator=(ToolDigitalStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToolDigitalStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToolDigitalStatus* internal_default_instance() {
    return reinterpret_cast<const ToolDigitalStatus*>(
               &_ToolDigitalStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ToolDigitalStatus* other);
  friend void swap(ToolDigitalStatus& a, ToolDigitalStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToolDigitalStatus* New() const final {
    return CreateMaybeMessage<ToolDigitalStatus>(NULL);
  }

  ToolDigitalStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToolDigitalStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ToolDigitalStatus& from);
  void MergeFrom(const ToolDigitalStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolDigitalStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ioType = 1;
  bool has_iotype() const;
  void clear_iotype();
  static const int kIoTypeFieldNumber = 1;
  ::google::protobuf::uint32 iotype() const;
  void set_iotype(::google::protobuf::uint32 value);

  // required uint32 ioData = 2;
  bool has_iodata() const;
  void clear_iodata();
  static const int kIoDataFieldNumber = 2;
  ::google::protobuf::uint32 iodata() const;
  void set_iodata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ToolDigitalStatus)
 private:
  void set_has_iotype();
  void clear_has_iotype();
  void set_has_iodata();
  void clear_has_iodata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 iotype_;
  ::google::protobuf::uint32 iodata_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotToolStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.RobotToolStatus) */ {
 public:
  RobotToolStatus();
  virtual ~RobotToolStatus();

  RobotToolStatus(const RobotToolStatus& from);

  inline RobotToolStatus& operator=(const RobotToolStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotToolStatus(RobotToolStatus&& from) noexcept
    : RobotToolStatus() {
    *this = ::std::move(from);
  }

  inline RobotToolStatus& operator=(RobotToolStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotToolStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotToolStatus* internal_default_instance() {
    return reinterpret_cast<const RobotToolStatus*>(
               &_RobotToolStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(RobotToolStatus* other);
  friend void swap(RobotToolStatus& a, RobotToolStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotToolStatus* New() const final {
    return CreateMaybeMessage<RobotToolStatus>(NULL);
  }

  RobotToolStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotToolStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotToolStatus& from);
  void MergeFrom(const RobotToolStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotToolStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float aiData = 2;
  int aidata_size() const;
  void clear_aidata();
  static const int kAiDataFieldNumber = 2;
  float aidata(int index) const;
  void set_aidata(int index, float value);
  void add_aidata(float value);
  const ::google::protobuf::RepeatedField< float >&
      aidata() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_aidata();

  // required uint32 ioData = 1;
  bool has_iodata() const;
  void clear_iodata();
  static const int kIoDataFieldNumber = 1;
  ::google::protobuf::uint32 iodata() const;
  void set_iodata(::google::protobuf::uint32 value);

  // required float systemVoltage = 3;
  bool has_systemvoltage() const;
  void clear_systemvoltage();
  static const int kSystemVoltageFieldNumber = 3;
  float systemvoltage() const;
  void set_systemvoltage(float value);

  // required float systemTemperature = 4;
  bool has_systemtemperature() const;
  void clear_systemtemperature();
  static const int kSystemTemperatureFieldNumber = 4;
  float systemtemperature() const;
  void set_systemtemperature(float value);

  // required uint32 errorStatus = 5;
  bool has_errorstatus() const;
  void clear_errorstatus();
  static const int kErrorStatusFieldNumber = 5;
  ::google::protobuf::uint32 errorstatus() const;
  void set_errorstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.RobotToolStatus)
 private:
  void set_has_iodata();
  void clear_has_iodata();
  void set_has_systemvoltage();
  void clear_has_systemvoltage();
  void set_has_systemtemperature();
  void clear_has_systemtemperature();
  void set_has_errorstatus();
  void clear_has_errorstatus();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< float > aidata_;
  ::google::protobuf::uint32 iodata_;
  float systemvoltage_;
  float systemtemperature_;
  ::google::protobuf::uint32 errorstatus_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class toolAllIOStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.toolAllIOStatus) */ {
 public:
  toolAllIOStatus();
  virtual ~toolAllIOStatus();

  toolAllIOStatus(const toolAllIOStatus& from);

  inline toolAllIOStatus& operator=(const toolAllIOStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  toolAllIOStatus(toolAllIOStatus&& from) noexcept
    : toolAllIOStatus() {
    *this = ::std::move(from);
  }

  inline toolAllIOStatus& operator=(toolAllIOStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const toolAllIOStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const toolAllIOStatus* internal_default_instance() {
    return reinterpret_cast<const toolAllIOStatus*>(
               &_toolAllIOStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(toolAllIOStatus* other);
  friend void swap(toolAllIOStatus& a, toolAllIOStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline toolAllIOStatus* New() const final {
    return CreateMaybeMessage<toolAllIOStatus>(NULL);
  }

  toolAllIOStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<toolAllIOStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const toolAllIOStatus& from);
  void MergeFrom(const toolAllIOStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(toolAllIOStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.ToolDigitalStatus digitalIoStatus = 5;
  int digitaliostatus_size() const;
  void clear_digitaliostatus();
  static const int kDigitalIoStatusFieldNumber = 5;
  ::aubo::robot::communication::ToolDigitalStatus* mutable_digitaliostatus(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ToolDigitalStatus >*
      mutable_digitaliostatus();
  const ::aubo::robot::communication::ToolDigitalStatus& digitaliostatus(int index) const;
  ::aubo::robot::communication::ToolDigitalStatus* add_digitaliostatus();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ToolDigitalStatus >&
      digitaliostatus() const;

  // repeated double aiData = 6;
  int aidata_size() const;
  void clear_aidata();
  static const int kAiDataFieldNumber = 6;
  double aidata(int index) const;
  void set_aidata(int index, double value);
  void add_aidata(double value);
  const ::google::protobuf::RepeatedField< double >&
      aidata() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_aidata();

  // required double systemVoltage = 2;
  bool has_systemvoltage() const;
  void clear_systemvoltage();
  static const int kSystemVoltageFieldNumber = 2;
  double systemvoltage() const;
  void set_systemvoltage(double value);

  // required uint32 powerType = 1;
  bool has_powertype() const;
  void clear_powertype();
  static const int kPowerTypeFieldNumber = 1;
  ::google::protobuf::uint32 powertype() const;
  void set_powertype(::google::protobuf::uint32 value);

  // required uint32 errorStatus = 4;
  bool has_errorstatus() const;
  void clear_errorstatus();
  static const int kErrorStatusFieldNumber = 4;
  ::google::protobuf::uint32 errorstatus() const;
  void set_errorstatus(::google::protobuf::uint32 value);

  // required double systemTemperature = 3;
  bool has_systemtemperature() const;
  void clear_systemtemperature();
  static const int kSystemTemperatureFieldNumber = 3;
  double systemtemperature() const;
  void set_systemtemperature(double value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.toolAllIOStatus)
 private:
  void set_has_powertype();
  void clear_has_powertype();
  void set_has_systemvoltage();
  void clear_has_systemvoltage();
  void set_has_systemtemperature();
  void clear_has_systemtemperature();
  void set_has_errorstatus();
  void clear_has_errorstatus();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ToolDigitalStatus > digitaliostatus_;
  ::google::protobuf::RepeatedField< double > aidata_;
  double systemvoltage_;
  ::google::protobuf::uint32 powertype_;
  ::google::protobuf::uint32 errorstatus_;
  double systemtemperature_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationToolAllIOStatusInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse) */ {
 public:
  ProtoCommunicationToolAllIOStatusInfoResponse();
  virtual ~ProtoCommunicationToolAllIOStatusInfoResponse();

  ProtoCommunicationToolAllIOStatusInfoResponse(const ProtoCommunicationToolAllIOStatusInfoResponse& from);

  inline ProtoCommunicationToolAllIOStatusInfoResponse& operator=(const ProtoCommunicationToolAllIOStatusInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationToolAllIOStatusInfoResponse(ProtoCommunicationToolAllIOStatusInfoResponse&& from) noexcept
    : ProtoCommunicationToolAllIOStatusInfoResponse() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationToolAllIOStatusInfoResponse& operator=(ProtoCommunicationToolAllIOStatusInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationToolAllIOStatusInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationToolAllIOStatusInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationToolAllIOStatusInfoResponse*>(
               &_ProtoCommunicationToolAllIOStatusInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ProtoCommunicationToolAllIOStatusInfoResponse* other);
  friend void swap(ProtoCommunicationToolAllIOStatusInfoResponse& a, ProtoCommunicationToolAllIOStatusInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationToolAllIOStatusInfoResponse* New() const final {
    return CreateMaybeMessage<ProtoCommunicationToolAllIOStatusInfoResponse>(NULL);
  }

  ProtoCommunicationToolAllIOStatusInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationToolAllIOStatusInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationToolAllIOStatusInfoResponse& from);
  void MergeFrom(const ProtoCommunicationToolAllIOStatusInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationToolAllIOStatusInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .aubo.robot.communication.toolAllIOStatus toolIOStatus = 1;
  bool has_tooliostatus() const;
  void clear_tooliostatus();
  static const int kToolIOStatusFieldNumber = 1;
  private:
  const ::aubo::robot::communication::toolAllIOStatus& _internal_tooliostatus() const;
  public:
  const ::aubo::robot::communication::toolAllIOStatus& tooliostatus() const;
  ::aubo::robot::communication::toolAllIOStatus* release_tooliostatus();
  ::aubo::robot::communication::toolAllIOStatus* mutable_tooliostatus();
  void set_allocated_tooliostatus(::aubo::robot::communication::toolAllIOStatus* tooliostatus);

  // required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  private:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo() const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* release_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse)
 private:
  void set_has_tooliostatus();
  void clear_has_tooliostatus();
  void set_has_errorinfo();
  void clear_has_errorinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::aubo::robot::communication::toolAllIOStatus* tooliostatus_;
  ::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationRobotBoardFirmware : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware) */ {
 public:
  ProtoCommunicationRobotBoardFirmware();
  virtual ~ProtoCommunicationRobotBoardFirmware();

  ProtoCommunicationRobotBoardFirmware(const ProtoCommunicationRobotBoardFirmware& from);

  inline ProtoCommunicationRobotBoardFirmware& operator=(const ProtoCommunicationRobotBoardFirmware& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationRobotBoardFirmware(ProtoCommunicationRobotBoardFirmware&& from) noexcept
    : ProtoCommunicationRobotBoardFirmware() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationRobotBoardFirmware& operator=(ProtoCommunicationRobotBoardFirmware&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationRobotBoardFirmware& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationRobotBoardFirmware* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationRobotBoardFirmware*>(
               &_ProtoCommunicationRobotBoardFirmware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(ProtoCommunicationRobotBoardFirmware* other);
  friend void swap(ProtoCommunicationRobotBoardFirmware& a, ProtoCommunicationRobotBoardFirmware& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationRobotBoardFirmware* New() const final {
    return CreateMaybeMessage<ProtoCommunicationRobotBoardFirmware>(NULL);
  }

  ProtoCommunicationRobotBoardFirmware* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationRobotBoardFirmware>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationRobotBoardFirmware& from);
  void MergeFrom(const ProtoCommunicationRobotBoardFirmware& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationRobotBoardFirmware* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes firmwareContent = 2;
  bool has_firmwarecontent() const;
  void clear_firmwarecontent();
  static const int kFirmwareContentFieldNumber = 2;
  const ::std::string& firmwarecontent() const;
  void set_firmwarecontent(const ::std::string& value);
  #if LANG_CXX11
  void set_firmwarecontent(::std::string&& value);
  #endif
  void set_firmwarecontent(const char* value);
  void set_firmwarecontent(const void* value, size_t size);
  ::std::string* mutable_firmwarecontent();
  ::std::string* release_firmwarecontent();
  void set_allocated_firmwarecontent(::std::string* firmwarecontent);

  // required int32 command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::google::protobuf::int32 command() const;
  void set_command(::google::protobuf::int32 value);

  // required int32 firmwareContentSize = 3;
  bool has_firmwarecontentsize() const;
  void clear_firmwarecontentsize();
  static const int kFirmwareContentSizeFieldNumber = 3;
  ::google::protobuf::int32 firmwarecontentsize() const;
  void set_firmwarecontentsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_firmwarecontent();
  void clear_has_firmwarecontent();
  void set_has_firmwarecontentsize();
  void clear_has_firmwarecontentsize();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr firmwarecontent_;
  ::google::protobuf::int32 command_;
  ::google::protobuf::int32 firmwarecontentsize_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationEthernetDeviceNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse) */ {
 public:
  ProtoCommunicationEthernetDeviceNameResponse();
  virtual ~ProtoCommunicationEthernetDeviceNameResponse();

  ProtoCommunicationEthernetDeviceNameResponse(const ProtoCommunicationEthernetDeviceNameResponse& from);

  inline ProtoCommunicationEthernetDeviceNameResponse& operator=(const ProtoCommunicationEthernetDeviceNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationEthernetDeviceNameResponse(ProtoCommunicationEthernetDeviceNameResponse&& from) noexcept
    : ProtoCommunicationEthernetDeviceNameResponse() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationEthernetDeviceNameResponse& operator=(ProtoCommunicationEthernetDeviceNameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationEthernetDeviceNameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationEthernetDeviceNameResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationEthernetDeviceNameResponse*>(
               &_ProtoCommunicationEthernetDeviceNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ProtoCommunicationEthernetDeviceNameResponse* other);
  friend void swap(ProtoCommunicationEthernetDeviceNameResponse& a, ProtoCommunicationEthernetDeviceNameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationEthernetDeviceNameResponse* New() const final {
    return CreateMaybeMessage<ProtoCommunicationEthernetDeviceNameResponse>(NULL);
  }

  ProtoCommunicationEthernetDeviceNameResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationEthernetDeviceNameResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationEthernetDeviceNameResponse& from);
  void MergeFrom(const ProtoCommunicationEthernetDeviceNameResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationEthernetDeviceNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  private:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo() const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* release_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_errorinfo();
  void clear_has_errorinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationDoubleVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationDoubleVector) */ {
 public:
  ProtoCommunicationDoubleVector();
  virtual ~ProtoCommunicationDoubleVector();

  ProtoCommunicationDoubleVector(const ProtoCommunicationDoubleVector& from);

  inline ProtoCommunicationDoubleVector& operator=(const ProtoCommunicationDoubleVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationDoubleVector(ProtoCommunicationDoubleVector&& from) noexcept
    : ProtoCommunicationDoubleVector() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationDoubleVector& operator=(ProtoCommunicationDoubleVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationDoubleVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationDoubleVector* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationDoubleVector*>(
               &_ProtoCommunicationDoubleVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(ProtoCommunicationDoubleVector* other);
  friend void swap(ProtoCommunicationDoubleVector& a, ProtoCommunicationDoubleVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationDoubleVector* New() const final {
    return CreateMaybeMessage<ProtoCommunicationDoubleVector>(NULL);
  }

  ProtoCommunicationDoubleVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationDoubleVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationDoubleVector& from);
  void MergeFrom(const ProtoCommunicationDoubleVector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationDoubleVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::google::protobuf::RepeatedField< double >&
      value() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationDoubleVector)
 private:
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > value_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationIntVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationIntVector) */ {
 public:
  ProtoCommunicationIntVector();
  virtual ~ProtoCommunicationIntVector();

  ProtoCommunicationIntVector(const ProtoCommunicationIntVector& from);

  inline ProtoCommunicationIntVector& operator=(const ProtoCommunicationIntVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationIntVector(ProtoCommunicationIntVector&& from) noexcept
    : ProtoCommunicationIntVector() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationIntVector& operator=(ProtoCommunicationIntVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationIntVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationIntVector* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationIntVector*>(
               &_ProtoCommunicationIntVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(ProtoCommunicationIntVector* other);
  friend void swap(ProtoCommunicationIntVector& a, ProtoCommunicationIntVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationIntVector* New() const final {
    return CreateMaybeMessage<ProtoCommunicationIntVector>(NULL);
  }

  ProtoCommunicationIntVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationIntVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationIntVector& from);
  void MergeFrom(const ProtoCommunicationIntVector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationIntVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value(int index) const;
  void set_value(int index, ::google::protobuf::int32 value);
  void add_value(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationIntVector)
 private:
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationDoubleVectorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse) */ {
 public:
  ProtoCommunicationDoubleVectorResponse();
  virtual ~ProtoCommunicationDoubleVectorResponse();

  ProtoCommunicationDoubleVectorResponse(const ProtoCommunicationDoubleVectorResponse& from);

  inline ProtoCommunicationDoubleVectorResponse& operator=(const ProtoCommunicationDoubleVectorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationDoubleVectorResponse(ProtoCommunicationDoubleVectorResponse&& from) noexcept
    : ProtoCommunicationDoubleVectorResponse() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationDoubleVectorResponse& operator=(ProtoCommunicationDoubleVectorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationDoubleVectorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationDoubleVectorResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationDoubleVectorResponse*>(
               &_ProtoCommunicationDoubleVectorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ProtoCommunicationDoubleVectorResponse* other);
  friend void swap(ProtoCommunicationDoubleVectorResponse& a, ProtoCommunicationDoubleVectorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationDoubleVectorResponse* New() const final {
    return CreateMaybeMessage<ProtoCommunicationDoubleVectorResponse>(NULL);
  }

  ProtoCommunicationDoubleVectorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationDoubleVectorResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationDoubleVectorResponse& from);
  void MergeFrom(const ProtoCommunicationDoubleVectorResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationDoubleVectorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::google::protobuf::RepeatedField< double >&
      value() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  private:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo() const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* release_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo);

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse)
 private:
  void set_has_num();
  void clear_has_num();
  void set_has_errorinfo();
  void clear_has_errorinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > value_;
  ::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoCommunicationIntVectorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoCommunicationIntVectorResponse) */ {
 public:
  ProtoCommunicationIntVectorResponse();
  virtual ~ProtoCommunicationIntVectorResponse();

  ProtoCommunicationIntVectorResponse(const ProtoCommunicationIntVectorResponse& from);

  inline ProtoCommunicationIntVectorResponse& operator=(const ProtoCommunicationIntVectorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCommunicationIntVectorResponse(ProtoCommunicationIntVectorResponse&& from) noexcept
    : ProtoCommunicationIntVectorResponse() {
    *this = ::std::move(from);
  }

  inline ProtoCommunicationIntVectorResponse& operator=(ProtoCommunicationIntVectorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoCommunicationIntVectorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCommunicationIntVectorResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoCommunicationIntVectorResponse*>(
               &_ProtoCommunicationIntVectorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(ProtoCommunicationIntVectorResponse* other);
  friend void swap(ProtoCommunicationIntVectorResponse& a, ProtoCommunicationIntVectorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCommunicationIntVectorResponse* New() const final {
    return CreateMaybeMessage<ProtoCommunicationIntVectorResponse>(NULL);
  }

  ProtoCommunicationIntVectorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoCommunicationIntVectorResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoCommunicationIntVectorResponse& from);
  void MergeFrom(const ProtoCommunicationIntVectorResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCommunicationIntVectorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value(int index) const;
  void set_value(int index, ::google::protobuf::int32 value);
  void add_value(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 3;
  private:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo() const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* release_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo);

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoCommunicationIntVectorResponse)
 private:
  void set_has_num();
  void clear_has_num();
  void set_has_errorinfo();
  void clear_has_errorinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  ::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoJointCommonData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoJointCommonData) */ {
 public:
  ProtoJointCommonData();
  virtual ~ProtoJointCommonData();

  ProtoJointCommonData(const ProtoJointCommonData& from);

  inline ProtoJointCommonData& operator=(const ProtoJointCommonData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoJointCommonData(ProtoJointCommonData&& from) noexcept
    : ProtoJointCommonData() {
    *this = ::std::move(from);
  }

  inline ProtoJointCommonData& operator=(ProtoJointCommonData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoJointCommonData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoJointCommonData* internal_default_instance() {
    return reinterpret_cast<const ProtoJointCommonData*>(
               &_ProtoJointCommonData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ProtoJointCommonData* other);
  friend void swap(ProtoJointCommonData& a, ProtoJointCommonData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoJointCommonData* New() const final {
    return CreateMaybeMessage<ProtoJointCommonData>(NULL);
  }

  ProtoJointCommonData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoJointCommonData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoJointCommonData& from);
  void MergeFrom(const ProtoJointCommonData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoJointCommonData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 JointCurVol = 1;
  bool has_jointcurvol() const;
  void clear_jointcurvol();
  static const int kJointCurVolFieldNumber = 1;
  ::google::protobuf::int32 jointcurvol() const;
  void set_jointcurvol(::google::protobuf::int32 value);

  // required int32 JointCurTemp = 2;
  bool has_jointcurtemp() const;
  void clear_jointcurtemp();
  static const int kJointCurTempFieldNumber = 2;
  ::google::protobuf::int32 jointcurtemp() const;
  void set_jointcurtemp(::google::protobuf::int32 value);

  // required int32 JointWorkMode = 3;
  bool has_jointworkmode() const;
  void clear_jointworkmode();
  static const int kJointWorkModeFieldNumber = 3;
  ::google::protobuf::int32 jointworkmode() const;
  void set_jointworkmode(::google::protobuf::int32 value);

  // required int32 JointDriEnable = 4;
  bool has_jointdrienable() const;
  void clear_jointdrienable();
  static const int kJointDriEnableFieldNumber = 4;
  ::google::protobuf::int32 jointdrienable() const;
  void set_jointdrienable(::google::protobuf::int32 value);

  // required int32 JointOpenPwm = 5;
  bool has_jointopenpwm() const;
  void clear_jointopenpwm();
  static const int kJointOpenPwmFieldNumber = 5;
  ::google::protobuf::int32 jointopenpwm() const;
  void set_jointopenpwm(::google::protobuf::int32 value);

  // required int32 JointTagCurrent = 6;
  bool has_jointtagcurrent() const;
  void clear_jointtagcurrent();
  static const int kJointTagCurrentFieldNumber = 6;
  ::google::protobuf::int32 jointtagcurrent() const;
  void set_jointtagcurrent(::google::protobuf::int32 value);

  // required int32 JointTagSpeed = 7;
  bool has_jointtagspeed() const;
  void clear_jointtagspeed();
  static const int kJointTagSpeedFieldNumber = 7;
  ::google::protobuf::int32 jointtagspeed() const;
  void set_jointtagspeed(::google::protobuf::int32 value);

  // required int32 JointTagPos = 8;
  bool has_jointtagpos() const;
  void clear_jointtagpos();
  static const int kJointTagPosFieldNumber = 8;
  ::google::protobuf::int32 jointtagpos() const;
  void set_jointtagpos(::google::protobuf::int32 value);

  // required int32 JointMaxCur = 9;
  bool has_jointmaxcur() const;
  void clear_jointmaxcur();
  static const int kJointMaxCurFieldNumber = 9;
  ::google::protobuf::int32 jointmaxcur() const;
  void set_jointmaxcur(::google::protobuf::int32 value);

  // required int32 JointMaxSpeed = 10;
  bool has_jointmaxspeed() const;
  void clear_jointmaxspeed();
  static const int kJointMaxSpeedFieldNumber = 10;
  ::google::protobuf::int32 jointmaxspeed() const;
  void set_jointmaxspeed(::google::protobuf::int32 value);

  // required int32 JointMaxAcc = 11;
  bool has_jointmaxacc() const;
  void clear_jointmaxacc();
  static const int kJointMaxAccFieldNumber = 11;
  ::google::protobuf::int32 jointmaxacc() const;
  void set_jointmaxacc(::google::protobuf::int32 value);

  // required int32 JointMINPos = 12;
  bool has_jointminpos() const;
  void clear_jointminpos();
  static const int kJointMINPosFieldNumber = 12;
  ::google::protobuf::int32 jointminpos() const;
  void set_jointminpos(::google::protobuf::int32 value);

  // required int32 JointMAXPos = 13;
  bool has_jointmaxpos() const;
  void clear_jointmaxpos();
  static const int kJointMAXPosFieldNumber = 13;
  ::google::protobuf::int32 jointmaxpos() const;
  void set_jointmaxpos(::google::protobuf::int32 value);

  // required int32 JointSEVLock = 14;
  bool has_jointsevlock() const;
  void clear_jointsevlock();
  static const int kJointSEVLockFieldNumber = 14;
  ::google::protobuf::int32 jointsevlock() const;
  void set_jointsevlock(::google::protobuf::int32 value);

  // required int32 JointCurP = 15;
  bool has_jointcurp() const;
  void clear_jointcurp();
  static const int kJointCurPFieldNumber = 15;
  ::google::protobuf::int32 jointcurp() const;
  void set_jointcurp(::google::protobuf::int32 value);

  // required int32 JointCurI = 16;
  bool has_jointcuri() const;
  void clear_jointcuri();
  static const int kJointCurIFieldNumber = 16;
  ::google::protobuf::int32 jointcuri() const;
  void set_jointcuri(::google::protobuf::int32 value);

  // required int32 JointCurD = 17;
  bool has_jointcurd() const;
  void clear_jointcurd();
  static const int kJointCurDFieldNumber = 17;
  ::google::protobuf::int32 jointcurd() const;
  void set_jointcurd(::google::protobuf::int32 value);

  // required int32 JointSpeedP = 18;
  bool has_jointspeedp() const;
  void clear_jointspeedp();
  static const int kJointSpeedPFieldNumber = 18;
  ::google::protobuf::int32 jointspeedp() const;
  void set_jointspeedp(::google::protobuf::int32 value);

  // required int32 JointSpeedI = 19;
  bool has_jointspeedi() const;
  void clear_jointspeedi();
  static const int kJointSpeedIFieldNumber = 19;
  ::google::protobuf::int32 jointspeedi() const;
  void set_jointspeedi(::google::protobuf::int32 value);

  // required int32 JointSpeedD = 20;
  bool has_jointspeedd() const;
  void clear_jointspeedd();
  static const int kJointSpeedDFieldNumber = 20;
  ::google::protobuf::int32 jointspeedd() const;
  void set_jointspeedd(::google::protobuf::int32 value);

  // required int32 JointSpeedDS = 21;
  bool has_jointspeedds() const;
  void clear_jointspeedds();
  static const int kJointSpeedDSFieldNumber = 21;
  ::google::protobuf::int32 jointspeedds() const;
  void set_jointspeedds(::google::protobuf::int32 value);

  // required int32 JointPosP = 22;
  bool has_jointposp() const;
  void clear_jointposp();
  static const int kJointPosPFieldNumber = 22;
  ::google::protobuf::int32 jointposp() const;
  void set_jointposp(::google::protobuf::int32 value);

  // required int32 JointPosI = 23;
  bool has_jointposi() const;
  void clear_jointposi();
  static const int kJointPosIFieldNumber = 23;
  ::google::protobuf::int32 jointposi() const;
  void set_jointposi(::google::protobuf::int32 value);

  // required int32 JointPosD = 24;
  bool has_jointposd() const;
  void clear_jointposd();
  static const int kJointPosDFieldNumber = 24;
  ::google::protobuf::int32 jointposd() const;
  void set_jointposd(::google::protobuf::int32 value);

  // required int32 JointPosDS = 25;
  bool has_jointposds() const;
  void clear_jointposds();
  static const int kJointPosDSFieldNumber = 25;
  ::google::protobuf::int32 jointposds() const;
  void set_jointposds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoJointCommonData)
 private:
  void set_has_jointcurvol();
  void clear_has_jointcurvol();
  void set_has_jointcurtemp();
  void clear_has_jointcurtemp();
  void set_has_jointworkmode();
  void clear_has_jointworkmode();
  void set_has_jointdrienable();
  void clear_has_jointdrienable();
  void set_has_jointopenpwm();
  void clear_has_jointopenpwm();
  void set_has_jointtagcurrent();
  void clear_has_jointtagcurrent();
  void set_has_jointtagspeed();
  void clear_has_jointtagspeed();
  void set_has_jointtagpos();
  void clear_has_jointtagpos();
  void set_has_jointmaxcur();
  void clear_has_jointmaxcur();
  void set_has_jointmaxspeed();
  void clear_has_jointmaxspeed();
  void set_has_jointmaxacc();
  void clear_has_jointmaxacc();
  void set_has_jointminpos();
  void clear_has_jointminpos();
  void set_has_jointmaxpos();
  void clear_has_jointmaxpos();
  void set_has_jointsevlock();
  void clear_has_jointsevlock();
  void set_has_jointcurp();
  void clear_has_jointcurp();
  void set_has_jointcuri();
  void clear_has_jointcuri();
  void set_has_jointcurd();
  void clear_has_jointcurd();
  void set_has_jointspeedp();
  void clear_has_jointspeedp();
  void set_has_jointspeedi();
  void clear_has_jointspeedi();
  void set_has_jointspeedd();
  void clear_has_jointspeedd();
  void set_has_jointspeedds();
  void clear_has_jointspeedds();
  void set_has_jointposp();
  void clear_has_jointposp();
  void set_has_jointposi();
  void clear_has_jointposi();
  void set_has_jointposd();
  void clear_has_jointposd();
  void set_has_jointposds();
  void clear_has_jointposds();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 jointcurvol_;
  ::google::protobuf::int32 jointcurtemp_;
  ::google::protobuf::int32 jointworkmode_;
  ::google::protobuf::int32 jointdrienable_;
  ::google::protobuf::int32 jointopenpwm_;
  ::google::protobuf::int32 jointtagcurrent_;
  ::google::protobuf::int32 jointtagspeed_;
  ::google::protobuf::int32 jointtagpos_;
  ::google::protobuf::int32 jointmaxcur_;
  ::google::protobuf::int32 jointmaxspeed_;
  ::google::protobuf::int32 jointmaxacc_;
  ::google::protobuf::int32 jointminpos_;
  ::google::protobuf::int32 jointmaxpos_;
  ::google::protobuf::int32 jointsevlock_;
  ::google::protobuf::int32 jointcurp_;
  ::google::protobuf::int32 jointcuri_;
  ::google::protobuf::int32 jointcurd_;
  ::google::protobuf::int32 jointspeedp_;
  ::google::protobuf::int32 jointspeedi_;
  ::google::protobuf::int32 jointspeedd_;
  ::google::protobuf::int32 jointspeedds_;
  ::google::protobuf::int32 jointposp_;
  ::google::protobuf::int32 jointposi_;
  ::google::protobuf::int32 jointposd_;
  ::google::protobuf::int32 jointposds_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtoJointCommonDataResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aubo.robot.communication.ProtoJointCommonDataResponse) */ {
 public:
  ProtoJointCommonDataResponse();
  virtual ~ProtoJointCommonDataResponse();

  ProtoJointCommonDataResponse(const ProtoJointCommonDataResponse& from);

  inline ProtoJointCommonDataResponse& operator=(const ProtoJointCommonDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoJointCommonDataResponse(ProtoJointCommonDataResponse&& from) noexcept
    : ProtoJointCommonDataResponse() {
    *this = ::std::move(from);
  }

  inline ProtoJointCommonDataResponse& operator=(ProtoJointCommonDataResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoJointCommonDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoJointCommonDataResponse* internal_default_instance() {
    return reinterpret_cast<const ProtoJointCommonDataResponse*>(
               &_ProtoJointCommonDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(ProtoJointCommonDataResponse* other);
  friend void swap(ProtoJointCommonDataResponse& a, ProtoJointCommonDataResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoJointCommonDataResponse* New() const final {
    return CreateMaybeMessage<ProtoJointCommonDataResponse>(NULL);
  }

  ProtoJointCommonDataResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtoJointCommonDataResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtoJointCommonDataResponse& from);
  void MergeFrom(const ProtoJointCommonDataResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoJointCommonDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aubo.robot.communication.ProtoJointCommonData JointCommonData = 1;
  int jointcommondata_size() const;
  void clear_jointcommondata();
  static const int kJointCommonDataFieldNumber = 1;
  ::aubo::robot::communication::ProtoJointCommonData* mutable_jointcommondata(int index);
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoJointCommonData >*
      mutable_jointcommondata();
  const ::aubo::robot::communication::ProtoJointCommonData& jointcommondata(int index) const;
  ::aubo::robot::communication::ProtoJointCommonData* add_jointcommondata();
  const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoJointCommonData >&
      jointcommondata() const;

  // required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
  bool has_errorinfo() const;
  void clear_errorinfo();
  static const int kErrorInfoFieldNumber = 2;
  private:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& _internal_errorinfo() const;
  public:
  const ::aubo::robot::communication::ProtoRobotCommonResponse& errorinfo() const;
  ::aubo::robot::communication::ProtoRobotCommonResponse* release_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* mutable_errorinfo();
  void set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo);

  // @@protoc_insertion_point(class_scope:aubo.robot.communication.ProtoJointCommonDataResponse)
 private:
  void set_has_errorinfo();
  void clear_has_errorinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoJointCommonData > jointcommondata_;
  ::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo_;
  friend struct ::protobuf_robotcommunication_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JointStatus

// required int32 jointCurrentI = 1;
inline bool JointStatus::has_jointcurrenti() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointStatus::set_has_jointcurrenti() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointStatus::clear_has_jointcurrenti() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointStatus::clear_jointcurrenti() {
  jointcurrenti_ = 0;
  clear_has_jointcurrenti();
}
inline ::google::protobuf::int32 JointStatus::jointcurrenti() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointCurrentI)
  return jointcurrenti_;
}
inline void JointStatus::set_jointcurrenti(::google::protobuf::int32 value) {
  set_has_jointcurrenti();
  jointcurrenti_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointCurrentI)
}

// required int32 jointSpeedMoto = 2;
inline bool JointStatus::has_jointspeedmoto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointStatus::set_has_jointspeedmoto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointStatus::clear_has_jointspeedmoto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointStatus::clear_jointspeedmoto() {
  jointspeedmoto_ = 0;
  clear_has_jointspeedmoto();
}
inline ::google::protobuf::int32 JointStatus::jointspeedmoto() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointSpeedMoto)
  return jointspeedmoto_;
}
inline void JointStatus::set_jointspeedmoto(::google::protobuf::int32 value) {
  set_has_jointspeedmoto();
  jointspeedmoto_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointSpeedMoto)
}

// required float jointPosJ = 3;
inline bool JointStatus::has_jointposj() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JointStatus::set_has_jointposj() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JointStatus::clear_has_jointposj() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JointStatus::clear_jointposj() {
  jointposj_ = 0;
  clear_has_jointposj();
}
inline float JointStatus::jointposj() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointPosJ)
  return jointposj_;
}
inline void JointStatus::set_jointposj(float value) {
  set_has_jointposj();
  jointposj_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointPosJ)
}

// required float jointCurVol = 4;
inline bool JointStatus::has_jointcurvol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JointStatus::set_has_jointcurvol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JointStatus::clear_has_jointcurvol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JointStatus::clear_jointcurvol() {
  jointcurvol_ = 0;
  clear_has_jointcurvol();
}
inline float JointStatus::jointcurvol() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointCurVol)
  return jointcurvol_;
}
inline void JointStatus::set_jointcurvol(float value) {
  set_has_jointcurvol();
  jointcurvol_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointCurVol)
}

// required float jointCurTemp = 5;
inline bool JointStatus::has_jointcurtemp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JointStatus::set_has_jointcurtemp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JointStatus::clear_has_jointcurtemp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JointStatus::clear_jointcurtemp() {
  jointcurtemp_ = 0;
  clear_has_jointcurtemp();
}
inline float JointStatus::jointcurtemp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointCurTemp)
  return jointcurtemp_;
}
inline void JointStatus::set_jointcurtemp(float value) {
  set_has_jointcurtemp();
  jointcurtemp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointCurTemp)
}

// required int32 jointTagCurrentI = 6;
inline bool JointStatus::has_jointtagcurrenti() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JointStatus::set_has_jointtagcurrenti() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JointStatus::clear_has_jointtagcurrenti() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JointStatus::clear_jointtagcurrenti() {
  jointtagcurrenti_ = 0;
  clear_has_jointtagcurrenti();
}
inline ::google::protobuf::int32 JointStatus::jointtagcurrenti() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointTagCurrentI)
  return jointtagcurrenti_;
}
inline void JointStatus::set_jointtagcurrenti(::google::protobuf::int32 value) {
  set_has_jointtagcurrenti();
  jointtagcurrenti_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointTagCurrentI)
}

// required float jointTagSpeedMoto = 7;
inline bool JointStatus::has_jointtagspeedmoto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void JointStatus::set_has_jointtagspeedmoto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void JointStatus::clear_has_jointtagspeedmoto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void JointStatus::clear_jointtagspeedmoto() {
  jointtagspeedmoto_ = 0;
  clear_has_jointtagspeedmoto();
}
inline float JointStatus::jointtagspeedmoto() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointTagSpeedMoto)
  return jointtagspeedmoto_;
}
inline void JointStatus::set_jointtagspeedmoto(float value) {
  set_has_jointtagspeedmoto();
  jointtagspeedmoto_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointTagSpeedMoto)
}

// required float jointTagPosJ = 8;
inline bool JointStatus::has_jointtagposj() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void JointStatus::set_has_jointtagposj() {
  _has_bits_[0] |= 0x00000080u;
}
inline void JointStatus::clear_has_jointtagposj() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void JointStatus::clear_jointtagposj() {
  jointtagposj_ = 0;
  clear_has_jointtagposj();
}
inline float JointStatus::jointtagposj() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointTagPosJ)
  return jointtagposj_;
}
inline void JointStatus::set_jointtagposj(float value) {
  set_has_jointtagposj();
  jointtagposj_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointTagPosJ)
}

// required uint32 jointErrorNum = 9;
inline bool JointStatus::has_jointerrornum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void JointStatus::set_has_jointerrornum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void JointStatus::clear_has_jointerrornum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void JointStatus::clear_jointerrornum() {
  jointerrornum_ = 0u;
  clear_has_jointerrornum();
}
inline ::google::protobuf::uint32 JointStatus::jointerrornum() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointStatus.jointErrorNum)
  return jointerrornum_;
}
inline void JointStatus::set_jointerrornum(::google::protobuf::uint32 value) {
  set_has_jointerrornum();
  jointerrornum_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointStatus.jointErrorNum)
}

// -------------------------------------------------------------------

// RobotCollisionCurrent

// repeated uint32 jointCollisionCurrent = 1;
inline int RobotCollisionCurrent::jointcollisioncurrent_size() const {
  return jointcollisioncurrent_.size();
}
inline void RobotCollisionCurrent::clear_jointcollisioncurrent() {
  jointcollisioncurrent_.Clear();
}
inline ::google::protobuf::uint32 RobotCollisionCurrent::jointcollisioncurrent(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotCollisionCurrent.jointCollisionCurrent)
  return jointcollisioncurrent_.Get(index);
}
inline void RobotCollisionCurrent::set_jointcollisioncurrent(int index, ::google::protobuf::uint32 value) {
  jointcollisioncurrent_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotCollisionCurrent.jointCollisionCurrent)
}
inline void RobotCollisionCurrent::add_jointcollisioncurrent(::google::protobuf::uint32 value) {
  jointcollisioncurrent_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotCollisionCurrent.jointCollisionCurrent)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RobotCollisionCurrent::jointcollisioncurrent() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotCollisionCurrent.jointCollisionCurrent)
  return jointcollisioncurrent_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RobotCollisionCurrent::mutable_jointcollisioncurrent() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotCollisionCurrent.jointCollisionCurrent)
  return &jointcollisioncurrent_;
}

// required uint32 collisionClass = 2;
inline bool RobotCollisionCurrent::has_collisionclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotCollisionCurrent::set_has_collisionclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotCollisionCurrent::clear_has_collisionclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotCollisionCurrent::clear_collisionclass() {
  collisionclass_ = 0u;
  clear_has_collisionclass();
}
inline ::google::protobuf::uint32 RobotCollisionCurrent::collisionclass() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotCollisionCurrent.collisionClass)
  return collisionclass_;
}
inline void RobotCollisionCurrent::set_collisionclass(::google::protobuf::uint32 value) {
  set_has_collisionclass();
  collisionclass_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotCollisionCurrent.collisionClass)
}

// -------------------------------------------------------------------

// TcpParam

// required float positionX = 1;
inline bool TcpParam::has_positionx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpParam::set_has_positionx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpParam::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpParam::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float TcpParam::positionx() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TcpParam.positionX)
  return positionx_;
}
inline void TcpParam::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TcpParam.positionX)
}

// required float positionY = 2;
inline bool TcpParam::has_positiony() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpParam::set_has_positiony() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpParam::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpParam::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float TcpParam::positiony() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TcpParam.positionY)
  return positiony_;
}
inline void TcpParam::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TcpParam.positionY)
}

// required float positionZ = 3;
inline bool TcpParam::has_positionz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpParam::set_has_positionz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpParam::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpParam::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float TcpParam::positionz() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TcpParam.positionZ)
  return positionz_;
}
inline void TcpParam::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TcpParam.positionZ)
}

// required float payload = 4;
inline bool TcpParam::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpParam::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpParam::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpParam::clear_payload() {
  payload_ = 0;
  clear_has_payload();
}
inline float TcpParam::payload() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TcpParam.payload)
  return payload_;
}
inline void TcpParam::set_payload(float value) {
  set_has_payload();
  payload_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TcpParam.payload)
}

// -------------------------------------------------------------------

// RobotTcpParam

// required .aubo.robot.communication.TcpParam paramAutorun = 1;
inline bool RobotTcpParam::has_paramautorun() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotTcpParam::set_has_paramautorun() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotTcpParam::clear_has_paramautorun() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotTcpParam::clear_paramautorun() {
  if (paramautorun_ != NULL) paramautorun_->Clear();
  clear_has_paramautorun();
}
inline const ::aubo::robot::communication::TcpParam& RobotTcpParam::_internal_paramautorun() const {
  return *paramautorun_;
}
inline const ::aubo::robot::communication::TcpParam& RobotTcpParam::paramautorun() const {
  const ::aubo::robot::communication::TcpParam* p = paramautorun_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotTcpParam.paramAutorun)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::TcpParam*>(
      &::aubo::robot::communication::_TcpParam_default_instance_);
}
inline ::aubo::robot::communication::TcpParam* RobotTcpParam::release_paramautorun() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.RobotTcpParam.paramAutorun)
  clear_has_paramautorun();
  ::aubo::robot::communication::TcpParam* temp = paramautorun_;
  paramautorun_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::TcpParam* RobotTcpParam::mutable_paramautorun() {
  set_has_paramautorun();
  if (paramautorun_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::TcpParam>(GetArenaNoVirtual());
    paramautorun_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.RobotTcpParam.paramAutorun)
  return paramautorun_;
}
inline void RobotTcpParam::set_allocated_paramautorun(::aubo::robot::communication::TcpParam* paramautorun) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete paramautorun_;
  }
  if (paramautorun) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      paramautorun = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, paramautorun, submessage_arena);
    }
    set_has_paramautorun();
  } else {
    clear_has_paramautorun();
  }
  paramautorun_ = paramautorun;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.RobotTcpParam.paramAutorun)
}

// required .aubo.robot.communication.TcpParam paramManual = 2;
inline bool RobotTcpParam::has_parammanual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotTcpParam::set_has_parammanual() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotTcpParam::clear_has_parammanual() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotTcpParam::clear_parammanual() {
  if (parammanual_ != NULL) parammanual_->Clear();
  clear_has_parammanual();
}
inline const ::aubo::robot::communication::TcpParam& RobotTcpParam::_internal_parammanual() const {
  return *parammanual_;
}
inline const ::aubo::robot::communication::TcpParam& RobotTcpParam::parammanual() const {
  const ::aubo::robot::communication::TcpParam* p = parammanual_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotTcpParam.paramManual)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::TcpParam*>(
      &::aubo::robot::communication::_TcpParam_default_instance_);
}
inline ::aubo::robot::communication::TcpParam* RobotTcpParam::release_parammanual() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.RobotTcpParam.paramManual)
  clear_has_parammanual();
  ::aubo::robot::communication::TcpParam* temp = parammanual_;
  parammanual_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::TcpParam* RobotTcpParam::mutable_parammanual() {
  set_has_parammanual();
  if (parammanual_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::TcpParam>(GetArenaNoVirtual());
    parammanual_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.RobotTcpParam.paramManual)
  return parammanual_;
}
inline void RobotTcpParam::set_allocated_parammanual(::aubo::robot::communication::TcpParam* parammanual) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parammanual_;
  }
  if (parammanual) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parammanual = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parammanual, submessage_arena);
    }
    set_has_parammanual();
  } else {
    clear_has_parammanual();
  }
  parammanual_ = parammanual;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.RobotTcpParam.paramManual)
}

// -------------------------------------------------------------------

// RobotGravityComponent

// required float x = 1;
inline bool RobotGravityComponent::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotGravityComponent::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotGravityComponent::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotGravityComponent::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float RobotGravityComponent::x() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotGravityComponent.x)
  return x_;
}
inline void RobotGravityComponent::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotGravityComponent.x)
}

// required float y = 2;
inline bool RobotGravityComponent::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotGravityComponent::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotGravityComponent::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotGravityComponent::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float RobotGravityComponent::y() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotGravityComponent.y)
  return y_;
}
inline void RobotGravityComponent::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotGravityComponent.y)
}

// required float z = 3;
inline bool RobotGravityComponent::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotGravityComponent::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotGravityComponent::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotGravityComponent::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float RobotGravityComponent::z() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotGravityComponent.z)
  return z_;
}
inline void RobotGravityComponent::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotGravityComponent.z)
}

// -------------------------------------------------------------------

// JointVersion

// required string hwVersion = 1;
inline bool JointVersion::has_hwversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointVersion::set_has_hwversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointVersion::clear_has_hwversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointVersion::clear_hwversion() {
  hwversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hwversion();
}
inline const ::std::string& JointVersion::hwversion() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointVersion.hwVersion)
  return hwversion_.GetNoArena();
}
inline void JointVersion::set_hwversion(const ::std::string& value) {
  set_has_hwversion();
  hwversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointVersion.hwVersion)
}
#if LANG_CXX11
inline void JointVersion::set_hwversion(::std::string&& value) {
  set_has_hwversion();
  hwversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.JointVersion.hwVersion)
}
#endif
inline void JointVersion::set_hwversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hwversion();
  hwversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.JointVersion.hwVersion)
}
inline void JointVersion::set_hwversion(const char* value, size_t size) {
  set_has_hwversion();
  hwversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.JointVersion.hwVersion)
}
inline ::std::string* JointVersion::mutable_hwversion() {
  set_has_hwversion();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.JointVersion.hwVersion)
  return hwversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointVersion::release_hwversion() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.JointVersion.hwVersion)
  if (!has_hwversion()) {
    return NULL;
  }
  clear_has_hwversion();
  return hwversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointVersion::set_allocated_hwversion(::std::string* hwversion) {
  if (hwversion != NULL) {
    set_has_hwversion();
  } else {
    clear_has_hwversion();
  }
  hwversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hwversion);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.JointVersion.hwVersion)
}

// required string swVersion = 2;
inline bool JointVersion::has_swversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointVersion::set_has_swversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointVersion::clear_has_swversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointVersion::clear_swversion() {
  swversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_swversion();
}
inline const ::std::string& JointVersion::swversion() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.JointVersion.swVersion)
  return swversion_.GetNoArena();
}
inline void JointVersion::set_swversion(const ::std::string& value) {
  set_has_swversion();
  swversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.JointVersion.swVersion)
}
#if LANG_CXX11
inline void JointVersion::set_swversion(::std::string&& value) {
  set_has_swversion();
  swversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.JointVersion.swVersion)
}
#endif
inline void JointVersion::set_swversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_swversion();
  swversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.JointVersion.swVersion)
}
inline void JointVersion::set_swversion(const char* value, size_t size) {
  set_has_swversion();
  swversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.JointVersion.swVersion)
}
inline ::std::string* JointVersion::mutable_swversion() {
  set_has_swversion();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.JointVersion.swVersion)
  return swversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointVersion::release_swversion() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.JointVersion.swVersion)
  if (!has_swversion()) {
    return NULL;
  }
  clear_has_swversion();
  return swversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointVersion::set_allocated_swversion(::std::string* swversion) {
  if (swversion != NULL) {
    set_has_swversion();
  } else {
    clear_has_swversion();
  }
  swversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), swversion);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.JointVersion.swVersion)
}

// -------------------------------------------------------------------

// OurRobotDevInfo

// required uint32 type = 1;
inline bool OurRobotDevInfo::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OurRobotDevInfo::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OurRobotDevInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OurRobotDevInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 OurRobotDevInfo::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.type)
  return type_;
}
inline void OurRobotDevInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.type)
}

// required string revision = 2;
inline bool OurRobotDevInfo::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OurRobotDevInfo::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OurRobotDevInfo::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OurRobotDevInfo::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_revision();
}
inline const ::std::string& OurRobotDevInfo::revision() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.revision)
  return revision_.GetNoArena();
}
inline void OurRobotDevInfo::set_revision(const ::std::string& value) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.revision)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_revision(::std::string&& value) {
  set_has_revision();
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.revision)
}
#endif
inline void OurRobotDevInfo::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.revision)
}
inline void OurRobotDevInfo::set_revision(const char* value, size_t size) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.revision)
}
inline ::std::string* OurRobotDevInfo::mutable_revision() {
  set_has_revision();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_revision() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.revision)
  if (!has_revision()) {
    return NULL;
  }
  clear_has_revision();
  return revision_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.revision)
}

// required string manuID = 3;
inline bool OurRobotDevInfo::has_manuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OurRobotDevInfo::set_has_manuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OurRobotDevInfo::clear_has_manuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OurRobotDevInfo::clear_manuid() {
  manuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_manuid();
}
inline const ::std::string& OurRobotDevInfo::manuid() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.manuID)
  return manuid_.GetNoArena();
}
inline void OurRobotDevInfo::set_manuid(const ::std::string& value) {
  set_has_manuid();
  manuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.manuID)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_manuid(::std::string&& value) {
  set_has_manuid();
  manuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.manuID)
}
#endif
inline void OurRobotDevInfo::set_manuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_manuid();
  manuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.manuID)
}
inline void OurRobotDevInfo::set_manuid(const char* value, size_t size) {
  set_has_manuid();
  manuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.manuID)
}
inline ::std::string* OurRobotDevInfo::mutable_manuid() {
  set_has_manuid();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.manuID)
  return manuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_manuid() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.manuID)
  if (!has_manuid()) {
    return NULL;
  }
  clear_has_manuid();
  return manuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_manuid(::std::string* manuid) {
  if (manuid != NULL) {
    set_has_manuid();
  } else {
    clear_has_manuid();
  }
  manuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manuid);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.manuID)
}

// required string jointType = 4;
inline bool OurRobotDevInfo::has_jointtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OurRobotDevInfo::set_has_jointtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OurRobotDevInfo::clear_has_jointtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OurRobotDevInfo::clear_jointtype() {
  jointtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jointtype();
}
inline const ::std::string& OurRobotDevInfo::jointtype() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.jointType)
  return jointtype_.GetNoArena();
}
inline void OurRobotDevInfo::set_jointtype(const ::std::string& value) {
  set_has_jointtype();
  jointtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.jointType)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_jointtype(::std::string&& value) {
  set_has_jointtype();
  jointtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.jointType)
}
#endif
inline void OurRobotDevInfo::set_jointtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jointtype();
  jointtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.jointType)
}
inline void OurRobotDevInfo::set_jointtype(const char* value, size_t size) {
  set_has_jointtype();
  jointtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.jointType)
}
inline ::std::string* OurRobotDevInfo::mutable_jointtype() {
  set_has_jointtype();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.jointType)
  return jointtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_jointtype() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.jointType)
  if (!has_jointtype()) {
    return NULL;
  }
  clear_has_jointtype();
  return jointtype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_jointtype(::std::string* jointtype) {
  if (jointtype != NULL) {
    set_has_jointtype();
  } else {
    clear_has_jointtype();
  }
  jointtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jointtype);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.jointType)
}

// repeated .aubo.robot.communication.JointVersion jointVer = 5;
inline int OurRobotDevInfo::jointver_size() const {
  return jointver_.size();
}
inline void OurRobotDevInfo::clear_jointver() {
  jointver_.Clear();
}
inline ::aubo::robot::communication::JointVersion* OurRobotDevInfo::mutable_jointver(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.jointVer)
  return jointver_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::JointVersion >*
OurRobotDevInfo::mutable_jointver() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.OurRobotDevInfo.jointVer)
  return &jointver_;
}
inline const ::aubo::robot::communication::JointVersion& OurRobotDevInfo::jointver(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.jointVer)
  return jointver_.Get(index);
}
inline ::aubo::robot::communication::JointVersion* OurRobotDevInfo::add_jointver() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.OurRobotDevInfo.jointVer)
  return jointver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::JointVersion >&
OurRobotDevInfo::jointver() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.OurRobotDevInfo.jointVer)
  return jointver_;
}

// required string desc = 6;
inline bool OurRobotDevInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OurRobotDevInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OurRobotDevInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OurRobotDevInfo::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& OurRobotDevInfo::desc() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.desc)
  return desc_.GetNoArena();
}
inline void OurRobotDevInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.desc)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.desc)
}
#endif
inline void OurRobotDevInfo::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.desc)
}
inline void OurRobotDevInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.desc)
}
inline ::std::string* OurRobotDevInfo::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_desc() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.desc)
  if (!has_desc()) {
    return NULL;
  }
  clear_has_desc();
  return desc_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.desc)
}

// repeated string jointProductID = 7;
inline int OurRobotDevInfo::jointproductid_size() const {
  return jointproductid_.size();
}
inline void OurRobotDevInfo::clear_jointproductid() {
  jointproductid_.Clear();
}
inline const ::std::string& OurRobotDevInfo::jointproductid(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  return jointproductid_.Get(index);
}
inline ::std::string* OurRobotDevInfo::mutable_jointproductid(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  return jointproductid_.Mutable(index);
}
inline void OurRobotDevInfo::set_jointproductid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  jointproductid_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_jointproductid(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  jointproductid_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OurRobotDevInfo::set_jointproductid(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  jointproductid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
inline void OurRobotDevInfo::set_jointproductid(int index, const char* value, size_t size) {
  jointproductid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
inline ::std::string* OurRobotDevInfo::add_jointproductid() {
  // @@protoc_insertion_point(field_add_mutable:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  return jointproductid_.Add();
}
inline void OurRobotDevInfo::add_jointproductid(const ::std::string& value) {
  jointproductid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
#if LANG_CXX11
inline void OurRobotDevInfo::add_jointproductid(::std::string&& value) {
  jointproductid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
#endif
inline void OurRobotDevInfo::add_jointproductid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  jointproductid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
inline void OurRobotDevInfo::add_jointproductid(const char* value, size_t size) {
  jointproductid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aubo.robot.communication.OurRobotDevInfo.jointProductID)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OurRobotDevInfo::jointproductid() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  return jointproductid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OurRobotDevInfo::mutable_jointproductid() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.OurRobotDevInfo.jointProductID)
  return &jointproductid_;
}

// required string slaveDevVersion = 8;
inline bool OurRobotDevInfo::has_slavedevversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OurRobotDevInfo::set_has_slavedevversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OurRobotDevInfo::clear_has_slavedevversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OurRobotDevInfo::clear_slavedevversion() {
  slavedevversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_slavedevversion();
}
inline const ::std::string& OurRobotDevInfo::slavedevversion() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
  return slavedevversion_.GetNoArena();
}
inline void OurRobotDevInfo::set_slavedevversion(const ::std::string& value) {
  set_has_slavedevversion();
  slavedevversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_slavedevversion(::std::string&& value) {
  set_has_slavedevversion();
  slavedevversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
}
#endif
inline void OurRobotDevInfo::set_slavedevversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_slavedevversion();
  slavedevversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
}
inline void OurRobotDevInfo::set_slavedevversion(const char* value, size_t size) {
  set_has_slavedevversion();
  slavedevversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
}
inline ::std::string* OurRobotDevInfo::mutable_slavedevversion() {
  set_has_slavedevversion();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
  return slavedevversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_slavedevversion() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
  if (!has_slavedevversion()) {
    return NULL;
  }
  clear_has_slavedevversion();
  return slavedevversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_slavedevversion(::std::string* slavedevversion) {
  if (slavedevversion != NULL) {
    set_has_slavedevversion();
  } else {
    clear_has_slavedevversion();
  }
  slavedevversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slavedevversion);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.slaveDevVersion)
}

// required string extendIoBoardVersion = 9;
inline bool OurRobotDevInfo::has_extendioboardversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OurRobotDevInfo::set_has_extendioboardversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OurRobotDevInfo::clear_has_extendioboardversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OurRobotDevInfo::clear_extendioboardversion() {
  extendioboardversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extendioboardversion();
}
inline const ::std::string& OurRobotDevInfo::extendioboardversion() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
  return extendioboardversion_.GetNoArena();
}
inline void OurRobotDevInfo::set_extendioboardversion(const ::std::string& value) {
  set_has_extendioboardversion();
  extendioboardversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
}
#if LANG_CXX11
inline void OurRobotDevInfo::set_extendioboardversion(::std::string&& value) {
  set_has_extendioboardversion();
  extendioboardversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
}
#endif
inline void OurRobotDevInfo::set_extendioboardversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extendioboardversion();
  extendioboardversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
}
inline void OurRobotDevInfo::set_extendioboardversion(const char* value, size_t size) {
  set_has_extendioboardversion();
  extendioboardversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
}
inline ::std::string* OurRobotDevInfo::mutable_extendioboardversion() {
  set_has_extendioboardversion();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
  return extendioboardversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OurRobotDevInfo::release_extendioboardversion() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
  if (!has_extendioboardversion()) {
    return NULL;
  }
  clear_has_extendioboardversion();
  return extendioboardversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OurRobotDevInfo::set_allocated_extendioboardversion(::std::string* extendioboardversion) {
  if (extendioboardversion != NULL) {
    set_has_extendioboardversion();
  } else {
    clear_has_extendioboardversion();
  }
  extendioboardversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extendioboardversion);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.OurRobotDevInfo.extendIoBoardVersion)
}

// -------------------------------------------------------------------

// RobotDiagnosis

// required uint32 armCanbusStatus = 1;
inline bool RobotDiagnosis::has_armcanbusstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotDiagnosis::set_has_armcanbusstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotDiagnosis::clear_has_armcanbusstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotDiagnosis::clear_armcanbusstatus() {
  armcanbusstatus_ = 0u;
  clear_has_armcanbusstatus();
}
inline ::google::protobuf::uint32 RobotDiagnosis::armcanbusstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.armCanbusStatus)
  return armcanbusstatus_;
}
inline void RobotDiagnosis::set_armcanbusstatus(::google::protobuf::uint32 value) {
  set_has_armcanbusstatus();
  armcanbusstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.armCanbusStatus)
}

// required float armPowerCurrent = 2;
inline bool RobotDiagnosis::has_armpowercurrent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotDiagnosis::set_has_armpowercurrent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotDiagnosis::clear_has_armpowercurrent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotDiagnosis::clear_armpowercurrent() {
  armpowercurrent_ = 0;
  clear_has_armpowercurrent();
}
inline float RobotDiagnosis::armpowercurrent() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.armPowerCurrent)
  return armpowercurrent_;
}
inline void RobotDiagnosis::set_armpowercurrent(float value) {
  set_has_armpowercurrent();
  armpowercurrent_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.armPowerCurrent)
}

// required float armPowerVoltage = 3;
inline bool RobotDiagnosis::has_armpowervoltage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotDiagnosis::set_has_armpowervoltage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotDiagnosis::clear_has_armpowervoltage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotDiagnosis::clear_armpowervoltage() {
  armpowervoltage_ = 0;
  clear_has_armpowervoltage();
}
inline float RobotDiagnosis::armpowervoltage() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.armPowerVoltage)
  return armpowervoltage_;
}
inline void RobotDiagnosis::set_armpowervoltage(float value) {
  set_has_armpowervoltage();
  armpowervoltage_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.armPowerVoltage)
}

// required bool armPowerStatus = 4;
inline bool RobotDiagnosis::has_armpowerstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotDiagnosis::set_has_armpowerstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotDiagnosis::clear_has_armpowerstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotDiagnosis::clear_armpowerstatus() {
  armpowerstatus_ = false;
  clear_has_armpowerstatus();
}
inline bool RobotDiagnosis::armpowerstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.armPowerStatus)
  return armpowerstatus_;
}
inline void RobotDiagnosis::set_armpowerstatus(bool value) {
  set_has_armpowerstatus();
  armpowerstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.armPowerStatus)
}

// required int32 contorllerTemp = 5;
inline bool RobotDiagnosis::has_contorllertemp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotDiagnosis::set_has_contorllertemp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotDiagnosis::clear_has_contorllertemp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotDiagnosis::clear_contorllertemp() {
  contorllertemp_ = 0;
  clear_has_contorllertemp();
}
inline ::google::protobuf::int32 RobotDiagnosis::contorllertemp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.contorllerTemp)
  return contorllertemp_;
}
inline void RobotDiagnosis::set_contorllertemp(::google::protobuf::int32 value) {
  set_has_contorllertemp();
  contorllertemp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.contorllerTemp)
}

// required uint32 contorllerHumidity = 6;
inline bool RobotDiagnosis::has_contorllerhumidity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotDiagnosis::set_has_contorllerhumidity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotDiagnosis::clear_has_contorllerhumidity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotDiagnosis::clear_contorllerhumidity() {
  contorllerhumidity_ = 0u;
  clear_has_contorllerhumidity();
}
inline ::google::protobuf::uint32 RobotDiagnosis::contorllerhumidity() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.contorllerHumidity)
  return contorllerhumidity_;
}
inline void RobotDiagnosis::set_contorllerhumidity(::google::protobuf::uint32 value) {
  set_has_contorllerhumidity();
  contorllerhumidity_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.contorllerHumidity)
}

// required bool remoteHalt = 7;
inline bool RobotDiagnosis::has_remotehalt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotDiagnosis::set_has_remotehalt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotDiagnosis::clear_has_remotehalt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotDiagnosis::clear_remotehalt() {
  remotehalt_ = false;
  clear_has_remotehalt();
}
inline bool RobotDiagnosis::remotehalt() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.remoteHalt)
  return remotehalt_;
}
inline void RobotDiagnosis::set_remotehalt(bool value) {
  set_has_remotehalt();
  remotehalt_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.remoteHalt)
}

// required bool softEmergency = 8;
inline bool RobotDiagnosis::has_softemergency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotDiagnosis::set_has_softemergency() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotDiagnosis::clear_has_softemergency() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotDiagnosis::clear_softemergency() {
  softemergency_ = false;
  clear_has_softemergency();
}
inline bool RobotDiagnosis::softemergency() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.softEmergency)
  return softemergency_;
}
inline void RobotDiagnosis::set_softemergency(bool value) {
  set_has_softemergency();
  softemergency_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.softEmergency)
}

// required bool remoteEmergency = 9;
inline bool RobotDiagnosis::has_remoteemergency() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RobotDiagnosis::set_has_remoteemergency() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RobotDiagnosis::clear_has_remoteemergency() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RobotDiagnosis::clear_remoteemergency() {
  remoteemergency_ = false;
  clear_has_remoteemergency();
}
inline bool RobotDiagnosis::remoteemergency() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.remoteEmergency)
  return remoteemergency_;
}
inline void RobotDiagnosis::set_remoteemergency(bool value) {
  set_has_remoteemergency();
  remoteemergency_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.remoteEmergency)
}

// required bool robotCollision = 10;
inline bool RobotDiagnosis::has_robotcollision() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RobotDiagnosis::set_has_robotcollision() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RobotDiagnosis::clear_has_robotcollision() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RobotDiagnosis::clear_robotcollision() {
  robotcollision_ = false;
  clear_has_robotcollision();
}
inline bool RobotDiagnosis::robotcollision() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotCollision)
  return robotcollision_;
}
inline void RobotDiagnosis::set_robotcollision(bool value) {
  set_has_robotcollision();
  robotcollision_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotCollision)
}

// required bool forceControlMode = 11;
inline bool RobotDiagnosis::has_forcecontrolmode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RobotDiagnosis::set_has_forcecontrolmode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RobotDiagnosis::clear_has_forcecontrolmode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RobotDiagnosis::clear_forcecontrolmode() {
  forcecontrolmode_ = false;
  clear_has_forcecontrolmode();
}
inline bool RobotDiagnosis::forcecontrolmode() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.forceControlMode)
  return forcecontrolmode_;
}
inline void RobotDiagnosis::set_forcecontrolmode(bool value) {
  set_has_forcecontrolmode();
  forcecontrolmode_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.forceControlMode)
}

// required bool brakeStuats = 12;
inline bool RobotDiagnosis::has_brakestuats() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RobotDiagnosis::set_has_brakestuats() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RobotDiagnosis::clear_has_brakestuats() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RobotDiagnosis::clear_brakestuats() {
  brakestuats_ = false;
  clear_has_brakestuats();
}
inline bool RobotDiagnosis::brakestuats() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.brakeStuats)
  return brakestuats_;
}
inline void RobotDiagnosis::set_brakestuats(bool value) {
  set_has_brakestuats();
  brakestuats_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.brakeStuats)
}

// required float robotEndSpeed = 13;
inline bool RobotDiagnosis::has_robotendspeed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RobotDiagnosis::set_has_robotendspeed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RobotDiagnosis::clear_has_robotendspeed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RobotDiagnosis::clear_robotendspeed() {
  robotendspeed_ = 0;
  clear_has_robotendspeed();
}
inline float RobotDiagnosis::robotendspeed() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotEndSpeed)
  return robotendspeed_;
}
inline void RobotDiagnosis::set_robotendspeed(float value) {
  set_has_robotendspeed();
  robotendspeed_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotEndSpeed)
}

// required int32 robotMaxAcc = 14;
inline bool RobotDiagnosis::has_robotmaxacc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RobotDiagnosis::set_has_robotmaxacc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RobotDiagnosis::clear_has_robotmaxacc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RobotDiagnosis::clear_robotmaxacc() {
  robotmaxacc_ = 0;
  clear_has_robotmaxacc();
}
inline ::google::protobuf::int32 RobotDiagnosis::robotmaxacc() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotMaxAcc)
  return robotmaxacc_;
}
inline void RobotDiagnosis::set_robotmaxacc(::google::protobuf::int32 value) {
  set_has_robotmaxacc();
  robotmaxacc_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotMaxAcc)
}

// required bool orpeStatus = 15;
inline bool RobotDiagnosis::has_orpestatus() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RobotDiagnosis::set_has_orpestatus() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RobotDiagnosis::clear_has_orpestatus() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RobotDiagnosis::clear_orpestatus() {
  orpestatus_ = false;
  clear_has_orpestatus();
}
inline bool RobotDiagnosis::orpestatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.orpeStatus)
  return orpestatus_;
}
inline void RobotDiagnosis::set_orpestatus(bool value) {
  set_has_orpestatus();
  orpestatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.orpeStatus)
}

// required bool enableReadPose = 16;
inline bool RobotDiagnosis::has_enablereadpose() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RobotDiagnosis::set_has_enablereadpose() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RobotDiagnosis::clear_has_enablereadpose() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RobotDiagnosis::clear_enablereadpose() {
  enablereadpose_ = false;
  clear_has_enablereadpose();
}
inline bool RobotDiagnosis::enablereadpose() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.enableReadPose)
  return enablereadpose_;
}
inline void RobotDiagnosis::set_enablereadpose(bool value) {
  set_has_enablereadpose();
  enablereadpose_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.enableReadPose)
}

// required bool robotMountingPoseChanged = 17;
inline bool RobotDiagnosis::has_robotmountingposechanged() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RobotDiagnosis::set_has_robotmountingposechanged() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RobotDiagnosis::clear_has_robotmountingposechanged() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RobotDiagnosis::clear_robotmountingposechanged() {
  robotmountingposechanged_ = false;
  clear_has_robotmountingposechanged();
}
inline bool RobotDiagnosis::robotmountingposechanged() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotMountingPoseChanged)
  return robotmountingposechanged_;
}
inline void RobotDiagnosis::set_robotmountingposechanged(bool value) {
  set_has_robotmountingposechanged();
  robotmountingposechanged_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotMountingPoseChanged)
}

// required bool encoderErrorStatus = 18;
inline bool RobotDiagnosis::has_encodererrorstatus() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RobotDiagnosis::set_has_encodererrorstatus() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RobotDiagnosis::clear_has_encodererrorstatus() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RobotDiagnosis::clear_encodererrorstatus() {
  encodererrorstatus_ = false;
  clear_has_encodererrorstatus();
}
inline bool RobotDiagnosis::encodererrorstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.encoderErrorStatus)
  return encodererrorstatus_;
}
inline void RobotDiagnosis::set_encodererrorstatus(bool value) {
  set_has_encodererrorstatus();
  encodererrorstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.encoderErrorStatus)
}

// required bool staticCollisionDetect = 19;
inline bool RobotDiagnosis::has_staticcollisiondetect() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RobotDiagnosis::set_has_staticcollisiondetect() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RobotDiagnosis::clear_has_staticcollisiondetect() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RobotDiagnosis::clear_staticcollisiondetect() {
  staticcollisiondetect_ = false;
  clear_has_staticcollisiondetect();
}
inline bool RobotDiagnosis::staticcollisiondetect() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.staticCollisionDetect)
  return staticcollisiondetect_;
}
inline void RobotDiagnosis::set_staticcollisiondetect(bool value) {
  set_has_staticcollisiondetect();
  staticcollisiondetect_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.staticCollisionDetect)
}

// required uint32 jointCollisionDetect = 20;
inline bool RobotDiagnosis::has_jointcollisiondetect() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RobotDiagnosis::set_has_jointcollisiondetect() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RobotDiagnosis::clear_has_jointcollisiondetect() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RobotDiagnosis::clear_jointcollisiondetect() {
  jointcollisiondetect_ = 0u;
  clear_has_jointcollisiondetect();
}
inline ::google::protobuf::uint32 RobotDiagnosis::jointcollisiondetect() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.jointCollisionDetect)
  return jointcollisiondetect_;
}
inline void RobotDiagnosis::set_jointcollisiondetect(::google::protobuf::uint32 value) {
  set_has_jointcollisiondetect();
  jointcollisiondetect_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.jointCollisionDetect)
}

// required bool encoderLinesError = 21;
inline bool RobotDiagnosis::has_encoderlineserror() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RobotDiagnosis::set_has_encoderlineserror() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RobotDiagnosis::clear_has_encoderlineserror() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RobotDiagnosis::clear_encoderlineserror() {
  encoderlineserror_ = false;
  clear_has_encoderlineserror();
}
inline bool RobotDiagnosis::encoderlineserror() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.encoderLinesError)
  return encoderlineserror_;
}
inline void RobotDiagnosis::set_encoderlineserror(bool value) {
  set_has_encoderlineserror();
  encoderlineserror_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.encoderLinesError)
}

// required bool jointErrorStatus = 22;
inline bool RobotDiagnosis::has_jointerrorstatus() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RobotDiagnosis::set_has_jointerrorstatus() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RobotDiagnosis::clear_has_jointerrorstatus() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RobotDiagnosis::clear_jointerrorstatus() {
  jointerrorstatus_ = false;
  clear_has_jointerrorstatus();
}
inline bool RobotDiagnosis::jointerrorstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.jointErrorStatus)
  return jointerrorstatus_;
}
inline void RobotDiagnosis::set_jointerrorstatus(bool value) {
  set_has_jointerrorstatus();
  jointerrorstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.jointErrorStatus)
}

// required bool singularityOverSpeedAlarm = 23;
inline bool RobotDiagnosis::has_singularityoverspeedalarm() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RobotDiagnosis::set_has_singularityoverspeedalarm() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RobotDiagnosis::clear_has_singularityoverspeedalarm() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RobotDiagnosis::clear_singularityoverspeedalarm() {
  singularityoverspeedalarm_ = false;
  clear_has_singularityoverspeedalarm();
}
inline bool RobotDiagnosis::singularityoverspeedalarm() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.singularityOverSpeedAlarm)
  return singularityoverspeedalarm_;
}
inline void RobotDiagnosis::set_singularityoverspeedalarm(bool value) {
  set_has_singularityoverspeedalarm();
  singularityoverspeedalarm_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.singularityOverSpeedAlarm)
}

// required bool robotCurrentAlarm = 24;
inline bool RobotDiagnosis::has_robotcurrentalarm() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RobotDiagnosis::set_has_robotcurrentalarm() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RobotDiagnosis::clear_has_robotcurrentalarm() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RobotDiagnosis::clear_robotcurrentalarm() {
  robotcurrentalarm_ = false;
  clear_has_robotcurrentalarm();
}
inline bool RobotDiagnosis::robotcurrentalarm() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotCurrentAlarm)
  return robotcurrentalarm_;
}
inline void RobotDiagnosis::set_robotcurrentalarm(bool value) {
  set_has_robotcurrentalarm();
  robotcurrentalarm_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotCurrentAlarm)
}

// required int32 toolIoError = 25;
inline bool RobotDiagnosis::has_toolioerror() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RobotDiagnosis::set_has_toolioerror() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RobotDiagnosis::clear_has_toolioerror() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RobotDiagnosis::clear_toolioerror() {
  toolioerror_ = 0;
  clear_has_toolioerror();
}
inline ::google::protobuf::int32 RobotDiagnosis::toolioerror() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.toolIoError)
  return toolioerror_;
}
inline void RobotDiagnosis::set_toolioerror(::google::protobuf::int32 value) {
  set_has_toolioerror();
  toolioerror_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.toolIoError)
}

// required bool robotMountingPoseWarning = 26;
inline bool RobotDiagnosis::has_robotmountingposewarning() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RobotDiagnosis::set_has_robotmountingposewarning() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RobotDiagnosis::clear_has_robotmountingposewarning() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RobotDiagnosis::clear_robotmountingposewarning() {
  robotmountingposewarning_ = false;
  clear_has_robotmountingposewarning();
}
inline bool RobotDiagnosis::robotmountingposewarning() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.robotMountingPoseWarning)
  return robotmountingposewarning_;
}
inline void RobotDiagnosis::set_robotmountingposewarning(bool value) {
  set_has_robotmountingposewarning();
  robotmountingposewarning_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.robotMountingPoseWarning)
}

// required uint32 macTargetPosBufferSize = 27;
inline bool RobotDiagnosis::has_mactargetposbuffersize() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RobotDiagnosis::set_has_mactargetposbuffersize() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RobotDiagnosis::clear_has_mactargetposbuffersize() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RobotDiagnosis::clear_mactargetposbuffersize() {
  mactargetposbuffersize_ = 0u;
  clear_has_mactargetposbuffersize();
}
inline ::google::protobuf::uint32 RobotDiagnosis::mactargetposbuffersize() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.macTargetPosBufferSize)
  return mactargetposbuffersize_;
}
inline void RobotDiagnosis::set_mactargetposbuffersize(::google::protobuf::uint32 value) {
  set_has_mactargetposbuffersize();
  mactargetposbuffersize_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.macTargetPosBufferSize)
}

// required uint32 macTargetPosDataSize = 28;
inline bool RobotDiagnosis::has_mactargetposdatasize() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RobotDiagnosis::set_has_mactargetposdatasize() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RobotDiagnosis::clear_has_mactargetposdatasize() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RobotDiagnosis::clear_mactargetposdatasize() {
  mactargetposdatasize_ = 0u;
  clear_has_mactargetposdatasize();
}
inline ::google::protobuf::uint32 RobotDiagnosis::mactargetposdatasize() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.macTargetPosDataSize)
  return mactargetposdatasize_;
}
inline void RobotDiagnosis::set_mactargetposdatasize(::google::protobuf::uint32 value) {
  set_has_mactargetposdatasize();
  mactargetposdatasize_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.macTargetPosDataSize)
}

// required uint32 macDataInterruptWarning = 29;
inline bool RobotDiagnosis::has_macdatainterruptwarning() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RobotDiagnosis::set_has_macdatainterruptwarning() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RobotDiagnosis::clear_has_macdatainterruptwarning() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RobotDiagnosis::clear_macdatainterruptwarning() {
  macdatainterruptwarning_ = 0u;
  clear_has_macdatainterruptwarning();
}
inline ::google::protobuf::uint32 RobotDiagnosis::macdatainterruptwarning() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.macDataInterruptWarning)
  return macdatainterruptwarning_;
}
inline void RobotDiagnosis::set_macdatainterruptwarning(::google::protobuf::uint32 value) {
  set_has_macdatainterruptwarning();
  macdatainterruptwarning_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.macDataInterruptWarning)
}

// optional uint32 controlBoardAbnormalStateFlag = 30;
inline bool RobotDiagnosis::has_controlboardabnormalstateflag() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void RobotDiagnosis::set_has_controlboardabnormalstateflag() {
  _has_bits_[0] |= 0x20000000u;
}
inline void RobotDiagnosis::clear_has_controlboardabnormalstateflag() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void RobotDiagnosis::clear_controlboardabnormalstateflag() {
  controlboardabnormalstateflag_ = 0u;
  clear_has_controlboardabnormalstateflag();
}
inline ::google::protobuf::uint32 RobotDiagnosis::controlboardabnormalstateflag() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotDiagnosis.controlBoardAbnormalStateFlag)
  return controlboardabnormalstateflag_;
}
inline void RobotDiagnosis::set_controlboardabnormalstateflag(::google::protobuf::uint32 value) {
  set_has_controlboardabnormalstateflag();
  controlboardabnormalstateflag_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotDiagnosis.controlBoardAbnormalStateFlag)
}

// -------------------------------------------------------------------

// RobotExtDiagnosis

// required uint32 robotState = 1;
inline bool RobotExtDiagnosis::has_robotstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotExtDiagnosis::set_has_robotstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotExtDiagnosis::clear_has_robotstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotExtDiagnosis::clear_robotstate() {
  robotstate_ = 0u;
  clear_has_robotstate();
}
inline ::google::protobuf::uint32 RobotExtDiagnosis::robotstate() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.robotState)
  return robotstate_;
}
inline void RobotExtDiagnosis::set_robotstate(::google::protobuf::uint32 value) {
  set_has_robotstate();
  robotstate_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.robotState)
}

// required uint32 robotStatus = 2;
inline bool RobotExtDiagnosis::has_robotstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotExtDiagnosis::set_has_robotstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotExtDiagnosis::clear_has_robotstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotExtDiagnosis::clear_robotstatus() {
  robotstatus_ = 0u;
  clear_has_robotstatus();
}
inline ::google::protobuf::uint32 RobotExtDiagnosis::robotstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.robotStatus)
  return robotstatus_;
}
inline void RobotExtDiagnosis::set_robotstatus(::google::protobuf::uint32 value) {
  set_has_robotstatus();
  robotstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.robotStatus)
}

// repeated float targetPos = 3;
inline int RobotExtDiagnosis::targetpos_size() const {
  return targetpos_.size();
}
inline void RobotExtDiagnosis::clear_targetpos() {
  targetpos_.Clear();
}
inline float RobotExtDiagnosis::targetpos(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.targetPos)
  return targetpos_.Get(index);
}
inline void RobotExtDiagnosis::set_targetpos(int index, float value) {
  targetpos_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.targetPos)
}
inline void RobotExtDiagnosis::add_targetpos(float value) {
  targetpos_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotExtDiagnosis.targetPos)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotExtDiagnosis::targetpos() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotExtDiagnosis.targetPos)
  return targetpos_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotExtDiagnosis::mutable_targetpos() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotExtDiagnosis.targetPos)
  return &targetpos_;
}

// repeated float theoreticalSpeed = 4;
inline int RobotExtDiagnosis::theoreticalspeed_size() const {
  return theoreticalspeed_.size();
}
inline void RobotExtDiagnosis::clear_theoreticalspeed() {
  theoreticalspeed_.Clear();
}
inline float RobotExtDiagnosis::theoreticalspeed(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.theoreticalSpeed)
  return theoreticalspeed_.Get(index);
}
inline void RobotExtDiagnosis::set_theoreticalspeed(int index, float value) {
  theoreticalspeed_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.theoreticalSpeed)
}
inline void RobotExtDiagnosis::add_theoreticalspeed(float value) {
  theoreticalspeed_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotExtDiagnosis.theoreticalSpeed)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotExtDiagnosis::theoreticalspeed() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalSpeed)
  return theoreticalspeed_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotExtDiagnosis::mutable_theoreticalspeed() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalSpeed)
  return &theoreticalspeed_;
}

// repeated float theoreticalAcc = 5;
inline int RobotExtDiagnosis::theoreticalacc_size() const {
  return theoreticalacc_.size();
}
inline void RobotExtDiagnosis::clear_theoreticalacc() {
  theoreticalacc_.Clear();
}
inline float RobotExtDiagnosis::theoreticalacc(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.theoreticalAcc)
  return theoreticalacc_.Get(index);
}
inline void RobotExtDiagnosis::set_theoreticalacc(int index, float value) {
  theoreticalacc_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.theoreticalAcc)
}
inline void RobotExtDiagnosis::add_theoreticalacc(float value) {
  theoreticalacc_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotExtDiagnosis.theoreticalAcc)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotExtDiagnosis::theoreticalacc() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalAcc)
  return theoreticalacc_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotExtDiagnosis::mutable_theoreticalacc() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalAcc)
  return &theoreticalacc_;
}

// repeated uint32 theoreticalCurrent = 6;
inline int RobotExtDiagnosis::theoreticalcurrent_size() const {
  return theoreticalcurrent_.size();
}
inline void RobotExtDiagnosis::clear_theoreticalcurrent() {
  theoreticalcurrent_.Clear();
}
inline ::google::protobuf::uint32 RobotExtDiagnosis::theoreticalcurrent(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotExtDiagnosis.theoreticalCurrent)
  return theoreticalcurrent_.Get(index);
}
inline void RobotExtDiagnosis::set_theoreticalcurrent(int index, ::google::protobuf::uint32 value) {
  theoreticalcurrent_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotExtDiagnosis.theoreticalCurrent)
}
inline void RobotExtDiagnosis::add_theoreticalcurrent(::google::protobuf::uint32 value) {
  theoreticalcurrent_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotExtDiagnosis.theoreticalCurrent)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RobotExtDiagnosis::theoreticalcurrent() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalCurrent)
  return theoreticalcurrent_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RobotExtDiagnosis::mutable_theoreticalcurrent() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotExtDiagnosis.theoreticalCurrent)
  return &theoreticalcurrent_;
}

// -------------------------------------------------------------------

// RobotSafetyConfig

// repeated uint32 robotReducedConfigJointSpeed = 1;
inline int RobotSafetyConfig::robotreducedconfigjointspeed_size() const {
  return robotreducedconfigjointspeed_.size();
}
inline void RobotSafetyConfig::clear_robotreducedconfigjointspeed() {
  robotreducedconfigjointspeed_.Clear();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotreducedconfigjointspeed(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigJointSpeed)
  return robotreducedconfigjointspeed_.Get(index);
}
inline void RobotSafetyConfig::set_robotreducedconfigjointspeed(int index, ::google::protobuf::uint32 value) {
  robotreducedconfigjointspeed_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigJointSpeed)
}
inline void RobotSafetyConfig::add_robotreducedconfigjointspeed(::google::protobuf::uint32 value) {
  robotreducedconfigjointspeed_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigJointSpeed)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RobotSafetyConfig::robotreducedconfigjointspeed() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigJointSpeed)
  return robotreducedconfigjointspeed_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RobotSafetyConfig::mutable_robotreducedconfigjointspeed() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigJointSpeed)
  return &robotreducedconfigjointspeed_;
}

// required uint32 robotReducedConfigTcpSpeed = 2;
inline bool RobotSafetyConfig::has_robotreducedconfigtcpspeed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotSafetyConfig::set_has_robotreducedconfigtcpspeed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotSafetyConfig::clear_has_robotreducedconfigtcpspeed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotSafetyConfig::clear_robotreducedconfigtcpspeed() {
  robotreducedconfigtcpspeed_ = 0u;
  clear_has_robotreducedconfigtcpspeed();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotreducedconfigtcpspeed() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigTcpSpeed)
  return robotreducedconfigtcpspeed_;
}
inline void RobotSafetyConfig::set_robotreducedconfigtcpspeed(::google::protobuf::uint32 value) {
  set_has_robotreducedconfigtcpspeed();
  robotreducedconfigtcpspeed_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigTcpSpeed)
}

// required uint32 robotReducedConfigTcpForce = 3;
inline bool RobotSafetyConfig::has_robotreducedconfigtcpforce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotSafetyConfig::set_has_robotreducedconfigtcpforce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotSafetyConfig::clear_has_robotreducedconfigtcpforce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotSafetyConfig::clear_robotreducedconfigtcpforce() {
  robotreducedconfigtcpforce_ = 0u;
  clear_has_robotreducedconfigtcpforce();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotreducedconfigtcpforce() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigTcpForce)
  return robotreducedconfigtcpforce_;
}
inline void RobotSafetyConfig::set_robotreducedconfigtcpforce(::google::protobuf::uint32 value) {
  set_has_robotreducedconfigtcpforce();
  robotreducedconfigtcpforce_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigTcpForce)
}

// required uint32 robotReducedConfigMomentum = 4;
inline bool RobotSafetyConfig::has_robotreducedconfigmomentum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotSafetyConfig::set_has_robotreducedconfigmomentum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotSafetyConfig::clear_has_robotreducedconfigmomentum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotSafetyConfig::clear_robotreducedconfigmomentum() {
  robotreducedconfigmomentum_ = 0u;
  clear_has_robotreducedconfigmomentum();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotreducedconfigmomentum() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigMomentum)
  return robotreducedconfigmomentum_;
}
inline void RobotSafetyConfig::set_robotreducedconfigmomentum(::google::protobuf::uint32 value) {
  set_has_robotreducedconfigmomentum();
  robotreducedconfigmomentum_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigMomentum)
}

// required uint32 robotReducedConfigPower = 5;
inline bool RobotSafetyConfig::has_robotreducedconfigpower() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotSafetyConfig::set_has_robotreducedconfigpower() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotSafetyConfig::clear_has_robotreducedconfigpower() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotSafetyConfig::clear_robotreducedconfigpower() {
  robotreducedconfigpower_ = 0u;
  clear_has_robotreducedconfigpower();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotreducedconfigpower() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigPower)
  return robotreducedconfigpower_;
}
inline void RobotSafetyConfig::set_robotreducedconfigpower(::google::protobuf::uint32 value) {
  set_has_robotreducedconfigpower();
  robotreducedconfigpower_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotReducedConfigPower)
}

// required uint32 robotSafeguradResetConfig = 6;
inline bool RobotSafetyConfig::has_robotsafeguradresetconfig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotSafetyConfig::set_has_robotsafeguradresetconfig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotSafetyConfig::clear_has_robotsafeguradresetconfig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotSafetyConfig::clear_robotsafeguradresetconfig() {
  robotsafeguradresetconfig_ = 0u;
  clear_has_robotsafeguradresetconfig();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotsafeguradresetconfig() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotSafeguradResetConfig)
  return robotsafeguradresetconfig_;
}
inline void RobotSafetyConfig::set_robotsafeguradresetconfig(::google::protobuf::uint32 value) {
  set_has_robotsafeguradresetconfig();
  robotsafeguradresetconfig_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotSafeguradResetConfig)
}

// required uint32 robotOperationalModeConfig = 7;
inline bool RobotSafetyConfig::has_robotoperationalmodeconfig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotSafetyConfig::set_has_robotoperationalmodeconfig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotSafetyConfig::clear_has_robotoperationalmodeconfig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotSafetyConfig::clear_robotoperationalmodeconfig() {
  robotoperationalmodeconfig_ = 0u;
  clear_has_robotoperationalmodeconfig();
}
inline ::google::protobuf::uint32 RobotSafetyConfig::robotoperationalmodeconfig() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotSafetyConfig.robotOperationalModeConfig)
  return robotoperationalmodeconfig_;
}
inline void RobotSafetyConfig::set_robotoperationalmodeconfig(::google::protobuf::uint32 value) {
  set_has_robotoperationalmodeconfig();
  robotoperationalmodeconfig_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotSafetyConfig.robotOperationalModeConfig)
}

// -------------------------------------------------------------------

// OrpeSafetyStatus

// required uint32 orpePause = 1;
inline bool OrpeSafetyStatus::has_orpepause() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrpeSafetyStatus::set_has_orpepause() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrpeSafetyStatus::clear_has_orpepause() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrpeSafetyStatus::clear_orpepause() {
  orpepause_ = 0u;
  clear_has_orpepause();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::orpepause() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.orpePause)
  return orpepause_;
}
inline void OrpeSafetyStatus::set_orpepause(::google::protobuf::uint32 value) {
  set_has_orpepause();
  orpepause_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.orpePause)
}

// required uint32 orpeStop = 2;
inline bool OrpeSafetyStatus::has_orpestop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrpeSafetyStatus::set_has_orpestop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrpeSafetyStatus::clear_has_orpestop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrpeSafetyStatus::clear_orpestop() {
  orpestop_ = 0u;
  clear_has_orpestop();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::orpestop() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.orpeStop)
  return orpestop_;
}
inline void OrpeSafetyStatus::set_orpestop(::google::protobuf::uint32 value) {
  set_has_orpestop();
  orpestop_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.orpeStop)
}

// repeated uint32 orpeError = 3;
inline int OrpeSafetyStatus::orpeerror_size() const {
  return orpeerror_.size();
}
inline void OrpeSafetyStatus::clear_orpeerror() {
  orpeerror_.Clear();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::orpeerror(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.orpeError)
  return orpeerror_.Get(index);
}
inline void OrpeSafetyStatus::set_orpeerror(int index, ::google::protobuf::uint32 value) {
  orpeerror_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.orpeError)
}
inline void OrpeSafetyStatus::add_orpeerror(::google::protobuf::uint32 value) {
  orpeerror_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.OrpeSafetyStatus.orpeError)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OrpeSafetyStatus::orpeerror() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.OrpeSafetyStatus.orpeError)
  return orpeerror_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OrpeSafetyStatus::mutable_orpeerror() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.OrpeSafetyStatus.orpeError)
  return &orpeerror_;
}

// required uint32 systemEmergencyStop = 4;
inline bool OrpeSafetyStatus::has_systememergencystop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrpeSafetyStatus::set_has_systememergencystop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrpeSafetyStatus::clear_has_systememergencystop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrpeSafetyStatus::clear_systememergencystop() {
  systememergencystop_ = 0u;
  clear_has_systememergencystop();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::systememergencystop() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.systemEmergencyStop)
  return systememergencystop_;
}
inline void OrpeSafetyStatus::set_systememergencystop(::google::protobuf::uint32 value) {
  set_has_systememergencystop();
  systememergencystop_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.systemEmergencyStop)
}

// required uint32 reducedModeError = 5;
inline bool OrpeSafetyStatus::has_reducedmodeerror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrpeSafetyStatus::set_has_reducedmodeerror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrpeSafetyStatus::clear_has_reducedmodeerror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrpeSafetyStatus::clear_reducedmodeerror() {
  reducedmodeerror_ = 0u;
  clear_has_reducedmodeerror();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::reducedmodeerror() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.reducedModeError)
  return reducedmodeerror_;
}
inline void OrpeSafetyStatus::set_reducedmodeerror(::google::protobuf::uint32 value) {
  set_has_reducedmodeerror();
  reducedmodeerror_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.reducedModeError)
}

// required uint32 safetyguardResetSucc = 6;
inline bool OrpeSafetyStatus::has_safetyguardresetsucc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrpeSafetyStatus::set_has_safetyguardresetsucc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrpeSafetyStatus::clear_has_safetyguardresetsucc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrpeSafetyStatus::clear_safetyguardresetsucc() {
  safetyguardresetsucc_ = 0u;
  clear_has_safetyguardresetsucc();
}
inline ::google::protobuf::uint32 OrpeSafetyStatus::safetyguardresetsucc() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OrpeSafetyStatus.safetyguardResetSucc)
  return safetyguardresetsucc_;
}
inline void OrpeSafetyStatus::set_safetyguardresetsucc(::google::protobuf::uint32 value) {
  set_has_safetyguardresetsucc();
  safetyguardresetsucc_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OrpeSafetyStatus.safetyguardResetSucc)
}

// -------------------------------------------------------------------

// protoSafeCommunicationParam

// required uint32 paramReserved = 1;
inline bool protoSafeCommunicationParam::has_paramreserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void protoSafeCommunicationParam::set_has_paramreserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void protoSafeCommunicationParam::clear_has_paramreserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void protoSafeCommunicationParam::clear_paramreserved() {
  paramreserved_ = 0u;
  clear_has_paramreserved();
}
inline ::google::protobuf::uint32 protoSafeCommunicationParam::paramreserved() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.protoSafeCommunicationParam.paramReserved)
  return paramreserved_;
}
inline void protoSafeCommunicationParam::set_paramreserved(::google::protobuf::uint32 value) {
  set_has_paramreserved();
  paramreserved_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.protoSafeCommunicationParam.paramReserved)
}

// repeated uint32 param = 2;
inline int protoSafeCommunicationParam::param_size() const {
  return param_.size();
}
inline void protoSafeCommunicationParam::clear_param() {
  param_.Clear();
}
inline ::google::protobuf::uint32 protoSafeCommunicationParam::param(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.protoSafeCommunicationParam.param)
  return param_.Get(index);
}
inline void protoSafeCommunicationParam::set_param(int index, ::google::protobuf::uint32 value) {
  param_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.protoSafeCommunicationParam.param)
}
inline void protoSafeCommunicationParam::add_param(::google::protobuf::uint32 value) {
  param_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.protoSafeCommunicationParam.param)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
protoSafeCommunicationParam::param() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.protoSafeCommunicationParam.param)
  return param_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
protoSafeCommunicationParam::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.protoSafeCommunicationParam.param)
  return &param_;
}

// -------------------------------------------------------------------

// OriginPose

// required uint32 OriginPoseState = 1;
inline bool OriginPose::has_originposestate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginPose::set_has_originposestate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginPose::clear_has_originposestate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OriginPose::clear_originposestate() {
  originposestate_ = 0u;
  clear_has_originposestate();
}
inline ::google::protobuf::uint32 OriginPose::originposestate() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OriginPose.OriginPoseState)
  return originposestate_;
}
inline void OriginPose::set_originposestate(::google::protobuf::uint32 value) {
  set_has_originposestate();
  originposestate_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OriginPose.OriginPoseState)
}

// repeated float OriginPose = 2;
inline int OriginPose::originpose_size() const {
  return originpose_.size();
}
inline void OriginPose::clear_originpose() {
  originpose_.Clear();
}
inline float OriginPose::originpose(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.OriginPose.OriginPose)
  return originpose_.Get(index);
}
inline void OriginPose::set_originpose(int index, float value) {
  originpose_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.OriginPose.OriginPose)
}
inline void OriginPose::add_originpose(float value) {
  originpose_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.OriginPose.OriginPose)
}
inline const ::google::protobuf::RepeatedField< float >&
OriginPose::originpose() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.OriginPose.OriginPose)
  return originpose_;
}
inline ::google::protobuf::RepeatedField< float >*
OriginPose::mutable_originpose() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.OriginPose.OriginPose)
  return &originpose_;
}

// -------------------------------------------------------------------

// RobotToolConfig

// required uint32 config = 1;
inline bool RobotToolConfig::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotToolConfig::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotToolConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotToolConfig::clear_config() {
  config_ = 0u;
  clear_has_config();
}
inline ::google::protobuf::uint32 RobotToolConfig::config() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolConfig.config)
  return config_;
}
inline void RobotToolConfig::set_config(::google::protobuf::uint32 value) {
  set_has_config();
  config_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolConfig.config)
}

// -------------------------------------------------------------------

// ProtoRobotCommonResponse

// required int32 errorCode = 1;
inline bool ProtoRobotCommonResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRobotCommonResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRobotCommonResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRobotCommonResponse::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 ProtoRobotCommonResponse::errorcode() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotCommonResponse.errorCode)
  return errorcode_;
}
inline void ProtoRobotCommonResponse::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotCommonResponse.errorCode)
}

// required string errorMsg = 2;
inline bool ProtoRobotCommonResponse::has_errormsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRobotCommonResponse::set_has_errormsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRobotCommonResponse::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRobotCommonResponse::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormsg();
}
inline const ::std::string& ProtoRobotCommonResponse::errormsg() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
  return errormsg_.GetNoArena();
}
inline void ProtoRobotCommonResponse::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
}
#if LANG_CXX11
inline void ProtoRobotCommonResponse::set_errormsg(::std::string&& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
}
#endif
inline void ProtoRobotCommonResponse::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
}
inline void ProtoRobotCommonResponse::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
}
inline ::std::string* ProtoRobotCommonResponse::mutable_errormsg() {
  set_has_errormsg();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoRobotCommonResponse::release_errormsg() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
  if (!has_errormsg()) {
    return NULL;
  }
  clear_has_errormsg();
  return errormsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoRobotCommonResponse::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoRobotCommonResponse.errorMsg)
}

// -------------------------------------------------------------------

// ProtoRequestLogin

// required string userName = 1;
inline bool ProtoRequestLogin::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRequestLogin::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRequestLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRequestLogin::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ProtoRequestLogin::username() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRequestLogin.userName)
  return username_.GetNoArena();
}
inline void ProtoRequestLogin::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRequestLogin.userName)
}
#if LANG_CXX11
inline void ProtoRequestLogin::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoRequestLogin.userName)
}
#endif
inline void ProtoRequestLogin::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoRequestLogin.userName)
}
inline void ProtoRequestLogin::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoRequestLogin.userName)
}
inline ::std::string* ProtoRequestLogin::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoRequestLogin.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoRequestLogin::release_username() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoRequestLogin.userName)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoRequestLogin::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoRequestLogin.userName)
}

// required string passwd = 2;
inline bool ProtoRequestLogin::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRequestLogin::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRequestLogin::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRequestLogin::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_passwd();
}
inline const ::std::string& ProtoRequestLogin::passwd() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRequestLogin.passwd)
  return passwd_.GetNoArena();
}
inline void ProtoRequestLogin::set_passwd(const ::std::string& value) {
  set_has_passwd();
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRequestLogin.passwd)
}
#if LANG_CXX11
inline void ProtoRequestLogin::set_passwd(::std::string&& value) {
  set_has_passwd();
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoRequestLogin.passwd)
}
#endif
inline void ProtoRequestLogin::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_passwd();
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoRequestLogin.passwd)
}
inline void ProtoRequestLogin::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoRequestLogin.passwd)
}
inline ::std::string* ProtoRequestLogin::mutable_passwd() {
  set_has_passwd();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoRequestLogin.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoRequestLogin::release_passwd() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoRequestLogin.passwd)
  if (!has_passwd()) {
    return NULL;
  }
  clear_has_passwd();
  return passwd_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoRequestLogin::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    set_has_passwd();
  } else {
    clear_has_passwd();
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoRequestLogin.passwd)
}

// -------------------------------------------------------------------

// ProtoRobotDiagnosisIODesc

// required uint32 addr = 1;
inline bool ProtoRobotDiagnosisIODesc::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRobotDiagnosisIODesc::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRobotDiagnosisIODesc::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRobotDiagnosisIODesc::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ProtoRobotDiagnosisIODesc::addr() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotDiagnosisIODesc.addr)
  return addr_;
}
inline void ProtoRobotDiagnosisIODesc::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotDiagnosisIODesc.addr)
}

// required uint32 type = 2;
inline bool ProtoRobotDiagnosisIODesc::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRobotDiagnosisIODesc::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRobotDiagnosisIODesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRobotDiagnosisIODesc::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ProtoRobotDiagnosisIODesc::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotDiagnosisIODesc.type)
  return type_;
}
inline void ProtoRobotDiagnosisIODesc::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotDiagnosisIODesc.type)
}

// required uint32 value = 3;
inline bool ProtoRobotDiagnosisIODesc::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoRobotDiagnosisIODesc::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoRobotDiagnosisIODesc::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoRobotDiagnosisIODesc::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ProtoRobotDiagnosisIODesc::value() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotDiagnosisIODesc.value)
  return value_;
}
inline void ProtoRobotDiagnosisIODesc::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotDiagnosisIODesc.value)
}

// -------------------------------------------------------------------

// ProtoRobotAnalogIODesc

// required uint32 addr = 1;
inline bool ProtoRobotAnalogIODesc::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRobotAnalogIODesc::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRobotAnalogIODesc::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRobotAnalogIODesc::clear_addr() {
  addr_ = 0u;
  clear_has_addr();
}
inline ::google::protobuf::uint32 ProtoRobotAnalogIODesc::addr() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotAnalogIODesc.addr)
  return addr_;
}
inline void ProtoRobotAnalogIODesc::set_addr(::google::protobuf::uint32 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotAnalogIODesc.addr)
}

// required uint32 type = 2;
inline bool ProtoRobotAnalogIODesc::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRobotAnalogIODesc::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRobotAnalogIODesc::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRobotAnalogIODesc::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ProtoRobotAnalogIODesc::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotAnalogIODesc.type)
  return type_;
}
inline void ProtoRobotAnalogIODesc::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotAnalogIODesc.type)
}

// required float value = 3;
inline bool ProtoRobotAnalogIODesc::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoRobotAnalogIODesc::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoRobotAnalogIODesc::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoRobotAnalogIODesc::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float ProtoRobotAnalogIODesc::value() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoRobotAnalogIODesc.value)
  return value_;
}
inline void ProtoRobotAnalogIODesc::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoRobotAnalogIODesc.value)
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotDiagnosisIOData

// required int32 type = 1;
inline bool ProtoCommunicationRobotDiagnosisIOData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotDiagnosisIOData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotDiagnosisIOData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotDiagnosisIOData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotDiagnosisIOData::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.type)
  return type_;
}
inline void ProtoCommunicationRobotDiagnosisIOData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.type)
}

// repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
inline int ProtoCommunicationRobotDiagnosisIOData::errorinfo_size() const {
  return errorinfo_.size();
}
inline void ProtoCommunicationRobotDiagnosisIOData::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotDiagnosisIOData::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
ProtoCommunicationRobotDiagnosisIOData::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.errorInfo)
  return &errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationRobotDiagnosisIOData::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.errorInfo)
  return errorinfo_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotDiagnosisIOData::add_errorinfo() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
ProtoCommunicationRobotDiagnosisIOData::errorinfo() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.errorInfo)
  return errorinfo_;
}

// repeated .aubo.robot.communication.ProtoRobotDiagnosisIODesc ioDesc = 3;
inline int ProtoCommunicationRobotDiagnosisIOData::iodesc_size() const {
  return iodesc_.size();
}
inline void ProtoCommunicationRobotDiagnosisIOData::clear_iodesc() {
  iodesc_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotDiagnosisIODesc* ProtoCommunicationRobotDiagnosisIOData::mutable_iodesc(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.ioDesc)
  return iodesc_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotDiagnosisIODesc >*
ProtoCommunicationRobotDiagnosisIOData::mutable_iodesc() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.ioDesc)
  return &iodesc_;
}
inline const ::aubo::robot::communication::ProtoRobotDiagnosisIODesc& ProtoCommunicationRobotDiagnosisIOData::iodesc(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.ioDesc)
  return iodesc_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotDiagnosisIODesc* ProtoCommunicationRobotDiagnosisIOData::add_iodesc() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.ioDesc)
  return iodesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotDiagnosisIODesc >&
ProtoCommunicationRobotDiagnosisIOData::iodesc() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisIOData.ioDesc)
  return iodesc_;
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotAnalogIOData

// required int32 type = 3;
inline bool ProtoCommunicationRobotAnalogIOData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotAnalogIOData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotAnalogIOData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotAnalogIOData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotAnalogIOData::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.type)
  return type_;
}
inline void ProtoCommunicationRobotAnalogIOData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.type)
}

// repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
inline int ProtoCommunicationRobotAnalogIOData::errorinfo_size() const {
  return errorinfo_.size();
}
inline void ProtoCommunicationRobotAnalogIOData::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotAnalogIOData::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
ProtoCommunicationRobotAnalogIOData::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.errorInfo)
  return &errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationRobotAnalogIOData::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.errorInfo)
  return errorinfo_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotAnalogIOData::add_errorinfo() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
ProtoCommunicationRobotAnalogIOData::errorinfo() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.errorInfo)
  return errorinfo_;
}

// repeated .aubo.robot.communication.ProtoRobotAnalogIODesc ioDesc = 1;
inline int ProtoCommunicationRobotAnalogIOData::iodesc_size() const {
  return iodesc_.size();
}
inline void ProtoCommunicationRobotAnalogIOData::clear_iodesc() {
  iodesc_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotAnalogIODesc* ProtoCommunicationRobotAnalogIOData::mutable_iodesc(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.ioDesc)
  return iodesc_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotAnalogIODesc >*
ProtoCommunicationRobotAnalogIOData::mutable_iodesc() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.ioDesc)
  return &iodesc_;
}
inline const ::aubo::robot::communication::ProtoRobotAnalogIODesc& ProtoCommunicationRobotAnalogIOData::iodesc(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.ioDesc)
  return iodesc_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotAnalogIODesc* ProtoCommunicationRobotAnalogIOData::add_iodesc() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.ioDesc)
  return iodesc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotAnalogIODesc >&
ProtoCommunicationRobotAnalogIOData::iodesc() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotAnalogIOData.ioDesc)
  return iodesc_;
}

// -------------------------------------------------------------------

// ProtoCommunicationGeneralData

// repeated int32 property1 = 1;
inline int ProtoCommunicationGeneralData::property1_size() const {
  return property1_.size();
}
inline void ProtoCommunicationGeneralData::clear_property1() {
  property1_.Clear();
}
inline ::google::protobuf::int32 ProtoCommunicationGeneralData::property1(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationGeneralData.property1)
  return property1_.Get(index);
}
inline void ProtoCommunicationGeneralData::set_property1(int index, ::google::protobuf::int32 value) {
  property1_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationGeneralData.property1)
}
inline void ProtoCommunicationGeneralData::add_property1(::google::protobuf::int32 value) {
  property1_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationGeneralData.property1)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoCommunicationGeneralData::property1() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationGeneralData.property1)
  return property1_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoCommunicationGeneralData::mutable_property1() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationGeneralData.property1)
  return &property1_;
}

// repeated bool property2 = 2;
inline int ProtoCommunicationGeneralData::property2_size() const {
  return property2_.size();
}
inline void ProtoCommunicationGeneralData::clear_property2() {
  property2_.Clear();
}
inline bool ProtoCommunicationGeneralData::property2(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationGeneralData.property2)
  return property2_.Get(index);
}
inline void ProtoCommunicationGeneralData::set_property2(int index, bool value) {
  property2_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationGeneralData.property2)
}
inline void ProtoCommunicationGeneralData::add_property2(bool value) {
  property2_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationGeneralData.property2)
}
inline const ::google::protobuf::RepeatedField< bool >&
ProtoCommunicationGeneralData::property2() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationGeneralData.property2)
  return property2_;
}
inline ::google::protobuf::RepeatedField< bool >*
ProtoCommunicationGeneralData::mutable_property2() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationGeneralData.property2)
  return &property2_;
}

// repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
inline int ProtoCommunicationGeneralData::errorinfo_size() const {
  return errorinfo_.size();
}
inline void ProtoCommunicationGeneralData::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationGeneralData::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationGeneralData.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
ProtoCommunicationGeneralData::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationGeneralData.errorInfo)
  return &errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationGeneralData::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationGeneralData.errorInfo)
  return errorinfo_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationGeneralData::add_errorinfo() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationGeneralData.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
ProtoCommunicationGeneralData::errorinfo() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationGeneralData.errorInfo)
  return errorinfo_;
}

// required int32 type = 4;
inline bool ProtoCommunicationGeneralData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationGeneralData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationGeneralData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationGeneralData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ProtoCommunicationGeneralData::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationGeneralData.type)
  return type_;
}
inline void ProtoCommunicationGeneralData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationGeneralData.type)
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotDiagnosisInfo

// required int32 num = 1;
inline bool ProtoCommunicationRobotDiagnosisInfo::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotDiagnosisInfo::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotDiagnosisInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotDiagnosisInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotDiagnosisInfo::num() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.num)
  return num_;
}
inline void ProtoCommunicationRobotDiagnosisInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.num)
}

// repeated .aubo.robot.communication.RobotDiagnosis robotDiagnosis = 2;
inline int ProtoCommunicationRobotDiagnosisInfo::robotdiagnosis_size() const {
  return robotdiagnosis_.size();
}
inline void ProtoCommunicationRobotDiagnosisInfo::clear_robotdiagnosis() {
  robotdiagnosis_.Clear();
}
inline ::aubo::robot::communication::RobotDiagnosis* ProtoCommunicationRobotDiagnosisInfo::mutable_robotdiagnosis(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.robotDiagnosis)
  return robotdiagnosis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::RobotDiagnosis >*
ProtoCommunicationRobotDiagnosisInfo::mutable_robotdiagnosis() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.robotDiagnosis)
  return &robotdiagnosis_;
}
inline const ::aubo::robot::communication::RobotDiagnosis& ProtoCommunicationRobotDiagnosisInfo::robotdiagnosis(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.robotDiagnosis)
  return robotdiagnosis_.Get(index);
}
inline ::aubo::robot::communication::RobotDiagnosis* ProtoCommunicationRobotDiagnosisInfo::add_robotdiagnosis() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.robotDiagnosis)
  return robotdiagnosis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::RobotDiagnosis >&
ProtoCommunicationRobotDiagnosisInfo::robotdiagnosis() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.robotDiagnosis)
  return robotdiagnosis_;
}

// repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
inline int ProtoCommunicationRobotDiagnosisInfo::errorinfo_size() const {
  return errorinfo_.size();
}
inline void ProtoCommunicationRobotDiagnosisInfo::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotDiagnosisInfo::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
ProtoCommunicationRobotDiagnosisInfo::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.errorInfo)
  return &errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationRobotDiagnosisInfo::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.errorInfo)
  return errorinfo_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationRobotDiagnosisInfo::add_errorinfo() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
ProtoCommunicationRobotDiagnosisInfo::errorinfo() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationRobotDiagnosisInfo.errorInfo)
  return errorinfo_;
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotEvent

// required int32 eventType = 1;
inline bool ProtoCommunicationRobotEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationRobotEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationRobotEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationRobotEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotEvent::eventtype() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotEvent.eventType)
  return eventtype_;
}
inline void ProtoCommunicationRobotEvent::set_eventtype(::google::protobuf::int32 value) {
  set_has_eventtype();
  eventtype_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotEvent.eventType)
}

// required int32 eventCode = 2;
inline bool ProtoCommunicationRobotEvent::has_eventcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoCommunicationRobotEvent::set_has_eventcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoCommunicationRobotEvent::clear_has_eventcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoCommunicationRobotEvent::clear_eventcode() {
  eventcode_ = 0;
  clear_has_eventcode();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotEvent::eventcode() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotEvent.eventCode)
  return eventcode_;
}
inline void ProtoCommunicationRobotEvent::set_eventcode(::google::protobuf::int32 value) {
  set_has_eventcode();
  eventcode_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotEvent.eventCode)
}

// required bytes eventContent = 3;
inline bool ProtoCommunicationRobotEvent::has_eventcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotEvent::set_has_eventcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotEvent::clear_has_eventcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotEvent::clear_eventcontent() {
  eventcontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_eventcontent();
}
inline const ::std::string& ProtoCommunicationRobotEvent::eventcontent() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
  return eventcontent_.GetNoArena();
}
inline void ProtoCommunicationRobotEvent::set_eventcontent(const ::std::string& value) {
  set_has_eventcontent();
  eventcontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
}
#if LANG_CXX11
inline void ProtoCommunicationRobotEvent::set_eventcontent(::std::string&& value) {
  set_has_eventcontent();
  eventcontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
}
#endif
inline void ProtoCommunicationRobotEvent::set_eventcontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_eventcontent();
  eventcontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
}
inline void ProtoCommunicationRobotEvent::set_eventcontent(const void* value, size_t size) {
  set_has_eventcontent();
  eventcontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
}
inline ::std::string* ProtoCommunicationRobotEvent::mutable_eventcontent() {
  set_has_eventcontent();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
  return eventcontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoCommunicationRobotEvent::release_eventcontent() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
  if (!has_eventcontent()) {
    return NULL;
  }
  clear_has_eventcontent();
  return eventcontent_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoCommunicationRobotEvent::set_allocated_eventcontent(::std::string* eventcontent) {
  if (eventcontent != NULL) {
    set_has_eventcontent();
  } else {
    clear_has_eventcontent();
  }
  eventcontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), eventcontent);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationRobotEvent.eventContent)
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotStartupProfile

// required .aubo.robot.communication.RobotTcpParam tcpParam = 1;
inline bool ProtoCommunicationRobotStartupProfile::has_tcpparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotStartupProfile::set_has_tcpparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_has_tcpparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_tcpparam() {
  if (tcpparam_ != NULL) tcpparam_->Clear();
  clear_has_tcpparam();
}
inline const ::aubo::robot::communication::RobotTcpParam& ProtoCommunicationRobotStartupProfile::_internal_tcpparam() const {
  return *tcpparam_;
}
inline const ::aubo::robot::communication::RobotTcpParam& ProtoCommunicationRobotStartupProfile::tcpparam() const {
  const ::aubo::robot::communication::RobotTcpParam* p = tcpparam_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.tcpParam)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::RobotTcpParam*>(
      &::aubo::robot::communication::_RobotTcpParam_default_instance_);
}
inline ::aubo::robot::communication::RobotTcpParam* ProtoCommunicationRobotStartupProfile::release_tcpparam() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.tcpParam)
  clear_has_tcpparam();
  ::aubo::robot::communication::RobotTcpParam* temp = tcpparam_;
  tcpparam_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::RobotTcpParam* ProtoCommunicationRobotStartupProfile::mutable_tcpparam() {
  set_has_tcpparam();
  if (tcpparam_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::RobotTcpParam>(GetArenaNoVirtual());
    tcpparam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.tcpParam)
  return tcpparam_;
}
inline void ProtoCommunicationRobotStartupProfile::set_allocated_tcpparam(::aubo::robot::communication::RobotTcpParam* tcpparam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tcpparam_;
  }
  if (tcpparam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tcpparam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tcpparam, submessage_arena);
    }
    set_has_tcpparam();
  } else {
    clear_has_tcpparam();
  }
  tcpparam_ = tcpparam;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.tcpParam)
}

// required bool readPose = 2;
inline bool ProtoCommunicationRobotStartupProfile::has_readpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationRobotStartupProfile::set_has_readpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_has_readpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_readpose() {
  readpose_ = false;
  clear_has_readpose();
}
inline bool ProtoCommunicationRobotStartupProfile::readpose() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.readPose)
  return readpose_;
}
inline void ProtoCommunicationRobotStartupProfile::set_readpose(bool value) {
  set_has_readpose();
  readpose_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.readPose)
}

// required bool staticCollisionDetect = 3;
inline bool ProtoCommunicationRobotStartupProfile::has_staticcollisiondetect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoCommunicationRobotStartupProfile::set_has_staticcollisiondetect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_has_staticcollisiondetect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_staticcollisiondetect() {
  staticcollisiondetect_ = false;
  clear_has_staticcollisiondetect();
}
inline bool ProtoCommunicationRobotStartupProfile::staticcollisiondetect() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.staticCollisionDetect)
  return staticcollisiondetect_;
}
inline void ProtoCommunicationRobotStartupProfile::set_staticcollisiondetect(bool value) {
  set_has_staticcollisiondetect();
  staticcollisiondetect_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.staticCollisionDetect)
}

// required int32 collisionClass = 4;
inline bool ProtoCommunicationRobotStartupProfile::has_collisionclass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoCommunicationRobotStartupProfile::set_has_collisionclass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_has_collisionclass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_collisionclass() {
  collisionclass_ = 0;
  clear_has_collisionclass();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotStartupProfile::collisionclass() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.collisionClass)
  return collisionclass_;
}
inline void ProtoCommunicationRobotStartupProfile::set_collisionclass(::google::protobuf::int32 value) {
  set_has_collisionclass();
  collisionclass_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.collisionClass)
}

// required int32 maxAcc = 5;
inline bool ProtoCommunicationRobotStartupProfile::has_maxacc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoCommunicationRobotStartupProfile::set_has_maxacc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_has_maxacc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoCommunicationRobotStartupProfile::clear_maxacc() {
  maxacc_ = 0;
  clear_has_maxacc();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotStartupProfile::maxacc() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.maxAcc)
  return maxacc_;
}
inline void ProtoCommunicationRobotStartupProfile::set_maxacc(::google::protobuf::int32 value) {
  set_has_maxacc();
  maxacc_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotStartupProfile.maxAcc)
}

// -------------------------------------------------------------------

// ProtoCommunicationOfflineExcitTraj

// required string trackFile = 1;
inline bool ProtoCommunicationOfflineExcitTraj::has_trackfile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationOfflineExcitTraj::set_has_trackfile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_has_trackfile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_trackfile() {
  trackfile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trackfile();
}
inline const ::std::string& ProtoCommunicationOfflineExcitTraj::trackfile() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
  return trackfile_.GetNoArena();
}
inline void ProtoCommunicationOfflineExcitTraj::set_trackfile(const ::std::string& value) {
  set_has_trackfile();
  trackfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
}
#if LANG_CXX11
inline void ProtoCommunicationOfflineExcitTraj::set_trackfile(::std::string&& value) {
  set_has_trackfile();
  trackfile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
}
#endif
inline void ProtoCommunicationOfflineExcitTraj::set_trackfile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_trackfile();
  trackfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
}
inline void ProtoCommunicationOfflineExcitTraj::set_trackfile(const char* value, size_t size) {
  set_has_trackfile();
  trackfile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
}
inline ::std::string* ProtoCommunicationOfflineExcitTraj::mutable_trackfile() {
  set_has_trackfile();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
  return trackfile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoCommunicationOfflineExcitTraj::release_trackfile() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
  if (!has_trackfile()) {
    return NULL;
  }
  clear_has_trackfile();
  return trackfile_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoCommunicationOfflineExcitTraj::set_allocated_trackfile(::std::string* trackfile) {
  if (trackfile != NULL) {
    set_has_trackfile();
  } else {
    clear_has_trackfile();
  }
  trackfile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trackfile);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.trackFile)
}

// required int32 type = 2;
inline bool ProtoCommunicationOfflineExcitTraj::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationOfflineExcitTraj::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ProtoCommunicationOfflineExcitTraj::type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.type)
  return type_;
}
inline void ProtoCommunicationOfflineExcitTraj::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.type)
}

// required int32 subtype = 3;
inline bool ProtoCommunicationOfflineExcitTraj::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoCommunicationOfflineExcitTraj::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoCommunicationOfflineExcitTraj::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::google::protobuf::int32 ProtoCommunicationOfflineExcitTraj::subtype() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.subtype)
  return subtype_;
}
inline void ProtoCommunicationOfflineExcitTraj::set_subtype(::google::protobuf::int32 value) {
  set_has_subtype();
  subtype_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationOfflineExcitTraj.subtype)
}

// -------------------------------------------------------------------

// ProtoCommunicationDynIdentifyResults

// required int32 temp = 1;
inline bool ProtoCommunicationDynIdentifyResults::has_temp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationDynIdentifyResults::set_has_temp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationDynIdentifyResults::clear_has_temp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationDynIdentifyResults::clear_temp() {
  temp_ = 0;
  clear_has_temp();
}
inline ::google::protobuf::int32 ProtoCommunicationDynIdentifyResults::temp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.temp)
  return temp_;
}
inline void ProtoCommunicationDynIdentifyResults::set_temp(::google::protobuf::int32 value) {
  set_has_temp();
  temp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.temp)
}

// repeated int32 param = 2;
inline int ProtoCommunicationDynIdentifyResults::param_size() const {
  return param_.size();
}
inline void ProtoCommunicationDynIdentifyResults::clear_param() {
  param_.Clear();
}
inline ::google::protobuf::int32 ProtoCommunicationDynIdentifyResults::param(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.param)
  return param_.Get(index);
}
inline void ProtoCommunicationDynIdentifyResults::set_param(int index, ::google::protobuf::int32 value) {
  param_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.param)
}
inline void ProtoCommunicationDynIdentifyResults::add_param(::google::protobuf::int32 value) {
  param_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.param)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoCommunicationDynIdentifyResults::param() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.param)
  return param_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoCommunicationDynIdentifyResults::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.param)
  return &param_;
}

// repeated .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
inline int ProtoCommunicationDynIdentifyResults::errorinfo_size() const {
  return errorinfo_.size();
}
inline void ProtoCommunicationDynIdentifyResults::clear_errorinfo() {
  errorinfo_.Clear();
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationDynIdentifyResults::mutable_errorinfo(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.errorInfo)
  return errorinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >*
ProtoCommunicationDynIdentifyResults::mutable_errorinfo() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.errorInfo)
  return &errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationDynIdentifyResults::errorinfo(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.errorInfo)
  return errorinfo_.Get(index);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationDynIdentifyResults::add_errorinfo() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.errorInfo)
  return errorinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoRobotCommonResponse >&
ProtoCommunicationDynIdentifyResults::errorinfo() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationDynIdentifyResults.errorInfo)
  return errorinfo_;
}

// -------------------------------------------------------------------

// InterfaceBoardError

// required bytes boardError = 1;
inline bool InterfaceBoardError::has_boarderror() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterfaceBoardError::set_has_boarderror() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterfaceBoardError::clear_has_boarderror() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterfaceBoardError::clear_boarderror() {
  boarderror_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_boarderror();
}
inline const ::std::string& InterfaceBoardError::boarderror() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.InterfaceBoardError.boardError)
  return boarderror_.GetNoArena();
}
inline void InterfaceBoardError::set_boarderror(const ::std::string& value) {
  set_has_boarderror();
  boarderror_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.InterfaceBoardError.boardError)
}
#if LANG_CXX11
inline void InterfaceBoardError::set_boarderror(::std::string&& value) {
  set_has_boarderror();
  boarderror_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.InterfaceBoardError.boardError)
}
#endif
inline void InterfaceBoardError::set_boarderror(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_boarderror();
  boarderror_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.InterfaceBoardError.boardError)
}
inline void InterfaceBoardError::set_boarderror(const void* value, size_t size) {
  set_has_boarderror();
  boarderror_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.InterfaceBoardError.boardError)
}
inline ::std::string* InterfaceBoardError::mutable_boarderror() {
  set_has_boarderror();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.InterfaceBoardError.boardError)
  return boarderror_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InterfaceBoardError::release_boarderror() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.InterfaceBoardError.boardError)
  if (!has_boarderror()) {
    return NULL;
  }
  clear_has_boarderror();
  return boarderror_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterfaceBoardError::set_allocated_boarderror(::std::string* boarderror) {
  if (boarderror != NULL) {
    set_has_boarderror();
  } else {
    clear_has_boarderror();
  }
  boarderror_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), boarderror);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.InterfaceBoardError.boardError)
}

// -------------------------------------------------------------------

// ModbusCfg

// required string uuid = 1;
inline bool ModbusCfg::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModbusCfg::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModbusCfg::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModbusCfg::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& ModbusCfg::uuid() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.uuid)
  return uuid_.GetNoArena();
}
inline void ModbusCfg::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.uuid)
}
#if LANG_CXX11
inline void ModbusCfg::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ModbusCfg.uuid)
}
#endif
inline void ModbusCfg::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ModbusCfg.uuid)
}
inline void ModbusCfg::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ModbusCfg.uuid)
}
inline ::std::string* ModbusCfg::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ModbusCfg.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModbusCfg::release_uuid() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ModbusCfg.uuid)
  if (!has_uuid()) {
    return NULL;
  }
  clear_has_uuid();
  return uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusCfg::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ModbusCfg.uuid)
}

// required string name = 2;
inline bool ModbusCfg::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModbusCfg::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModbusCfg::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModbusCfg::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ModbusCfg::name() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.name)
  return name_.GetNoArena();
}
inline void ModbusCfg::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.name)
}
#if LANG_CXX11
inline void ModbusCfg::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ModbusCfg.name)
}
#endif
inline void ModbusCfg::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ModbusCfg.name)
}
inline void ModbusCfg::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ModbusCfg.name)
}
inline ::std::string* ModbusCfg::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ModbusCfg.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModbusCfg::release_name() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ModbusCfg.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusCfg::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ModbusCfg.name)
}

// required .aubo.robot.communication.ModbusMode mode = 3;
inline bool ModbusCfg::has_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModbusCfg::set_has_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModbusCfg::clear_has_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModbusCfg::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::aubo::robot::communication::ModbusMode ModbusCfg::mode() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.mode)
  return static_cast< ::aubo::robot::communication::ModbusMode >(mode_);
}
inline void ModbusCfg::set_mode(::aubo::robot::communication::ModbusMode value) {
  assert(::aubo::robot::communication::ModbusMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.mode)
}

// required uint32 slave = 4;
inline bool ModbusCfg::has_slave() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModbusCfg::set_has_slave() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModbusCfg::clear_has_slave() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModbusCfg::clear_slave() {
  slave_ = 0u;
  clear_has_slave();
}
inline ::google::protobuf::uint32 ModbusCfg::slave() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.slave)
  return slave_;
}
inline void ModbusCfg::set_slave(::google::protobuf::uint32 value) {
  set_has_slave();
  slave_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.slave)
}

// required string ip = 5;
inline bool ModbusCfg::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModbusCfg::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModbusCfg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModbusCfg::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ModbusCfg::ip() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.ip)
  return ip_.GetNoArena();
}
inline void ModbusCfg::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.ip)
}
#if LANG_CXX11
inline void ModbusCfg::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ModbusCfg.ip)
}
#endif
inline void ModbusCfg::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ModbusCfg.ip)
}
inline void ModbusCfg::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ModbusCfg.ip)
}
inline ::std::string* ModbusCfg::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ModbusCfg.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModbusCfg::release_ip() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ModbusCfg.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusCfg::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ModbusCfg.ip)
}

// required uint32 port = 6;
inline bool ModbusCfg::has_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModbusCfg::set_has_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModbusCfg::clear_has_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModbusCfg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ModbusCfg::port() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.port)
  return port_;
}
inline void ModbusCfg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.port)
}

// required string device = 7;
inline bool ModbusCfg::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModbusCfg::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModbusCfg::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModbusCfg::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device();
}
inline const ::std::string& ModbusCfg::device() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.device)
  return device_.GetNoArena();
}
inline void ModbusCfg::set_device(const ::std::string& value) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.device)
}
#if LANG_CXX11
inline void ModbusCfg::set_device(::std::string&& value) {
  set_has_device();
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ModbusCfg.device)
}
#endif
inline void ModbusCfg::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ModbusCfg.device)
}
inline void ModbusCfg::set_device(const char* value, size_t size) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ModbusCfg.device)
}
inline ::std::string* ModbusCfg::mutable_device() {
  set_has_device();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ModbusCfg.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModbusCfg::release_device() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ModbusCfg.device)
  if (!has_device()) {
    return NULL;
  }
  clear_has_device();
  return device_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusCfg::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    set_has_device();
  } else {
    clear_has_device();
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ModbusCfg.device)
}

// required uint32 baud = 8;
inline bool ModbusCfg::has_baud() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ModbusCfg::set_has_baud() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ModbusCfg::clear_has_baud() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ModbusCfg::clear_baud() {
  baud_ = 0u;
  clear_has_baud();
}
inline ::google::protobuf::uint32 ModbusCfg::baud() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.baud)
  return baud_;
}
inline void ModbusCfg::set_baud(::google::protobuf::uint32 value) {
  set_has_baud();
  baud_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.baud)
}

// required string parity = 9;
inline bool ModbusCfg::has_parity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModbusCfg::set_has_parity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModbusCfg::clear_has_parity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModbusCfg::clear_parity() {
  parity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parity();
}
inline const ::std::string& ModbusCfg::parity() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.parity)
  return parity_.GetNoArena();
}
inline void ModbusCfg::set_parity(const ::std::string& value) {
  set_has_parity();
  parity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.parity)
}
#if LANG_CXX11
inline void ModbusCfg::set_parity(::std::string&& value) {
  set_has_parity();
  parity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ModbusCfg.parity)
}
#endif
inline void ModbusCfg::set_parity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parity();
  parity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ModbusCfg.parity)
}
inline void ModbusCfg::set_parity(const char* value, size_t size) {
  set_has_parity();
  parity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ModbusCfg.parity)
}
inline ::std::string* ModbusCfg::mutable_parity() {
  set_has_parity();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ModbusCfg.parity)
  return parity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModbusCfg::release_parity() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ModbusCfg.parity)
  if (!has_parity()) {
    return NULL;
  }
  clear_has_parity();
  return parity_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModbusCfg::set_allocated_parity(::std::string* parity) {
  if (parity != NULL) {
    set_has_parity();
  } else {
    clear_has_parity();
  }
  parity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parity);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ModbusCfg.parity)
}

// required uint32 data_bits = 10;
inline bool ModbusCfg::has_data_bits() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ModbusCfg::set_has_data_bits() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ModbusCfg::clear_has_data_bits() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ModbusCfg::clear_data_bits() {
  data_bits_ = 0u;
  clear_has_data_bits();
}
inline ::google::protobuf::uint32 ModbusCfg::data_bits() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.data_bits)
  return data_bits_;
}
inline void ModbusCfg::set_data_bits(::google::protobuf::uint32 value) {
  set_has_data_bits();
  data_bits_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.data_bits)
}

// required uint32 stop_bits = 11;
inline bool ModbusCfg::has_stop_bits() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ModbusCfg::set_has_stop_bits() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ModbusCfg::clear_has_stop_bits() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ModbusCfg::clear_stop_bits() {
  stop_bits_ = 0u;
  clear_has_stop_bits();
}
inline ::google::protobuf::uint32 ModbusCfg::stop_bits() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.stop_bits)
  return stop_bits_;
}
inline void ModbusCfg::set_stop_bits(::google::protobuf::uint32 value) {
  set_has_stop_bits();
  stop_bits_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.stop_bits)
}

// required uint32 response = 12;
inline bool ModbusCfg::has_response() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ModbusCfg::set_has_response() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ModbusCfg::clear_has_response() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ModbusCfg::clear_response() {
  response_ = 0u;
  clear_has_response();
}
inline ::google::protobuf::uint32 ModbusCfg::response() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.response)
  return response_;
}
inline void ModbusCfg::set_response(::google::protobuf::uint32 value) {
  set_has_response();
  response_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.response)
}

// required uint32 frequency = 13;
inline bool ModbusCfg::has_frequency() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ModbusCfg::set_has_frequency() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ModbusCfg::clear_has_frequency() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ModbusCfg::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 ModbusCfg::frequency() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ModbusCfg.frequency)
  return frequency_;
}
inline void ModbusCfg::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ModbusCfg.frequency)
}

// -------------------------------------------------------------------

// TagIoCfg

// required string io_name = 1;
inline bool TagIoCfg::has_io_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagIoCfg::set_has_io_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagIoCfg::clear_has_io_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagIoCfg::clear_io_name() {
  io_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_io_name();
}
inline const ::std::string& TagIoCfg::io_name() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.io_name)
  return io_name_.GetNoArena();
}
inline void TagIoCfg::set_io_name(const ::std::string& value) {
  set_has_io_name();
  io_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.io_name)
}
#if LANG_CXX11
inline void TagIoCfg::set_io_name(::std::string&& value) {
  set_has_io_name();
  io_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.TagIoCfg.io_name)
}
#endif
inline void TagIoCfg::set_io_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_io_name();
  io_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.TagIoCfg.io_name)
}
inline void TagIoCfg::set_io_name(const char* value, size_t size) {
  set_has_io_name();
  io_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.TagIoCfg.io_name)
}
inline ::std::string* TagIoCfg::mutable_io_name() {
  set_has_io_name();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.TagIoCfg.io_name)
  return io_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagIoCfg::release_io_name() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.TagIoCfg.io_name)
  if (!has_io_name()) {
    return NULL;
  }
  clear_has_io_name();
  return io_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagIoCfg::set_allocated_io_name(::std::string* io_name) {
  if (io_name != NULL) {
    set_has_io_name();
  } else {
    clear_has_io_name();
  }
  io_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), io_name);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.TagIoCfg.io_name)
}

// required .aubo.robot.communication.TagIoType io_type = 2;
inline bool TagIoCfg::has_io_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TagIoCfg::set_has_io_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TagIoCfg::clear_has_io_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TagIoCfg::clear_io_type() {
  io_type_ = 0;
  clear_has_io_type();
}
inline ::aubo::robot::communication::TagIoType TagIoCfg::io_type() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.io_type)
  return static_cast< ::aubo::robot::communication::TagIoType >(io_type_);
}
inline void TagIoCfg::set_io_type(::aubo::robot::communication::TagIoType value) {
  assert(::aubo::robot::communication::TagIoType_IsValid(value));
  set_has_io_type();
  io_type_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.io_type)
}

// required uint32 register_addr = 3;
inline bool TagIoCfg::has_register_addr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TagIoCfg::set_has_register_addr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TagIoCfg::clear_has_register_addr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TagIoCfg::clear_register_addr() {
  register_addr_ = 0u;
  clear_has_register_addr();
}
inline ::google::protobuf::uint32 TagIoCfg::register_addr() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.register_addr)
  return register_addr_;
}
inline void TagIoCfg::set_register_addr(::google::protobuf::uint32 value) {
  set_has_register_addr();
  register_addr_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.register_addr)
}

// required string modbus_uuid = 4;
inline bool TagIoCfg::has_modbus_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagIoCfg::set_has_modbus_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagIoCfg::clear_has_modbus_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagIoCfg::clear_modbus_uuid() {
  modbus_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modbus_uuid();
}
inline const ::std::string& TagIoCfg::modbus_uuid() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.modbus_uuid)
  return modbus_uuid_.GetNoArena();
}
inline void TagIoCfg::set_modbus_uuid(const ::std::string& value) {
  set_has_modbus_uuid();
  modbus_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.modbus_uuid)
}
#if LANG_CXX11
inline void TagIoCfg::set_modbus_uuid(::std::string&& value) {
  set_has_modbus_uuid();
  modbus_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.TagIoCfg.modbus_uuid)
}
#endif
inline void TagIoCfg::set_modbus_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modbus_uuid();
  modbus_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.TagIoCfg.modbus_uuid)
}
inline void TagIoCfg::set_modbus_uuid(const char* value, size_t size) {
  set_has_modbus_uuid();
  modbus_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.TagIoCfg.modbus_uuid)
}
inline ::std::string* TagIoCfg::mutable_modbus_uuid() {
  set_has_modbus_uuid();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.TagIoCfg.modbus_uuid)
  return modbus_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagIoCfg::release_modbus_uuid() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.TagIoCfg.modbus_uuid)
  if (!has_modbus_uuid()) {
    return NULL;
  }
  clear_has_modbus_uuid();
  return modbus_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagIoCfg::set_allocated_modbus_uuid(::std::string* modbus_uuid) {
  if (modbus_uuid != NULL) {
    set_has_modbus_uuid();
  } else {
    clear_has_modbus_uuid();
  }
  modbus_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modbus_uuid);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.TagIoCfg.modbus_uuid)
}

// required string io_id = 5;
inline bool TagIoCfg::has_io_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TagIoCfg::set_has_io_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TagIoCfg::clear_has_io_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TagIoCfg::clear_io_id() {
  io_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_io_id();
}
inline const ::std::string& TagIoCfg::io_id() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.io_id)
  return io_id_.GetNoArena();
}
inline void TagIoCfg::set_io_id(const ::std::string& value) {
  set_has_io_id();
  io_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.io_id)
}
#if LANG_CXX11
inline void TagIoCfg::set_io_id(::std::string&& value) {
  set_has_io_id();
  io_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.TagIoCfg.io_id)
}
#endif
inline void TagIoCfg::set_io_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_io_id();
  io_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.TagIoCfg.io_id)
}
inline void TagIoCfg::set_io_id(const char* value, size_t size) {
  set_has_io_id();
  io_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.TagIoCfg.io_id)
}
inline ::std::string* TagIoCfg::mutable_io_id() {
  set_has_io_id();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.TagIoCfg.io_id)
  return io_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagIoCfg::release_io_id() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.TagIoCfg.io_id)
  if (!has_io_id()) {
    return NULL;
  }
  clear_has_io_id();
  return io_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagIoCfg::set_allocated_io_id(::std::string* io_id) {
  if (io_id != NULL) {
    set_has_io_id();
  } else {
    clear_has_io_id();
  }
  io_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), io_id);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.TagIoCfg.io_id)
}

// required double io_value = 6;
inline bool TagIoCfg::has_io_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TagIoCfg::set_has_io_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TagIoCfg::clear_has_io_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TagIoCfg::clear_io_value() {
  io_value_ = 0;
  clear_has_io_value();
}
inline double TagIoCfg::io_value() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.TagIoCfg.io_value)
  return io_value_;
}
inline void TagIoCfg::set_io_value(double value) {
  set_has_io_value();
  io_value_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.TagIoCfg.io_value)
}

// -------------------------------------------------------------------

// ToolDigitalStatus

// required uint32 ioType = 1;
inline bool ToolDigitalStatus::has_iotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToolDigitalStatus::set_has_iotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToolDigitalStatus::clear_has_iotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToolDigitalStatus::clear_iotype() {
  iotype_ = 0u;
  clear_has_iotype();
}
inline ::google::protobuf::uint32 ToolDigitalStatus::iotype() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ToolDigitalStatus.ioType)
  return iotype_;
}
inline void ToolDigitalStatus::set_iotype(::google::protobuf::uint32 value) {
  set_has_iotype();
  iotype_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ToolDigitalStatus.ioType)
}

// required uint32 ioData = 2;
inline bool ToolDigitalStatus::has_iodata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ToolDigitalStatus::set_has_iodata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ToolDigitalStatus::clear_has_iodata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ToolDigitalStatus::clear_iodata() {
  iodata_ = 0u;
  clear_has_iodata();
}
inline ::google::protobuf::uint32 ToolDigitalStatus::iodata() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ToolDigitalStatus.ioData)
  return iodata_;
}
inline void ToolDigitalStatus::set_iodata(::google::protobuf::uint32 value) {
  set_has_iodata();
  iodata_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ToolDigitalStatus.ioData)
}

// -------------------------------------------------------------------

// RobotToolStatus

// required uint32 ioData = 1;
inline bool RobotToolStatus::has_iodata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotToolStatus::set_has_iodata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotToolStatus::clear_has_iodata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotToolStatus::clear_iodata() {
  iodata_ = 0u;
  clear_has_iodata();
}
inline ::google::protobuf::uint32 RobotToolStatus::iodata() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolStatus.ioData)
  return iodata_;
}
inline void RobotToolStatus::set_iodata(::google::protobuf::uint32 value) {
  set_has_iodata();
  iodata_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolStatus.ioData)
}

// repeated float aiData = 2;
inline int RobotToolStatus::aidata_size() const {
  return aidata_.size();
}
inline void RobotToolStatus::clear_aidata() {
  aidata_.Clear();
}
inline float RobotToolStatus::aidata(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolStatus.aiData)
  return aidata_.Get(index);
}
inline void RobotToolStatus::set_aidata(int index, float value) {
  aidata_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolStatus.aiData)
}
inline void RobotToolStatus::add_aidata(float value) {
  aidata_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.RobotToolStatus.aiData)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotToolStatus::aidata() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.RobotToolStatus.aiData)
  return aidata_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotToolStatus::mutable_aidata() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.RobotToolStatus.aiData)
  return &aidata_;
}

// required float systemVoltage = 3;
inline bool RobotToolStatus::has_systemvoltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotToolStatus::set_has_systemvoltage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotToolStatus::clear_has_systemvoltage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotToolStatus::clear_systemvoltage() {
  systemvoltage_ = 0;
  clear_has_systemvoltage();
}
inline float RobotToolStatus::systemvoltage() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolStatus.systemVoltage)
  return systemvoltage_;
}
inline void RobotToolStatus::set_systemvoltage(float value) {
  set_has_systemvoltage();
  systemvoltage_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolStatus.systemVoltage)
}

// required float systemTemperature = 4;
inline bool RobotToolStatus::has_systemtemperature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotToolStatus::set_has_systemtemperature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotToolStatus::clear_has_systemtemperature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotToolStatus::clear_systemtemperature() {
  systemtemperature_ = 0;
  clear_has_systemtemperature();
}
inline float RobotToolStatus::systemtemperature() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolStatus.systemTemperature)
  return systemtemperature_;
}
inline void RobotToolStatus::set_systemtemperature(float value) {
  set_has_systemtemperature();
  systemtemperature_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolStatus.systemTemperature)
}

// required uint32 errorStatus = 5;
inline bool RobotToolStatus::has_errorstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotToolStatus::set_has_errorstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotToolStatus::clear_has_errorstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotToolStatus::clear_errorstatus() {
  errorstatus_ = 0u;
  clear_has_errorstatus();
}
inline ::google::protobuf::uint32 RobotToolStatus::errorstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.RobotToolStatus.errorStatus)
  return errorstatus_;
}
inline void RobotToolStatus::set_errorstatus(::google::protobuf::uint32 value) {
  set_has_errorstatus();
  errorstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.RobotToolStatus.errorStatus)
}

// -------------------------------------------------------------------

// toolAllIOStatus

// required uint32 powerType = 1;
inline bool toolAllIOStatus::has_powertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void toolAllIOStatus::set_has_powertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void toolAllIOStatus::clear_has_powertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void toolAllIOStatus::clear_powertype() {
  powertype_ = 0u;
  clear_has_powertype();
}
inline ::google::protobuf::uint32 toolAllIOStatus::powertype() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.powerType)
  return powertype_;
}
inline void toolAllIOStatus::set_powertype(::google::protobuf::uint32 value) {
  set_has_powertype();
  powertype_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.toolAllIOStatus.powerType)
}

// required double systemVoltage = 2;
inline bool toolAllIOStatus::has_systemvoltage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void toolAllIOStatus::set_has_systemvoltage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void toolAllIOStatus::clear_has_systemvoltage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void toolAllIOStatus::clear_systemvoltage() {
  systemvoltage_ = 0;
  clear_has_systemvoltage();
}
inline double toolAllIOStatus::systemvoltage() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.systemVoltage)
  return systemvoltage_;
}
inline void toolAllIOStatus::set_systemvoltage(double value) {
  set_has_systemvoltage();
  systemvoltage_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.toolAllIOStatus.systemVoltage)
}

// required double systemTemperature = 3;
inline bool toolAllIOStatus::has_systemtemperature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void toolAllIOStatus::set_has_systemtemperature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void toolAllIOStatus::clear_has_systemtemperature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void toolAllIOStatus::clear_systemtemperature() {
  systemtemperature_ = 0;
  clear_has_systemtemperature();
}
inline double toolAllIOStatus::systemtemperature() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.systemTemperature)
  return systemtemperature_;
}
inline void toolAllIOStatus::set_systemtemperature(double value) {
  set_has_systemtemperature();
  systemtemperature_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.toolAllIOStatus.systemTemperature)
}

// required uint32 errorStatus = 4;
inline bool toolAllIOStatus::has_errorstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void toolAllIOStatus::set_has_errorstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void toolAllIOStatus::clear_has_errorstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void toolAllIOStatus::clear_errorstatus() {
  errorstatus_ = 0u;
  clear_has_errorstatus();
}
inline ::google::protobuf::uint32 toolAllIOStatus::errorstatus() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.errorStatus)
  return errorstatus_;
}
inline void toolAllIOStatus::set_errorstatus(::google::protobuf::uint32 value) {
  set_has_errorstatus();
  errorstatus_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.toolAllIOStatus.errorStatus)
}

// repeated .aubo.robot.communication.ToolDigitalStatus digitalIoStatus = 5;
inline int toolAllIOStatus::digitaliostatus_size() const {
  return digitaliostatus_.size();
}
inline void toolAllIOStatus::clear_digitaliostatus() {
  digitaliostatus_.Clear();
}
inline ::aubo::robot::communication::ToolDigitalStatus* toolAllIOStatus::mutable_digitaliostatus(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.toolAllIOStatus.digitalIoStatus)
  return digitaliostatus_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ToolDigitalStatus >*
toolAllIOStatus::mutable_digitaliostatus() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.toolAllIOStatus.digitalIoStatus)
  return &digitaliostatus_;
}
inline const ::aubo::robot::communication::ToolDigitalStatus& toolAllIOStatus::digitaliostatus(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.digitalIoStatus)
  return digitaliostatus_.Get(index);
}
inline ::aubo::robot::communication::ToolDigitalStatus* toolAllIOStatus::add_digitaliostatus() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.toolAllIOStatus.digitalIoStatus)
  return digitaliostatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ToolDigitalStatus >&
toolAllIOStatus::digitaliostatus() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.toolAllIOStatus.digitalIoStatus)
  return digitaliostatus_;
}

// repeated double aiData = 6;
inline int toolAllIOStatus::aidata_size() const {
  return aidata_.size();
}
inline void toolAllIOStatus::clear_aidata() {
  aidata_.Clear();
}
inline double toolAllIOStatus::aidata(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.toolAllIOStatus.aiData)
  return aidata_.Get(index);
}
inline void toolAllIOStatus::set_aidata(int index, double value) {
  aidata_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.toolAllIOStatus.aiData)
}
inline void toolAllIOStatus::add_aidata(double value) {
  aidata_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.toolAllIOStatus.aiData)
}
inline const ::google::protobuf::RepeatedField< double >&
toolAllIOStatus::aidata() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.toolAllIOStatus.aiData)
  return aidata_;
}
inline ::google::protobuf::RepeatedField< double >*
toolAllIOStatus::mutable_aidata() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.toolAllIOStatus.aiData)
  return &aidata_;
}

// -------------------------------------------------------------------

// ProtoCommunicationToolAllIOStatusInfoResponse

// required .aubo.robot.communication.toolAllIOStatus toolIOStatus = 1;
inline bool ProtoCommunicationToolAllIOStatusInfoResponse::has_tooliostatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::set_has_tooliostatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::clear_has_tooliostatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::clear_tooliostatus() {
  if (tooliostatus_ != NULL) tooliostatus_->Clear();
  clear_has_tooliostatus();
}
inline const ::aubo::robot::communication::toolAllIOStatus& ProtoCommunicationToolAllIOStatusInfoResponse::_internal_tooliostatus() const {
  return *tooliostatus_;
}
inline const ::aubo::robot::communication::toolAllIOStatus& ProtoCommunicationToolAllIOStatusInfoResponse::tooliostatus() const {
  const ::aubo::robot::communication::toolAllIOStatus* p = tooliostatus_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.toolIOStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::toolAllIOStatus*>(
      &::aubo::robot::communication::_toolAllIOStatus_default_instance_);
}
inline ::aubo::robot::communication::toolAllIOStatus* ProtoCommunicationToolAllIOStatusInfoResponse::release_tooliostatus() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.toolIOStatus)
  clear_has_tooliostatus();
  ::aubo::robot::communication::toolAllIOStatus* temp = tooliostatus_;
  tooliostatus_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::toolAllIOStatus* ProtoCommunicationToolAllIOStatusInfoResponse::mutable_tooliostatus() {
  set_has_tooliostatus();
  if (tooliostatus_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::toolAllIOStatus>(GetArenaNoVirtual());
    tooliostatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.toolIOStatus)
  return tooliostatus_;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::set_allocated_tooliostatus(::aubo::robot::communication::toolAllIOStatus* tooliostatus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tooliostatus_;
  }
  if (tooliostatus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tooliostatus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tooliostatus, submessage_arena);
    }
    set_has_tooliostatus();
  } else {
    clear_has_tooliostatus();
  }
  tooliostatus_ = tooliostatus;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.toolIOStatus)
}

// required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
inline bool ProtoCommunicationToolAllIOStatusInfoResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::clear_errorinfo() {
  if (errorinfo_ != NULL) errorinfo_->Clear();
  clear_has_errorinfo();
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationToolAllIOStatusInfoResponse::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationToolAllIOStatusInfoResponse::errorinfo() const {
  const ::aubo::robot::communication::ProtoRobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::ProtoRobotCommonResponse*>(
      &::aubo::robot::communication::_ProtoRobotCommonResponse_default_instance_);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationToolAllIOStatusInfoResponse::release_errorinfo() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationToolAllIOStatusInfoResponse::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.errorInfo)
  return errorinfo_;
}
inline void ProtoCommunicationToolAllIOStatusInfoResponse::set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete errorinfo_;
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationToolAllIOStatusInfoResponse.errorInfo)
}

// -------------------------------------------------------------------

// ProtoCommunicationRobotBoardFirmware

// required int32 command = 1;
inline bool ProtoCommunicationRobotBoardFirmware::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationRobotBoardFirmware::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotBoardFirmware::command() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.command)
  return command_;
}
inline void ProtoCommunicationRobotBoardFirmware::set_command(::google::protobuf::int32 value) {
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.command)
}

// required bytes firmwareContent = 2;
inline bool ProtoCommunicationRobotBoardFirmware::has_firmwarecontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationRobotBoardFirmware::set_has_firmwarecontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_has_firmwarecontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_firmwarecontent() {
  firmwarecontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firmwarecontent();
}
inline const ::std::string& ProtoCommunicationRobotBoardFirmware::firmwarecontent() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
  return firmwarecontent_.GetNoArena();
}
inline void ProtoCommunicationRobotBoardFirmware::set_firmwarecontent(const ::std::string& value) {
  set_has_firmwarecontent();
  firmwarecontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
}
#if LANG_CXX11
inline void ProtoCommunicationRobotBoardFirmware::set_firmwarecontent(::std::string&& value) {
  set_has_firmwarecontent();
  firmwarecontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
}
#endif
inline void ProtoCommunicationRobotBoardFirmware::set_firmwarecontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_firmwarecontent();
  firmwarecontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
}
inline void ProtoCommunicationRobotBoardFirmware::set_firmwarecontent(const void* value, size_t size) {
  set_has_firmwarecontent();
  firmwarecontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
}
inline ::std::string* ProtoCommunicationRobotBoardFirmware::mutable_firmwarecontent() {
  set_has_firmwarecontent();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
  return firmwarecontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoCommunicationRobotBoardFirmware::release_firmwarecontent() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
  if (!has_firmwarecontent()) {
    return NULL;
  }
  clear_has_firmwarecontent();
  return firmwarecontent_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoCommunicationRobotBoardFirmware::set_allocated_firmwarecontent(::std::string* firmwarecontent) {
  if (firmwarecontent != NULL) {
    set_has_firmwarecontent();
  } else {
    clear_has_firmwarecontent();
  }
  firmwarecontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwarecontent);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContent)
}

// required int32 firmwareContentSize = 3;
inline bool ProtoCommunicationRobotBoardFirmware::has_firmwarecontentsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoCommunicationRobotBoardFirmware::set_has_firmwarecontentsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_has_firmwarecontentsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoCommunicationRobotBoardFirmware::clear_firmwarecontentsize() {
  firmwarecontentsize_ = 0;
  clear_has_firmwarecontentsize();
}
inline ::google::protobuf::int32 ProtoCommunicationRobotBoardFirmware::firmwarecontentsize() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContentSize)
  return firmwarecontentsize_;
}
inline void ProtoCommunicationRobotBoardFirmware::set_firmwarecontentsize(::google::protobuf::int32 value) {
  set_has_firmwarecontentsize();
  firmwarecontentsize_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationRobotBoardFirmware.firmwareContentSize)
}

// -------------------------------------------------------------------

// ProtoCommunicationEthernetDeviceNameResponse

// required string name = 1;
inline bool ProtoCommunicationEthernetDeviceNameResponse::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ProtoCommunicationEthernetDeviceNameResponse::name() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
  return name_.GetNoArena();
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
}
#if LANG_CXX11
inline void ProtoCommunicationEthernetDeviceNameResponse::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
}
#endif
inline void ProtoCommunicationEthernetDeviceNameResponse::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
}
inline ::std::string* ProtoCommunicationEthernetDeviceNameResponse::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoCommunicationEthernetDeviceNameResponse::release_name() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.name)
}

// required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
inline bool ProtoCommunicationEthernetDeviceNameResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::clear_errorinfo() {
  if (errorinfo_ != NULL) errorinfo_->Clear();
  clear_has_errorinfo();
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationEthernetDeviceNameResponse::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationEthernetDeviceNameResponse::errorinfo() const {
  const ::aubo::robot::communication::ProtoRobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::ProtoRobotCommonResponse*>(
      &::aubo::robot::communication::_ProtoRobotCommonResponse_default_instance_);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationEthernetDeviceNameResponse::release_errorinfo() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationEthernetDeviceNameResponse::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.errorInfo)
  return errorinfo_;
}
inline void ProtoCommunicationEthernetDeviceNameResponse::set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete errorinfo_;
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationEthernetDeviceNameResponse.errorInfo)
}

// -------------------------------------------------------------------

// ProtoCommunicationDoubleVector

// required int32 num = 1;
inline bool ProtoCommunicationDoubleVector::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationDoubleVector::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationDoubleVector::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationDoubleVector::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ProtoCommunicationDoubleVector::num() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDoubleVector.num)
  return num_;
}
inline void ProtoCommunicationDoubleVector::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDoubleVector.num)
}

// repeated double value = 2;
inline int ProtoCommunicationDoubleVector::value_size() const {
  return value_.size();
}
inline void ProtoCommunicationDoubleVector::clear_value() {
  value_.Clear();
}
inline double ProtoCommunicationDoubleVector::value(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDoubleVector.value)
  return value_.Get(index);
}
inline void ProtoCommunicationDoubleVector::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDoubleVector.value)
}
inline void ProtoCommunicationDoubleVector::add_value(double value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationDoubleVector.value)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoCommunicationDoubleVector::value() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationDoubleVector.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoCommunicationDoubleVector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationDoubleVector.value)
  return &value_;
}

// -------------------------------------------------------------------

// ProtoCommunicationIntVector

// required int32 num = 1;
inline bool ProtoCommunicationIntVector::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationIntVector::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationIntVector::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationIntVector::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ProtoCommunicationIntVector::num() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationIntVector.num)
  return num_;
}
inline void ProtoCommunicationIntVector::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationIntVector.num)
}

// repeated int32 value = 2;
inline int ProtoCommunicationIntVector::value_size() const {
  return value_.size();
}
inline void ProtoCommunicationIntVector::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 ProtoCommunicationIntVector::value(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationIntVector.value)
  return value_.Get(index);
}
inline void ProtoCommunicationIntVector::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationIntVector.value)
}
inline void ProtoCommunicationIntVector::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationIntVector.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoCommunicationIntVector::value() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationIntVector.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoCommunicationIntVector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationIntVector.value)
  return &value_;
}

// -------------------------------------------------------------------

// ProtoCommunicationDoubleVectorResponse

// required int32 num = 1;
inline bool ProtoCommunicationDoubleVectorResponse::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationDoubleVectorResponse::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationDoubleVectorResponse::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationDoubleVectorResponse::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ProtoCommunicationDoubleVectorResponse::num() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.num)
  return num_;
}
inline void ProtoCommunicationDoubleVectorResponse::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.num)
}

// repeated double value = 2;
inline int ProtoCommunicationDoubleVectorResponse::value_size() const {
  return value_.size();
}
inline void ProtoCommunicationDoubleVectorResponse::clear_value() {
  value_.Clear();
}
inline double ProtoCommunicationDoubleVectorResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.value)
  return value_.Get(index);
}
inline void ProtoCommunicationDoubleVectorResponse::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.value)
}
inline void ProtoCommunicationDoubleVectorResponse::add_value(double value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.value)
}
inline const ::google::protobuf::RepeatedField< double >&
ProtoCommunicationDoubleVectorResponse::value() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
ProtoCommunicationDoubleVectorResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.value)
  return &value_;
}

// required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
inline bool ProtoCommunicationDoubleVectorResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationDoubleVectorResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationDoubleVectorResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationDoubleVectorResponse::clear_errorinfo() {
  if (errorinfo_ != NULL) errorinfo_->Clear();
  clear_has_errorinfo();
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationDoubleVectorResponse::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationDoubleVectorResponse::errorinfo() const {
  const ::aubo::robot::communication::ProtoRobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::ProtoRobotCommonResponse*>(
      &::aubo::robot::communication::_ProtoRobotCommonResponse_default_instance_);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationDoubleVectorResponse::release_errorinfo() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationDoubleVectorResponse::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.errorInfo)
  return errorinfo_;
}
inline void ProtoCommunicationDoubleVectorResponse::set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete errorinfo_;
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationDoubleVectorResponse.errorInfo)
}

// -------------------------------------------------------------------

// ProtoCommunicationIntVectorResponse

// required int32 num = 1;
inline bool ProtoCommunicationIntVectorResponse::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCommunicationIntVectorResponse::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCommunicationIntVectorResponse::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCommunicationIntVectorResponse::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ProtoCommunicationIntVectorResponse::num() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationIntVectorResponse.num)
  return num_;
}
inline void ProtoCommunicationIntVectorResponse::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationIntVectorResponse.num)
}

// repeated int32 value = 2;
inline int ProtoCommunicationIntVectorResponse::value_size() const {
  return value_.size();
}
inline void ProtoCommunicationIntVectorResponse::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 ProtoCommunicationIntVectorResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationIntVectorResponse.value)
  return value_.Get(index);
}
inline void ProtoCommunicationIntVectorResponse::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoCommunicationIntVectorResponse.value)
}
inline void ProtoCommunicationIntVectorResponse::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoCommunicationIntVectorResponse.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoCommunicationIntVectorResponse::value() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoCommunicationIntVectorResponse.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoCommunicationIntVectorResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoCommunicationIntVectorResponse.value)
  return &value_;
}

// required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 3;
inline bool ProtoCommunicationIntVectorResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCommunicationIntVectorResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCommunicationIntVectorResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCommunicationIntVectorResponse::clear_errorinfo() {
  if (errorinfo_ != NULL) errorinfo_->Clear();
  clear_has_errorinfo();
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationIntVectorResponse::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoCommunicationIntVectorResponse::errorinfo() const {
  const ::aubo::robot::communication::ProtoRobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoCommunicationIntVectorResponse.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::ProtoRobotCommonResponse*>(
      &::aubo::robot::communication::_ProtoRobotCommonResponse_default_instance_);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationIntVectorResponse::release_errorinfo() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoCommunicationIntVectorResponse.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoCommunicationIntVectorResponse::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoCommunicationIntVectorResponse.errorInfo)
  return errorinfo_;
}
inline void ProtoCommunicationIntVectorResponse::set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete errorinfo_;
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoCommunicationIntVectorResponse.errorInfo)
}

// -------------------------------------------------------------------

// ProtoJointCommonData

// required int32 JointCurVol = 1;
inline bool ProtoJointCommonData::has_jointcurvol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoJointCommonData::set_has_jointcurvol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoJointCommonData::clear_has_jointcurvol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoJointCommonData::clear_jointcurvol() {
  jointcurvol_ = 0;
  clear_has_jointcurvol();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointcurvol() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointCurVol)
  return jointcurvol_;
}
inline void ProtoJointCommonData::set_jointcurvol(::google::protobuf::int32 value) {
  set_has_jointcurvol();
  jointcurvol_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointCurVol)
}

// required int32 JointCurTemp = 2;
inline bool ProtoJointCommonData::has_jointcurtemp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoJointCommonData::set_has_jointcurtemp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoJointCommonData::clear_has_jointcurtemp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoJointCommonData::clear_jointcurtemp() {
  jointcurtemp_ = 0;
  clear_has_jointcurtemp();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointcurtemp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointCurTemp)
  return jointcurtemp_;
}
inline void ProtoJointCommonData::set_jointcurtemp(::google::protobuf::int32 value) {
  set_has_jointcurtemp();
  jointcurtemp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointCurTemp)
}

// required int32 JointWorkMode = 3;
inline bool ProtoJointCommonData::has_jointworkmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoJointCommonData::set_has_jointworkmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoJointCommonData::clear_has_jointworkmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoJointCommonData::clear_jointworkmode() {
  jointworkmode_ = 0;
  clear_has_jointworkmode();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointworkmode() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointWorkMode)
  return jointworkmode_;
}
inline void ProtoJointCommonData::set_jointworkmode(::google::protobuf::int32 value) {
  set_has_jointworkmode();
  jointworkmode_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointWorkMode)
}

// required int32 JointDriEnable = 4;
inline bool ProtoJointCommonData::has_jointdrienable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoJointCommonData::set_has_jointdrienable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoJointCommonData::clear_has_jointdrienable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoJointCommonData::clear_jointdrienable() {
  jointdrienable_ = 0;
  clear_has_jointdrienable();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointdrienable() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointDriEnable)
  return jointdrienable_;
}
inline void ProtoJointCommonData::set_jointdrienable(::google::protobuf::int32 value) {
  set_has_jointdrienable();
  jointdrienable_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointDriEnable)
}

// required int32 JointOpenPwm = 5;
inline bool ProtoJointCommonData::has_jointopenpwm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoJointCommonData::set_has_jointopenpwm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoJointCommonData::clear_has_jointopenpwm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoJointCommonData::clear_jointopenpwm() {
  jointopenpwm_ = 0;
  clear_has_jointopenpwm();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointopenpwm() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointOpenPwm)
  return jointopenpwm_;
}
inline void ProtoJointCommonData::set_jointopenpwm(::google::protobuf::int32 value) {
  set_has_jointopenpwm();
  jointopenpwm_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointOpenPwm)
}

// required int32 JointTagCurrent = 6;
inline bool ProtoJointCommonData::has_jointtagcurrent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoJointCommonData::set_has_jointtagcurrent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoJointCommonData::clear_has_jointtagcurrent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoJointCommonData::clear_jointtagcurrent() {
  jointtagcurrent_ = 0;
  clear_has_jointtagcurrent();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointtagcurrent() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointTagCurrent)
  return jointtagcurrent_;
}
inline void ProtoJointCommonData::set_jointtagcurrent(::google::protobuf::int32 value) {
  set_has_jointtagcurrent();
  jointtagcurrent_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointTagCurrent)
}

// required int32 JointTagSpeed = 7;
inline bool ProtoJointCommonData::has_jointtagspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoJointCommonData::set_has_jointtagspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoJointCommonData::clear_has_jointtagspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoJointCommonData::clear_jointtagspeed() {
  jointtagspeed_ = 0;
  clear_has_jointtagspeed();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointtagspeed() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointTagSpeed)
  return jointtagspeed_;
}
inline void ProtoJointCommonData::set_jointtagspeed(::google::protobuf::int32 value) {
  set_has_jointtagspeed();
  jointtagspeed_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointTagSpeed)
}

// required int32 JointTagPos = 8;
inline bool ProtoJointCommonData::has_jointtagpos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoJointCommonData::set_has_jointtagpos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoJointCommonData::clear_has_jointtagpos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoJointCommonData::clear_jointtagpos() {
  jointtagpos_ = 0;
  clear_has_jointtagpos();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointtagpos() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointTagPos)
  return jointtagpos_;
}
inline void ProtoJointCommonData::set_jointtagpos(::google::protobuf::int32 value) {
  set_has_jointtagpos();
  jointtagpos_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointTagPos)
}

// required int32 JointMaxCur = 9;
inline bool ProtoJointCommonData::has_jointmaxcur() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoJointCommonData::set_has_jointmaxcur() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoJointCommonData::clear_has_jointmaxcur() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoJointCommonData::clear_jointmaxcur() {
  jointmaxcur_ = 0;
  clear_has_jointmaxcur();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointmaxcur() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointMaxCur)
  return jointmaxcur_;
}
inline void ProtoJointCommonData::set_jointmaxcur(::google::protobuf::int32 value) {
  set_has_jointmaxcur();
  jointmaxcur_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointMaxCur)
}

// required int32 JointMaxSpeed = 10;
inline bool ProtoJointCommonData::has_jointmaxspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProtoJointCommonData::set_has_jointmaxspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProtoJointCommonData::clear_has_jointmaxspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProtoJointCommonData::clear_jointmaxspeed() {
  jointmaxspeed_ = 0;
  clear_has_jointmaxspeed();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointmaxspeed() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointMaxSpeed)
  return jointmaxspeed_;
}
inline void ProtoJointCommonData::set_jointmaxspeed(::google::protobuf::int32 value) {
  set_has_jointmaxspeed();
  jointmaxspeed_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointMaxSpeed)
}

// required int32 JointMaxAcc = 11;
inline bool ProtoJointCommonData::has_jointmaxacc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProtoJointCommonData::set_has_jointmaxacc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProtoJointCommonData::clear_has_jointmaxacc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProtoJointCommonData::clear_jointmaxacc() {
  jointmaxacc_ = 0;
  clear_has_jointmaxacc();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointmaxacc() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointMaxAcc)
  return jointmaxacc_;
}
inline void ProtoJointCommonData::set_jointmaxacc(::google::protobuf::int32 value) {
  set_has_jointmaxacc();
  jointmaxacc_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointMaxAcc)
}

// required int32 JointMINPos = 12;
inline bool ProtoJointCommonData::has_jointminpos() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProtoJointCommonData::set_has_jointminpos() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProtoJointCommonData::clear_has_jointminpos() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProtoJointCommonData::clear_jointminpos() {
  jointminpos_ = 0;
  clear_has_jointminpos();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointminpos() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointMINPos)
  return jointminpos_;
}
inline void ProtoJointCommonData::set_jointminpos(::google::protobuf::int32 value) {
  set_has_jointminpos();
  jointminpos_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointMINPos)
}

// required int32 JointMAXPos = 13;
inline bool ProtoJointCommonData::has_jointmaxpos() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointmaxpos() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProtoJointCommonData::clear_has_jointmaxpos() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProtoJointCommonData::clear_jointmaxpos() {
  jointmaxpos_ = 0;
  clear_has_jointmaxpos();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointmaxpos() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointMAXPos)
  return jointmaxpos_;
}
inline void ProtoJointCommonData::set_jointmaxpos(::google::protobuf::int32 value) {
  set_has_jointmaxpos();
  jointmaxpos_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointMAXPos)
}

// required int32 JointSEVLock = 14;
inline bool ProtoJointCommonData::has_jointsevlock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointsevlock() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProtoJointCommonData::clear_has_jointsevlock() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProtoJointCommonData::clear_jointsevlock() {
  jointsevlock_ = 0;
  clear_has_jointsevlock();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointsevlock() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointSEVLock)
  return jointsevlock_;
}
inline void ProtoJointCommonData::set_jointsevlock(::google::protobuf::int32 value) {
  set_has_jointsevlock();
  jointsevlock_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointSEVLock)
}

// required int32 JointCurP = 15;
inline bool ProtoJointCommonData::has_jointcurp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointcurp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProtoJointCommonData::clear_has_jointcurp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProtoJointCommonData::clear_jointcurp() {
  jointcurp_ = 0;
  clear_has_jointcurp();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointcurp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointCurP)
  return jointcurp_;
}
inline void ProtoJointCommonData::set_jointcurp(::google::protobuf::int32 value) {
  set_has_jointcurp();
  jointcurp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointCurP)
}

// required int32 JointCurI = 16;
inline bool ProtoJointCommonData::has_jointcuri() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointcuri() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProtoJointCommonData::clear_has_jointcuri() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProtoJointCommonData::clear_jointcuri() {
  jointcuri_ = 0;
  clear_has_jointcuri();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointcuri() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointCurI)
  return jointcuri_;
}
inline void ProtoJointCommonData::set_jointcuri(::google::protobuf::int32 value) {
  set_has_jointcuri();
  jointcuri_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointCurI)
}

// required int32 JointCurD = 17;
inline bool ProtoJointCommonData::has_jointcurd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointcurd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProtoJointCommonData::clear_has_jointcurd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProtoJointCommonData::clear_jointcurd() {
  jointcurd_ = 0;
  clear_has_jointcurd();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointcurd() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointCurD)
  return jointcurd_;
}
inline void ProtoJointCommonData::set_jointcurd(::google::protobuf::int32 value) {
  set_has_jointcurd();
  jointcurd_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointCurD)
}

// required int32 JointSpeedP = 18;
inline bool ProtoJointCommonData::has_jointspeedp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointspeedp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProtoJointCommonData::clear_has_jointspeedp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProtoJointCommonData::clear_jointspeedp() {
  jointspeedp_ = 0;
  clear_has_jointspeedp();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointspeedp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointSpeedP)
  return jointspeedp_;
}
inline void ProtoJointCommonData::set_jointspeedp(::google::protobuf::int32 value) {
  set_has_jointspeedp();
  jointspeedp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointSpeedP)
}

// required int32 JointSpeedI = 19;
inline bool ProtoJointCommonData::has_jointspeedi() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointspeedi() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ProtoJointCommonData::clear_has_jointspeedi() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ProtoJointCommonData::clear_jointspeedi() {
  jointspeedi_ = 0;
  clear_has_jointspeedi();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointspeedi() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointSpeedI)
  return jointspeedi_;
}
inline void ProtoJointCommonData::set_jointspeedi(::google::protobuf::int32 value) {
  set_has_jointspeedi();
  jointspeedi_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointSpeedI)
}

// required int32 JointSpeedD = 20;
inline bool ProtoJointCommonData::has_jointspeedd() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointspeedd() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ProtoJointCommonData::clear_has_jointspeedd() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ProtoJointCommonData::clear_jointspeedd() {
  jointspeedd_ = 0;
  clear_has_jointspeedd();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointspeedd() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointSpeedD)
  return jointspeedd_;
}
inline void ProtoJointCommonData::set_jointspeedd(::google::protobuf::int32 value) {
  set_has_jointspeedd();
  jointspeedd_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointSpeedD)
}

// required int32 JointSpeedDS = 21;
inline bool ProtoJointCommonData::has_jointspeedds() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointspeedds() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ProtoJointCommonData::clear_has_jointspeedds() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ProtoJointCommonData::clear_jointspeedds() {
  jointspeedds_ = 0;
  clear_has_jointspeedds();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointspeedds() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointSpeedDS)
  return jointspeedds_;
}
inline void ProtoJointCommonData::set_jointspeedds(::google::protobuf::int32 value) {
  set_has_jointspeedds();
  jointspeedds_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointSpeedDS)
}

// required int32 JointPosP = 22;
inline bool ProtoJointCommonData::has_jointposp() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointposp() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ProtoJointCommonData::clear_has_jointposp() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ProtoJointCommonData::clear_jointposp() {
  jointposp_ = 0;
  clear_has_jointposp();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointposp() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointPosP)
  return jointposp_;
}
inline void ProtoJointCommonData::set_jointposp(::google::protobuf::int32 value) {
  set_has_jointposp();
  jointposp_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointPosP)
}

// required int32 JointPosI = 23;
inline bool ProtoJointCommonData::has_jointposi() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointposi() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ProtoJointCommonData::clear_has_jointposi() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ProtoJointCommonData::clear_jointposi() {
  jointposi_ = 0;
  clear_has_jointposi();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointposi() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointPosI)
  return jointposi_;
}
inline void ProtoJointCommonData::set_jointposi(::google::protobuf::int32 value) {
  set_has_jointposi();
  jointposi_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointPosI)
}

// required int32 JointPosD = 24;
inline bool ProtoJointCommonData::has_jointposd() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointposd() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ProtoJointCommonData::clear_has_jointposd() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ProtoJointCommonData::clear_jointposd() {
  jointposd_ = 0;
  clear_has_jointposd();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointposd() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointPosD)
  return jointposd_;
}
inline void ProtoJointCommonData::set_jointposd(::google::protobuf::int32 value) {
  set_has_jointposd();
  jointposd_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointPosD)
}

// required int32 JointPosDS = 25;
inline bool ProtoJointCommonData::has_jointposds() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ProtoJointCommonData::set_has_jointposds() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ProtoJointCommonData::clear_has_jointposds() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ProtoJointCommonData::clear_jointposds() {
  jointposds_ = 0;
  clear_has_jointposds();
}
inline ::google::protobuf::int32 ProtoJointCommonData::jointposds() const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonData.JointPosDS)
  return jointposds_;
}
inline void ProtoJointCommonData::set_jointposds(::google::protobuf::int32 value) {
  set_has_jointposds();
  jointposds_ = value;
  // @@protoc_insertion_point(field_set:aubo.robot.communication.ProtoJointCommonData.JointPosDS)
}

// -------------------------------------------------------------------

// ProtoJointCommonDataResponse

// repeated .aubo.robot.communication.ProtoJointCommonData JointCommonData = 1;
inline int ProtoJointCommonDataResponse::jointcommondata_size() const {
  return jointcommondata_.size();
}
inline void ProtoJointCommonDataResponse::clear_jointcommondata() {
  jointcommondata_.Clear();
}
inline ::aubo::robot::communication::ProtoJointCommonData* ProtoJointCommonDataResponse::mutable_jointcommondata(int index) {
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoJointCommonDataResponse.JointCommonData)
  return jointcommondata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoJointCommonData >*
ProtoJointCommonDataResponse::mutable_jointcommondata() {
  // @@protoc_insertion_point(field_mutable_list:aubo.robot.communication.ProtoJointCommonDataResponse.JointCommonData)
  return &jointcommondata_;
}
inline const ::aubo::robot::communication::ProtoJointCommonData& ProtoJointCommonDataResponse::jointcommondata(int index) const {
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonDataResponse.JointCommonData)
  return jointcommondata_.Get(index);
}
inline ::aubo::robot::communication::ProtoJointCommonData* ProtoJointCommonDataResponse::add_jointcommondata() {
  // @@protoc_insertion_point(field_add:aubo.robot.communication.ProtoJointCommonDataResponse.JointCommonData)
  return jointcommondata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aubo::robot::communication::ProtoJointCommonData >&
ProtoJointCommonDataResponse::jointcommondata() const {
  // @@protoc_insertion_point(field_list:aubo.robot.communication.ProtoJointCommonDataResponse.JointCommonData)
  return jointcommondata_;
}

// required .aubo.robot.communication.ProtoRobotCommonResponse errorInfo = 2;
inline bool ProtoJointCommonDataResponse::has_errorinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoJointCommonDataResponse::set_has_errorinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoJointCommonDataResponse::clear_has_errorinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoJointCommonDataResponse::clear_errorinfo() {
  if (errorinfo_ != NULL) errorinfo_->Clear();
  clear_has_errorinfo();
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoJointCommonDataResponse::_internal_errorinfo() const {
  return *errorinfo_;
}
inline const ::aubo::robot::communication::ProtoRobotCommonResponse& ProtoJointCommonDataResponse::errorinfo() const {
  const ::aubo::robot::communication::ProtoRobotCommonResponse* p = errorinfo_;
  // @@protoc_insertion_point(field_get:aubo.robot.communication.ProtoJointCommonDataResponse.errorInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::aubo::robot::communication::ProtoRobotCommonResponse*>(
      &::aubo::robot::communication::_ProtoRobotCommonResponse_default_instance_);
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoJointCommonDataResponse::release_errorinfo() {
  // @@protoc_insertion_point(field_release:aubo.robot.communication.ProtoJointCommonDataResponse.errorInfo)
  clear_has_errorinfo();
  ::aubo::robot::communication::ProtoRobotCommonResponse* temp = errorinfo_;
  errorinfo_ = NULL;
  return temp;
}
inline ::aubo::robot::communication::ProtoRobotCommonResponse* ProtoJointCommonDataResponse::mutable_errorinfo() {
  set_has_errorinfo();
  if (errorinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::aubo::robot::communication::ProtoRobotCommonResponse>(GetArenaNoVirtual());
    errorinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aubo.robot.communication.ProtoJointCommonDataResponse.errorInfo)
  return errorinfo_;
}
inline void ProtoJointCommonDataResponse::set_allocated_errorinfo(::aubo::robot::communication::ProtoRobotCommonResponse* errorinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete errorinfo_;
  }
  if (errorinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      errorinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errorinfo, submessage_arena);
    }
    set_has_errorinfo();
  } else {
    clear_has_errorinfo();
  }
  errorinfo_ = errorinfo;
  // @@protoc_insertion_point(field_set_allocated:aubo.robot.communication.ProtoJointCommonDataResponse.errorInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace communication
}  // namespace robot
}  // namespace aubo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aubo::robot::communication::ModbusMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::communication::ModbusMode>() {
  return ::aubo::robot::communication::ModbusMode_descriptor();
}
template <> struct is_proto_enum< ::aubo::robot::communication::TagIoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aubo::robot::communication::TagIoType>() {
  return ::aubo::robot::communication::TagIoType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_robotcommunication_2eproto
